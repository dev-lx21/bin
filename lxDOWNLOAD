#!/bin/bash
# skript von -lx-

#strBefehlName="youtube-dl"
strBefehlName="yt-dlp"
strBefehlKonfigDatei=~/.config/youtube-dl/config

#[[ -f "$strBefehlKonfigDatei" ]] && echo -e "--- DEBUG Datei vorhanden: $strBefehlKonfigDatei"
#exit 0;

# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------
# ----- ToDo:
# -Max Anzahl Downloads pro Verzeichnis
# -System ausschalten prüfen, bei egal welcher Taste muss das Ausschalten abgebrochen werden
# -Video Info bei einzelnen URLs
#
# ----- DONE:
# -Max Anzahl Zeichen für Playlist Info
# -Stats Infos nur innerhalb der 3 Stats Zeilen (und nicht in den Menü Zeilen)
# -URL Datei löschen, danach FAV Aufruf, danach Möglichkeit URLs zu bearbeiten
# -Verarbeitungsgeschwindigkeit verbessert, Stats kopieren und Stats auslesen
# -Auswahl Möglichkeit: Playlist Aufruf oder Playlist-Items Aufruf
#
# ----- Bugs:
# -archiv bei Force
#
# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------
# [[ -z "$1" ]] && echo -e "[FEHLER: ${FUNCNAME[0]} - Kein oder fehlerhaftes Argument übergeben! - '$*']" && return
# -------------------------------------------------------------------------------------------------
# ----- START -------------------------------------------------------------------------------------
# ----- ENDE --------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------




function fncDEBUGstart {
    flagFNCdebug="true"
    [ "$1" ] && txtDEBUGtitel="$1" || txtDEBUGtitel="$0"
    echo -e "--------------------------------------------------------------------------------"
    echo -e "--- [`fncHHMMSS 'norm.mS3'`] - START Debug: $txtDEBUGtitel"
    PS4='+ ${LINENO}:'`echo -en '\\t'`
    set -x
}

function fncDEBUGstop {
    # -Damit fncDEBUGstop nur ausgeführt wird, wenn vorher fncDEBUGstart aufgerufen wurde.
    [ ! "$flagFNCdebug" ] && return
    set +x
    [ "$1" ] && txtDEBUGtitel="$1" || txtDEBUGtitel="$0"
    echo -e "--- [`fncHHMMSS 'norm.mS3'`] - ENDE Debug: $txtDEBUGtitel"
    echo -e "--------------------------------------------------------------------------------"
}


function fncClearX {
    # -Da 'clear -x' einen Bug hat und deshalb den sichtbaren Teil der letzten
    #  Befehle einfach löscht, werden soviele leere Zeilen ausgegeben, wie der
    #  Bildschirm Zeilen hat.
    # -Beim Aufruf von 'clear -x' löscht der Befehl dann diese leeren Zeilen
    #  und die History wird nicht überschrieben.
    typeset -i intAnzahlScreenZeilen=$(tput lines)
    for ((iZeilen=1; iZeilen<$intAnzahlScreenZeilen; iZeilen++))
    do
        echo -e "$iZeilen"
    done
    clear -x
}


dateiVersionInfoNr=""
function fncAUSLESENversion {
    [ -z $datei ] && datei=${0//*\//}
    [ -z $nutzer ] && nutzer=`ps --pid $$ -o user=` && [[ "$nutzer" == "root" ]] && nutzer=`id -un 1000`
    strVERZEICHNISbin="/home/$nutzer/bin-bak/"
    iaLSarray=(`ls -r $strVERZEICHNISbin$datei"_"* 2>/dev/null`)
    iaLSarrayANZAHL=${#iaLSarray[@]}
    dateiNameKomplett=${iaLSarray[0]}
    dateiVersionKomplett=${iaLSarray[0]}
    
    #  foo/bar/lxDOWNLOAD_2.17.05-01-01_TODO_einbauen-dateiVersionNrTxt
    
    # -Bis zum letzten Slash abschneiden:
    dateiVersionKomplett=${dateiVersionKomplett//*\//}
    #  lxDOWNLOAD_2.17.05-01-01_TODO_einbauen-dateiVersionNrTxt
    
    # -Dateiname bis Unterstrich abschneiden:
    dateiVersionKomplett=${dateiVersionKomplett//`echo -e $datei`_/}
    #  2.17.05-01-01_TODO_einbauen-dateiVersionNrTxt
    
    # -Unterstrich bis zum Ende abschneiden: dateiVersionInfoNr
    dateiVersionInfoNr=${dateiVersionKomplett//_*/}
    #  2.17.05-01-01
    
    # -Bis zum Unterstrich abschneiden: dateiVersionKomplettTxt
    dateiVersionKomplettTxt=${dateiVersionKomplett//$dateiVersionInfoNr\_/}
    #  TODO_einbauen-dateiVersionNrTxt
    
    # -Nur die Kategorie ausschneiden:
    dateiVersionInfoKategorie=${dateiVersionKomplettTxt//_*/}
    #  TODO
    
    # -Nur den Infotext ausschneiden: 
    dateiVersionInfoTxt=${dateiVersionKomplettTxt//$dateiVersionInfoKategorie\_/}
    #  einbauen-dateiVersionNrTxt
    
    dateiVersionInfoNr="$dateiVersionInfoNr"
    dateiVersionInfoKategorie="$dateiVersionInfoKategorie"
    dateiVersionInfoTxt="$dateiVersionInfoTxt"
    
}
[ -z $dateiVersionInfoNr ] && fncAUSLESENversion


function fncANZAHLzeichen {
    # -Die Anzahl der Zeichen in $1 ermitteln und mittels echo ausgeben!
    [ ! "$1" ] && echo -e "[Kein Argument übergegeben: fncANZAHLzeichen]" && return 10
    echo -e "${#1}"
}


txtPLATZHALTER=""
function fncECHOplatzhalter {
    # -Die Anzahl der Zeichen in $1 ermitteln und damit eine Linie als
    #  PLATZHALTER erstellen!
    # -ZeichenRandUhrzeit: "|- [09:31:37] "
    # -Maximale Gesamtzeichenanzahl:
    #  intZZmax=intLayoutMaxSpalten-intAnzahlZeichenRandUhrzeit
    # -Am Ende werden $1 und $txtPLATZHALTER gemeinsam ausgegeben.
    #  --------------------------------------------------------------------------------
    txtPLATZHALTER=""
    txtLEERZEICHEN=""
    typeset -i intZZmax=0
    typeset -i intZZplatzhalter=0
    [ ! "$1" ] && intZZplatzhalter=$intZZmax
    
    # -WICHTIG: Der Platzhalter wird mit der maximalen Länge erstellt und in die Logdatei
    #  geschrieben. Bei der Ausgabe in den dynamischen Statuszeilen wird die Länge kontrolliert
    #  und ggf korrigiert. Siehe intSTATUSzeichenMAX.
    intZZmax=$intLayoutMaxSpalten
    
    #echo -e "${#1}"
    # -Damit zwischen $1 und $txtPLATZHALTER genau 1 Leerzeichen ist,
    #  wird das letzte Zeichen von $1 entsprechend ausgeschnitten und
    #  überprüft:
    [ "$1" ] && [ -n "${1: -1}" ] && txtLEERZEICHEN=" "
    [ "$1" ] && intZZplatzhalter=intZZmax-${#1}-${#txtLEERZEICHEN}
    # -Den Platzhalter mittels Schleife zusammenbauen:
    while ( [[ $intZZplatzhalter -gt 0 ]] )
    do
        txtPLATZHALTER=$txtPLATZHALTER"-"
        intZZplatzhalter=intZZplatzhalter-1
    done
    # -$1 und $PLATZHALTER direkt ausgeben:
    echo -e "$1""$txtLEERZEICHEN""$txtPLATZHALTER"
}


function fncCheckEingabeDoppelteEntfernen {
    # -Ein durch Leerzeichen getrennter String wird aufgeteilt und mittels Array
    #  auf doppelte Einträge geprüft, korrigiert und wieder ausgegeben!
    # -Gecheckt wird die komplette Übergabe: $@
    
    #echo -e "$@" && return
    [[ "$1" == "" ]] && echo -e "[Kein Argument übergegeben: fncCheckEingabeDoppelteEntfernen]" && return 10
    
    arrFncEingabe=("$@")
    #arrFncEingabeKontrolle=("$@")

    typeset -i zz=0
    zz=0
    for i in "${arrFncEingabe[@]}"
    do
        i=${i//:\/\/www./:\/\/}
        #echo -e "-- Array i - $zz - Feld-i: $i"
        [ $zz -eq 0 ] && arrFncEingabeKontrolle[$zz]="$i" && zz=zz+1 && continue
        #zz=zz+1
        flagEingabeKontrolleNeu="true"
        flagEingabeKontrolleDoppelt="false"
        for ii in "${arrFncEingabeKontrolle[@]}"
        do
            ii=${ii//:\/\/www./:\/\/}
            #echo -e "-- arrFncEingabeKontrolle - $zz - i: $i - ii: $ii\\n"
            #[[ "$i" != *${arrFncEingabeKontrolle[*]}* ]] && arrFncEingabeKontrolle[$zz]="$i" && zz=zz+1
            [[ "$i" == *$ii* ]] && flagEingabeKontrolleNeu="false" # && echo -e "-- arrFncEingabeKontrolle - $zz - i: $i"
        done
        [[ "$flagEingabeKontrolleNeu" == "true" ]] && arrFncEingabeKontrolle[$zz]="$i" && zz=zz+1
        #echo -e "-- Array - $zz. Feld: $i"
    done
    
    #echo -e " |-----| ${#arrFncEingabe[@]} - ${#arrFncEingabeKontrolle[@]} - |-----|"
    echo -e "${arrFncEingabeKontrolle[@]}"
    
}








pfad="$1"
flag_update=$2
flag_aufruf_intern=$3
zeitSTARTutc=`date '+%s'`
zeitSTART=`date -d @$zeitSTARTutc`
zeitSTARTdateiname=`date -d @$zeitSTARTutc '+%F_%T'`
zeitSTARTdateiname=${zeitSTARTdateiname//\-/}
zeitSTARTdateiname=${zeitSTARTdateiname//:/}
zeitSTARTdateiname=${zeitSTARTdateiname//_/\-}
flagACTION="false"


# echo -e "${fmtFETT}text...blabla${fmtRESET}"
fmtFETT=`tput bold`
fmtINVERS=`tput rev`
fmtUNTERSTRICHEN=`tput smul`

fmtCOLORfgBLAU=`tput setf 1`
fmtCOLORfgGRUEN=`tput setf 2`
fmtCOLORfgGELB=`tput setf 3`
fmtCOLORfgROT=`tput setf 4`
fmtCOLORbgBLAU=`tput setb 1`
fmtCOLORbgGRUEN=`tput setb 2`
fmtCOLORbgGELB=`tput setb 3`
fmtCOLORbgROT=`tput setb 4`

fmtRESET=`tput sgr0`


[[ ! $dateiVersionInfoNr ]] && fncAUSLESENversion
[[ -z "$datei" ]] && echo -e "[FEHLER: Variable konnte nicht gelesen werden: 'datei']" && exit 22;
txtTITEL="Video-, Audiodateien oder komplette HTML-Seiten herunterladen!"


# -DEBUG-INFO:
# echo -e "--- zeitSTARTutc:\\t$zeitSTARTutc"
# echo -e "--- zeitSTART:\\t\\t$zeitSTART"
# echo -e "--- zeitSTARTdateiname:\\t$zeitSTARTdateiname"
# fncAUSLESENversion
# echo -e "--- DEBUG-INFO: Version: $dateiVersionInfoNr"




# ***** Cache des Downloaders leeren: *************************************************************
# -Nur Starten wenn NICHT:
#  Logs, Hilfe, ShortcutCD (Verzeichniswechsel) aufgerufen wurden!
#
if ( [[ "$1" != -*PS* ]] && [[ "$1" != -*l* ]] && [[ "$1" != -*h* ]] && [[ "$1" != -*scl* ]] && [[ "$1" != -*sccd* ]] && [[ "$1" != -*conf* ]] )
then
    echo -e "|-"
    echo -e "|- $datei: Download Cache leeren: START!"
    echo -e "|-"
    sleep 0.2
    echo -e "|- $datei: $strBefehlName "`$strBefehlName --version`
    echo -e "|-"
    sleep 0.2
    # -Cache leeren:
    echo -e "|- $datei: $strBefehlName "`$strBefehlName -i -v --rm-cache-dir`
    #echo -e "--- Cache NICHT leeren! ---" && sleep 2
    sleep 0.2
    echo -e "|-"
    sleep 0.2
    echo -e "|- $datei: Download Cache leeren: FERTIG!"
    sleep 0.2
    echo -e "|-"
    sleep 2
fi





function fncHHMMSS {
    case "$1" in
        ( nurZAHLEN )
            echo -en `date '+%H%M%S'` ;;
        ( nurSS )
            echo -en `date '+%S'` ;;
        ( nurSS.S )
            echo -en `date '+%S.%N'` ;;
        ( nurSS.mS3 )
            HMSmS=`date '+%S.%N'`
            HMSxyz=${HMSmS//.*/}
            mSxyz=${HMSmS//*./}
            mSxyz=${mSxyz:0:3}
            echo -en $HMSxyz"."$mSxyz ;;
        ( norm.mS2 )
            HMSmS=`date '+%H:%M:%S.%N'`
            HMSxyz=${HMSmS//.*/}
            mSxyz=${HMSmS//*./}
            mSxyz=${mSxyz:0:2}
            echo -en $HMSxyz"."$mSxyz ;;
        ( norm.mS3 )
            HMSmS=`date '+%H:%M:%S.%N'`
            HMSxyz=${HMSmS//.*/}
            mSxyz=${HMSmS//*./}
            mSxyz=${mSxyz:0:3}
            echo -en $HMSxyz"."$mSxyz ;;
        (*)
            echo -en `date '+%H:%M:%S'` ;;
    esac
    #echo -en `date '+%H:%M:%S'`
}

function fncYEAR1231 {
    case "$1" in
        ( nurZAHLEN )
            echo -en `date '+%Y%m%d'`
            ;;
        ( YEAR )
            echo -en `date '+%Y'`
            ;;
        ( 12 )
            echo -en `date '+%m'`
            ;;
        ( 31 )
            echo -en `date '+%d'`
            ;;
        ( 1231 )
            echo -en `date '+%m%d'`
            ;;
        (*)
            echo -en `date '+%Y-%m-%d'`
            ;;
    esac
}


function getCPos { 
    local v=() t=$(stty -g)
    stty -echo
    printf "\033[6n"
    IFS='[;' read -ra v -d R
    stty $t
    CPos=(${v[@]:1})
    CPosSPALTE=(${v[@]:2})
}


function fncAusgabeDialogBeendet {
    if ( [[ `tty` == *dev* ]] )
    then
        #[[ `tty` == *dev* ]] && kdialog --title "$datei.Ende `fncHHMMSS 'norm.mS2'`:" --msgbox " --- <b>$datei:</b> --- <br><br>$datei wurde beendet!<br>" --geometry=500x300 >/dev/null 2>&1 &
        #kdialog --title "$datei.Info" --msgbox " --- <b>$datei.Info:</b> --- <br><br>$datei wurde beendet!<br><br>Zeit: `fncHHMMSS 'norm.mS2'` - PID: $$" >/dev/null 2>&1 &
        kdialog --title "$datei.Info" --msgbox " --- <b>$datei.Info:</b> --- <br><br>$datei wurde beendet!<br>$txtInfoStatusDialog$txtInfoDialogMenueEnde<br><br>Zeit: `fncHHMMSS 'norm.mS2'` - PID: $$" >/dev/null 2>&1 &
    fi
}






















# -------------------------------------------------------------------------------------------------------------
# ----- START Prozess Option --------------------------------------------------------------------------
arrPROZESSE=($datei $strBefehlName ffmpeg wget cpulimit)


function fncKILLallePROZESSE {
    # -Alle Instanzen der genutzten Programme auslesen und beenden!
    # --WICHTIG: Nur im eigenen Terminal! Wenn $1==""
    # --WICHTIG: Nur im eigenen Terminal! Wenn $1=="EIGENESTTY"
    # --WICHTIG: Nur im eigenen Terminal! Wenn $1=="*"
    # --WICHTIG: In allen Terminals! Wenn $1=="ALLETTY"
    #
    for i in "${arrPROZESSE[@]}"
    do
        if ( [[ "$1" == "" ]] || [[ "$1" == "EIGENESTTY" ]] )
        then
            arrTERMINALS=`tty`
        elif ( [[ "$1" == "ALLETTY" ]] )
        then
            arrTERMINALS=(`ps -C $i -o tty=`)
        else
            arrTERMINALS=`tty`
        fi
        iTalle=""
        for iT in "${arrTERMINALS[@]}"
        do
            if ( [[ "$iTalle" != *$iT* ]] )
            then
                echo -e "- Prozess: $i"
                echo -e "- Terminal: "$iT

                ausgabe=`ps -ll --tty $iT | grep -i $i`
                if ( [[ "$ausgabe" != "" ]] )
                then
                    echo -e "$ausgabe"
                    echo -e "-"
                fi
                

                #strTERMINAL=`tty`
                #strTERMINAL="pts/5"
                strTERMINAL=$iT
                strLISTEtoKILL=""
                ausgabePIDs=""
                ausgabeCHILDPIDs=""
                #ausgabe=`lxPS -qs $i`
                #ausgabe=`ps -All --tty "/dev/pts/5" | grep -i $1`
                ausgabeLISTEdisplay=`ps --tty $strTERMINAL -o pid=`
                ausgabeLISTEname=`ps -C $i -o pid=`
                #ausgabeLISTEkombiniert=`ps --tty $strTERMINAL -l | grep -i $i`
                #ausgabeLISTEkombiniert=`ps --tty "pts/5" -l | grep -i $i`
                ausgabeLISTEkombiniert=`ps --tty $strTERMINAL -o pid= -o tty= -o comm= | grep -i $i`
                arrLISTEpid=($ausgabeLISTEkombiniert)
                #echo -e "- Kombiniert: "$ausgabeLISTEkombiniert
                
                typeset -i zL=0
                echo -e "- PIDs:"
                #while ( [[ "${arrLISTEpid[$zL]}" != "" ]] && [[ "${arrLISTEpid[$zL]}" != "$$" ]] )
                while ( [[ "${arrLISTEpid[$zL]}" != "" ]] )
                do
                    ausgabePIDsTMP="${arrLISTEpid[$zL]}"
                    echo -en "- PID: "$ausgabePIDsTMP
                    if ( [[ "$ausgabePIDsTMP" == "$$" ]] )
                    then
                        #continue
                        flagEIGENEpsid="true"
                    fi
                    if ( [[ "$ausgabePIDsTMP" != "" ]] && [[ "$ausgabePIDsTMP" != "$$" ]] )
                    then
                        if ( [[ "$strLISTEtoKILL" == "" ]] )
                        then
                            strLISTEtoKILL=$ausgabePIDsTMP
                        else
                            strLISTEtoKILL=$strLISTEtoKILL" "$ausgabePIDsTMP
                        fi
                    fi
                    ausgabeCHILDPIDsTMP=`ps --ppid ${arrLISTEpid[$zL]} -o pid=`
                    if ( [[ $ausgabeCHILDPIDsTMP != "" ]] )
                    then
                        echo -en " CPIDs: "$ausgabeCHILDPIDsTMP" --- "
                        strLISTEtoKILL=$strLISTEtoKILL" "$ausgabeCHILDPIDsTMP
                    fi
                    zL=zL+3
                done
                echo -e "\\n---"

                if ( [[ "$ausgabeLISTEkombiniert" != "" ]] )
                then
                    #echo -e "- PIDs: "$ausgabePIDs
                    #echo -e "- CPIDs:"$ausgabeCHILDPIDs
                    if ( [[ "$strLISTEtoKILL" != "" ]] )
                    then
                        #echo -e "kill -9 oder -14... "$strLISTEtoKILL
                        #kill -9 $ausgabePIDs $ausgabeCHILDPIDs
                        #echo -e "- Komplette Liste:"\\n$strLISTEtoKILL\\n"---"
                        
                        # -Doppelte PIDs in der Liste führen zu unnötigen Fehlermeldungen, daher
                        #  werden diese erkannt und entfernt!
                        echo -e "- Komplette Liste (bereinigt):"
                        arrLISTEtoKILL=($strLISTEtoKILL)
                        typeset -i zLK=0
                        strLISTEpidBENUTZT=""
                        flagLISTEtoKILLfertig="false"
                        while ( [[ "${arrLISTEtoKILL[$zLK]}" != "" ]] )
                        do
                            if ( [[ "$strLISTEpidBENUTZT" != *${arrLISTEtoKILL[$zLK]}* ]] && [[ `ps -p ${arrLISTEtoKILL[$zLK]} | grep -i ${arrLISTEtoKILL[$zLK]}` != "" ]] )
                            then
                                strLISTEpidBENUTZT=$strLISTEpidBENUTZT" "${arrLISTEtoKILL[$zLK]}
                                echo -en "${arrLISTEtoKILL[$zLK]} "
                                flagLISTEtoKILLfertig="true"
                            fi
                            zLK=zLK+1
                        done
                        echo -e \\b
                        if ( [[ "$flagLISTEtoKILLfertig" == "true" ]] )
                        then
                            echo -e "- Der Kill Befehl:"\\n"'kill -9 $strLISTEpidBENUTZT'"
                            kill -9 $strLISTEpidBENUTZT 2>/dev/null
                        else
                            echo -e "- INFO: Die Prozesse wurden bereits beendet!"
                        fi
                    else
                        echo -e "- INFO: Keine Prozesse zum Beenden gefunden!"
                    fi
                else
                    echo -e "- INFO: $i wurde nicht in der Prozessliste gefunden!"
                fi
                echo -e "-"

            fi
            iTalle=$iTalle" "$iT
        done
    done
}

#fncKILLallePROZESSE "EIGENESTTY"
#fncKILLallePROZESSE "ALLETTY"



if ( [[ "$1" == "-PS" ]] )
then
    echo -e "-"\\n"--- Alle Prozesse in allen Terminals anzeigen: ----------------------------------------------------"\\n"-"
    for i in "${arrPROZESSE[@]}"
    do
        echo -e "- Prozess: $i"
        ausgabe=`lxPS -qs $i`
        if ( [[ "$ausgabe" != "" ]] )
        then
            echo -e "$ausgabe"
        else
            echo -e "- INFO: $i wurde nicht in der Prozessliste gefunden!"
        fi
        echo -e "-"
    done
    exit 0;
fi

if ( [[ "$1" == "-PSK" ]] )
then
    echo -e "-"\\n"--- Alle Prozesse im eigenen Terminal anzeigen und beenden (kill): --------------------------------"\\n"-"
    fncKILLallePROZESSE "EIGENESTTY"
    exit 0;
fi

if ( [[ "$1" == "-PSKA" ]] )
then
    echo -e "-"\\n"--- Alle Prozesse in allen Terminals anzeigen und beenden (kill): ---------------------------------"\\n"-"
    fncKILLallePROZESSE "ALLETTY"
    exit 0;
fi
# ----- ENDE Prozess Option ---------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------














# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# ----- START Standardparameter setzen ----------------------------------------------------------------------
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# -Der Aufruf mit den Standard Optionen:
actionDATEIoptionen="$strBefehlName --config-locations $strBefehlKonfigDatei -v -i --add-metadata --restrict-filenames"
#actionDATEIoptionen="$strBefehlName -i --add-metadata --restrict-filenames"
#actionDATEIoptionen="/usr/local/bin/$strBefehlName_ARD-hack_v2020.05.29 -v -i --add-metadata --restrict-filenames"
#actionDATEIoptionen="/usr/bin/$strBefehlName -v -i --add-metadata --restrict-filenames"


# -Mehrere Möglichkeiten zum Login für bestimmte Webseiten:
# -1.: Die Daten im Befehlsaufruf übergeben: '-u Benutzername -p Kennwort'
#      -Wird '-p' nicht gesetzt, wird das Kennwort während der Ausführung abgefragt.
# -2.: Die Daten in einer .netrc Datei im Home Verzeichnis ablegen
#
# -Beide Verfahren sind schlecht! (Login Daten im Befehlsaufruf und in der Befehlshistory, .netrc Datei
#  ist unverschlüsselt und ihre Nutzung nur durch die Zugriffsrechte beschränkt)
#
# -BESSER: Logindaten bei Bedarf mittels Kdialog erfassen!
# --Bietet die Möglichkeit für individuelle Logindaten bei den verschiedenen Videoportalen!
#
actionLoginDaten=""
#actionLoginDaten=" -u demo -p demo"
#actionLoginDatenWGET=" --user=demo --password=demo"
#actionLoginDatenYoutube=" -u benutzer -p kennwort"
#actionLoginDaten="$actionLoginDatenYoutube"
#actionLoginDaten=" --netrc"
# -Login Daten einbauen:
actionDATEIoptionen="$actionDATEIoptionen""$actionLoginDaten"


# -Die Format Beschränkungen:
# --Damit das Videoformat auf normale HD Auflösung (1280x720) beschränkt wird:
#actionFORMAT="-f best[height<1080]"
#actionFORMAT="-f best"
#actionFORMAT="-f height<1080"
#actionFORMAT="-f best[height<1080]"
actionFormatNorm="best[height<=720]/best"
#actionFormatZdf="hls-2751-0+hls-aac-TV_Ton-0/"
actionFormatZdf="bestvideo+hls-aac-TV_Ton-0/"
actionFormatZdf=""
actionFORMAT="-f ""$actionFormatZdf""$actionFormatNorm"
#actionFORMAT=""


# -Die Namen der Dateien zum Zwischenspeichern und Loggen festlegen:
dateiCONF="/home/$nutzer/bin/$datei.conf"
dateiURLS="00_$datei.URLS.txt"
dateiURLSfav="00_$datei.URLS.FAV.txt"
dateiLOGS="00_$datei.LOGS.txt"
dateiLOGStmp="00_$datei.LOGS.txt.tmp"
dateiLOGStmpSTATUS="00_$datei.LOGS.STATUS.txt.tmp"
dateiLOGStmpOHNEzeilennummern="00_$datei.LOGS.txt.OHNEzeilennummern.tmp"
dateiLOGSsicherung="00_$datei.LOGS.$zeitSTARTdateiname.txt"

dateiCACHEflagCHECKurlsKOMPLETT="00_$datei.$$.CACHE.FLAG-CHECK-URLS.tmp"
dateiCACHEflagQUIT="00_$datei.$$.CACHE.FLAG-QUIT.tmp"
dateiCACHEplsINFOS="00_$datei.$$.CACHE.PLS-INFOS.tmp"
dateiCACHEplsINFOSitem="00_$datei.$$.CACHE.PLS-INFOS-ITEM.tmp"

strUVZLogs="zz.logs"


# -Standard Text Bausteine
txtStandardDownloadSingular="Video"
txtStandardDownloadPlural="Videos"


# -Wegen Kontrolle max Video Anzahl:
typeset -i intAnzahlVideosMax=100


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# ----- ENDE Standardparameter setzen -----------------------------------------------------------------------
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++















# -Nur Starten wenn NICHT:
# --Logs, Hilfe, ShortcutCD
if ( [[ "$1" != -*l* ]] && [[ "$1" != -*h* ]] && [[ "$1" != -*scl* ]] && [[ "$1" != -*sccd* ]] && [[ "$1" != -*conf* ]] )
then
    # -Wegen Unterschieden beim Auslesen der aktuellen Cursorposition, wird clear
    #  aufgerufen. Wenn die aktuelle Cursorposition in der untersten Zeile wäre, würde
    #  ansonsten die getCPos Funktion nicht korrekt arbeiten!
    #echo -e "...clear screen..."
    fncClearX
fi








function fncAUSGABEstandard {
    # -Gibt '(Standard)' aus, wenn $1 dem STANDARD $2 entspricht!
    [[ "$1" == "" ]] && echo -e "(Argumente nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$2" == "" ]] && echo -e "(Argument nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$1" == "$2" ]] && echo -e " (Standard)"
}

function fncAUSGABEstandardONOFF {
    # -Gibt 'on' aus, wenn $1 dem STANDARD $2 entspricht, ansonsten 'off'
    [[ "$1" == "" ]] && echo -e "(Argumente nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$2" == "" ]] && echo -e "(Argument nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$1" == "$2" ]] && echo -e "on" && return
    [[ "$1" != "$2" ]] && echo -e "off" && return
}





typeset -i intLayoutMaxSpalten=0
typeset -i intLayoutMaxSpaltenVorgabe=140
function fncLayoutMaxSpalten {
    # -Den Anzeigebereich des eigenen Layouts auf 80% der vorhandenen Bildschirmbreite
    #  begrenzen: ($zSPALTEN/10)*8
    
    typeset -i zZEILEN=$LINES
    typeset -i zSPALTEN=$COLUMNS
    
    intLayoutMaxSpaltenSCALE1=`echo -e "scale=1 ; ($zSPALTEN/10)*8" | bc -l`
    intLayoutMaxSpalten=${intLayoutMaxSpaltenSCALE1//\.*/}
    [ "$intLayoutMaxSpalten" -le 0 ] && intLayoutMaxSpalten=$intLayoutMaxSpaltenVorgabe
}
fncLayoutMaxSpalten


function fncAusgabeHRMaxSpalten {
    # -HRMaxSpalten erstellen und ausgeben!
    # -Argumente:
    # --$1: Die Zeichen mit denen die Linie anfangen soll.
    # --$2: Das Zeichen mit dem die Linie gefüllt wird.
    # -Werden keine Argumente übergeben, wird Standard genutzt:
    txtHRAnfang="|"
    txtHRFuellen="-"
    
    typeset -i zHRAnfang=0
    typeset -i zHRFuellen=0
    typeset -i zHRMaxSpalten=0
    
    [ $1 ] && txtHRAnfang="$1"
    zHRAnfang=${#txtHRAnfang}
    [ $2 ] && txtHRFuellen="$2"
    zHRFuellen=${#txtHRFuellen}
    
    txtHRMaxSpalten="$txtHRAnfang""$txtHRFuellen"
    zHRMaxSpalten=intLayoutMaxSpalten-zHRAnfang-zHRFuellen
    for ((zHR=0; zHR<$zHRMaxSpalten; zHR++))
    do
        #echo -en "$zzHR - "
        txtHRMaxSpalten="$txtHRMaxSpalten""$txtHRFuellen"
    done
    echo -e "\\r$txtHRMaxSpalten"
}



function fncLayoutHRFullScreen {
    # -Fullscreen HR erstellen und in $txtHRFullScreen speichern.
    # -Argumente:
    # --$1: txtHRFullScreenANFANG
    # --$2: txtHRFullScreenENDE
    
    typeset -i zZEILEN=$LINES
    typeset -i zSPALTEN=$COLUMNS
    typeset -i zHRanfang=0
    typeset -i zHRmitte=0
    typeset -i zHRende=0
    typeset -i zzHR=0
    
    txtHRFullScreenANFANG="|- $datei "
    #txtHRFullScreenANFANG="|"
    [ $1 ] && txtHRFullScreenANFANG="$1"
    zHRanfang=${#txtHRFullScreenANFANG}
    
    #txtHRFullScreenENDE=" $datei -|"
    txtHRFullScreenENDE="|"
    [ $2 ] && txtHRFullScreenENDE="$2"
    zHRende=${#txtHRFullScreenENDE}
    
    txtHRFullScreenMITTE=""
    zHRmitte=zSPALTEN-zHRanfang-zHRende
    for ((zzHR=0; zzHR<$zHRmitte; zzHR++))
    do
        #echo -en "$zzHR - "
        txtHRFullScreenMITTE="$txtHRFullScreenMITTE""-"
    done
    txtHRFullScreen="$txtHRFullScreenANFANG""$txtHRFullScreenMITTE""$txtHRFullScreenENDE"
    #echo -e "\\r$txtHRFullScreen"
}
fncLayoutHRFullScreen




#txtHR="|--------------------------------------------------------------------------------"
txtHR="`fncAusgabeHRMaxSpalten`"

#"$txtHR"\\n\
# txtKOPF=\
# "|- $dateiVersionInfoNr ($dateiVersionInfoKategorie: $dateiVersionInfoTxt)"\\n\
# "$txtHR"\\n\
# "|- $datei -| "

#txtKOPFlogs=$txtKOPF"Logdatei"\\n\
# txtKOPFlogs=$txtKOPF\\n\
# "$txtHR"\\n\
# "|- $zeitSTART"\\n\
# "|-"

# txtKOPF=$txtKOPF\\n\
# "$txtHR"\\n\
# "|- $zeitSTART"\\n\
# "|-"

txtKOPF=\
"$txtHR"\\n\
"|- $datei -| $txtTITEL"\\n\
"|- $dateiVersionInfoNr ($dateiVersionInfoKategorie: $dateiVersionInfoTxt)"\\n\
"$txtHR"\\n\
"|- $zeitSTART"\\n\
"|-"

txtKOPFlogs="$txtKOPF"



txtBENUTZUNG=\
\\n"|- Benutzung:"\\n\
"|- '$datei [OPTIONEN] [URLs]'"\\n\
"|- '$datei [OPTIONEN] [PFAD]'"\\n\
"|- '$datei [OPTIONEN] [Shortcut]'"\\n\
"|- '$datei [OPTIONEN]'"\\n\
"|- Komfortabel Videodateien herunterladen, bei Bedarf Audio extrahieren"\\n\
"|- oder komplette Webseiten lokal speichern."\\n\
"|-"

txtHILFE=$txtBENUTZUNG\\n\
"|- Hinweise zur Benutzung:"\\n\
"|- -Wenn kein Pfad angegeben wurde, wird das aktuelle Verzeichnis zum Speichern der Downloads und"\\n\
"|-  Logdateien verwendet. Bei globalen Shortcuts wird das Arbeitsverzeichnis innerhalb der Einstellungen"\\n\
"|-  festgelegt. Nähere Infos und Beispiele: '$datei -hc'"\\n\
"|-"\\n\
"|- Optionen:"\\n\
"|- -h\\t\\tDiesen Hilfetext anzeigen. Kann nur mit der More Option kombiniert werden."\\n\
"|- -hM\\t\\tDiesen Hilfetext mittels More anzeigen. Während dessen 'h' tippen, um Hinweise zur Bedienung"\\n\
"|-   \\t\\tvon More einzublenden. Andere Optionen werden ignoriert."\\n\
"|- -hc\\t\\tDie Konfigurationsdatei ($datei.conf) anzeigen. Andere Optionen werden ignoriert."\\n\
"|- -conf\\tDie Konfigurationsdatei ($datei.conf) bearbeiten. Dabei wird zuerst die aktuelle Konfiguration"\\n\
"|-      \\tgesichert ($datei.conf.bak.$zeitSTARTdateiname) und erst dann VI zum Bearbeiten gestartet."\\n\
"|-      \\tAndere Optionen werden ignoriert."\\n\
"|- -l\\t\\tDie Logdatei aus dem aktuellen Verzeichnis ausgeben. Falls keine Logdatei gefunden wurde, wird ein"\\n\
"|-   \\t\\tAuswahlfenster geöffnet."\\n\
"|- -lM\\t\\tAusgabe der Logdatei mittels More, ansonsten wie '-l'."\\n\
"|- -l?\\t\\tDirekt das Auswahlfenster für die Logdatei anzeigen und danach die Datei ausgeben."\\n\
"|- -l?M\\t\\tAusgabe der Logdatei mittels More, ansonsten wie '-l?'."\\n\
"|- -f\\t\\tDie Force Download Option nutzen. Dabei werden Datein auch dann heruntergeladen, wenn sie bereits"\\n\
"|-   \\t\\tim Archiv aufgeführt sind. Dies funktioniert nur bei Video- oder Audiodateien und es darf maximal"\\n\
"|-   \\t\\teine Quiet Option gesetzt werden. Die Force Download Frage wird automatisch übersprungen."\\n\
"|-   \\t\\t'-f -q' ist dabei das Gleiche wie '-fq' oder '-qf'."\\n\
"|- -cd\\t\\tÖffnet die Verzeichnisauswahl um das Skript in einem anderen Arbeitsverzeichnis auszuführen."\\n\
"|-   \\t\\tDie Funktion wird immer ausgeführt! Ist also mächtiger als die Quiet Optionen oder die entsprechende"\\n\
"|-   \\t\\tShortcut Einstellung. Der Aufruf kann mit anderen Optionen kombiniert werden, allerdings muss"\\n\
"|-   \\t\\t'-cd' als erste Option aufgeführt sein, oder sie muss allein stehen."\\n\
"|-   \\t\\tKorrekte Beispiele: '-cdf', '-cdqq -sc=foo', '-f -cd'"\\n\
"|-   \\t\\tFalsche Beispiele: '-qqcd', '-sccdcd'  (Diese Option hat Super-Kuh-Kräfte.)"\\n\
"|-"\\n\
"|- Quiet Optionen:"\\n\
"|- Diese Einstellungen reduzieren die erforderlichen Eingaben und die Ausgabe des Skripts."\\n\
"|- -q\\t\\tDie Sicherheitsfrage überspringen und direkt das Skript starten."\\n\
"|- -qq\\t\\tDie Sicherheitsfrage und die Force Download Frage überspringen. Standard: Force"\\n\
"|-   \\t\\tDownload ist ausgeschaltet."\\n\
"|- -qqq\\t\\tDie Sicherheitsfrage, die Force Download Frage und die Format Auswahl überspringen."\\n\
"|-   \\t\\tStandard: Force Download ist ausgeschaltet und Dateiformat ist nur Video."\\n\
"|-"\\n\
"|- Erweiterte Optionen:"\\n\
"|- -url='...'\\tWird diese Option beim Programmstart gesetzt, wird die URL syntaktisch geprüft und ggf. übernommen."\\n\
"|-   \\t\\tEs können auch URL-Shortcuts aus der $datei.conf Datei hier eingegeben werden. Das eigentliche Fenster"\\n\
"|-   \\t\\tzur URL Eingabe wird nicht mehr angezeigt."\\n\
"|-   \\t\\tNähere Infos und Beispiele: '$datei -hc'"\\n\
"|-   \\t\\tDiese Option muss einzeln und am Ende der Argumente stehen!"\\n\
"|- -sc '...'\\tEinen GLOBALEN Shortcut aus der $datei.conf auslesen und benutzen. Globale Shortcuts enthalten"\\n\
"|-   \\t\\tden Shortcut, ein Arbeitsverzeichnis als Downloadziel, eine Option zur Auswahl des Arbeitsverzeichnis,"\\n\
"|-   \\t\\teine Quietmodus Option und optional eine oder mehrere URLs."\\n\
"|-   \\t\\tNähere Infos und Beispiele: '$datei -hc'"\\n\
"|-   \\t\\tDiese Option muss einzeln stehen!"\\n\
"|- -sccd '...'\\tAnhand der Shortcut Einstellungen wird in das entsprechende Arbeitsverzeichnis gewechselt."\\n\
"|-   \\t\\tBeispiel: '$datei -sccd foo'"\\n\
"|- -scls '...'\\tAnhand der Shortcut Einstellungen wird der Inhalt des entsprechenden Arbeitsverzeichnisses angezeigt."\\n\
"|-   \\t\\tBeispiel: '$datei -scls foo'"\\n\
"|- -scl '...'\\tAnhand der Shortcut Einstellungen wird die entsprechende Logdatei angezeigt."\\n\
"|-   \\t\\tBeispiel: '$datei -scl foo'"\\n\
"|- -sclM\\tAusgabe der Logdatei mittels More, ansonsten wie '-scl'."\\n\
"|- -off\\t\\tNach erfolgreichem Beenden des Skripts das System herunterfahren. Wartezeit"\\n\
"|-   \\t\\tbis zum Shutdown: 1 min"\\n\
"|-   \\t\\tDiese Option muss einzeln stehen!"\\n\
"|- -off='N'\\tNach erfolgreichem Beenden des Skripts das System herunterfahren. Wartezeit"\\n\
"|-   \\t\\tbis zum Shutdown: 'N' min"\\n\
"|-   \\t\\tDiese Option muss einzeln stehen!"\\n\
"|-"\\n\
"|- Manche Optionen können kombiniert werden. Dabei ist '-qf' das gleiche wie '-fq'."\\n\
"|- Mehrere Quiet Optionen müssen als ein Argument zusammen gefasst werden."\\n\
"|- Beispiel: '-q -qf' ändern zu '-qq' oder mit Force Download '-qf'."\\n\
"|- Beispiel: '-q -q -q' ändern zu '-qqq' Nur zusammen hängende 'q' zählen als Quiet Optionen."\\n\
"|-"\\n\
"|- Die URLs zu den Videodateien, Playlisten oder HTML-Seiten müssen mittels Leerzeichen"\\n\
"|- getrennt werden. Zum Speichern der Videodateien stehen mehrere verschiedene"\\n\
"|- Formatoptionen zur Verfügung. (nur Video, nur Audio,...) Bei HTML-Seiten wird die"\\n\
"|- komplette Seite mit ihren lokalen Verknüpfungen heruntergeladen."\\n\
"|-"\\n\
"|- Die eingegebenen URLs werden temporär in der Datei '$dateiURLS' gespeichert."\\n\
"|- Kommt es zu einem Fehler bei der Ausführung des Skripts, können bei einem Neustart die gespeicherten"\\n\
"|- URLs ganz einfach übernommen werden. Dies funktioniert allerdings nur, wenn Sie das Skript im gleichen"\\n\
"|- Arbeitsverzeichnis starten!"\\n\
"|- Wenn das Skript ordnungsgemäß beendet wurde, wird die URLs Datei gelöscht. Eine Kopie der Logdatei"\\n\
"|- wird unter $strUVZLogs/$dateiLOGSsicherung gespeichert."\\n\
"|- "\\n\
"|- Dieses Tool benötigt folgende Pakete um zu funktionieren:"\\n\
"|- -$strBefehlName"\\n\
"|- -ffmpeg, plus die bevorzugten Codecs (zum Beispiel: lame, libmp3lame,...)"\\n\
"|- -wget, lsof, bc, cpulimit"\\n\
"|-"

txtFEHLERargument=\\n\
"|- FEHLER:\\tKein zulässiges Argument übergeben. - Es könnte Panik entstehen!"\\n\
"|-\\t\\tWeitere Hilfe erhalten Sie mit '$datei -h'!"\\n\
"|-"

txtENDEzeit=\
"|-"\\n\
"|-"\\n\
"|- Start:\\t$zeitSTART"\\n\
"|- Ende: \\t"


VORLAGEtxtFEHLER=\\n\
"|- FEHLER:\\tKeinPiePaPo..."\\n\
"|-\\t\\tNoch immer KeinPiePaPo..."\\n\
"|-\\t\\tWeitere Hilfe erhalten Sie mit '-h'!"\\n\
"|-"


# SHORTCUT
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START function $datei.conf auslesen ++++++++++++++++++++++++++++
function fncDATEIconfAUSLESEN {
    # -Wenn der richtige Schlüssel gefunden wurde, wird der entsprechende
    #  Wert ausgelesen und einer Variablen zugewiesen:
    eingabeURLkontrolle=$eingabeURL
    flagURLconf="false"
    flagSCglobalGEFUNDEN="false"
    while read txtDATEIconf
    do
        # -Kommentare und leere Zeilen ignorieren:
        if ( [[ "$txtDATEIconf" == \#* ]] || [[ "$txtDATEIconf" == "" ]] )
        then
            continue
        fi
        
        # -URL Shortcut auslesen:
        if ( [[ "$eingabeSCurl" != "" ]] && [[ "$txtDATEIconf" == url:$eingabeURL=* ]] )
        then
            #echo -e "--- Shortcut URL: $txtDATEIconf"
            eingabeURL=${txtDATEIconf//url:$eingabeURL=/}
            flagURLconf="true"
            break
        fi
        
        # -GLOBALEN Shortcut auslesen:
        if ( [[ "$eingabeSC" != "" ]] && [[ "$txtDATEIconf" == $eingabeSC* ]] )
        then
            #echo -e "--- Shortcut GLOBAL: $txtDATEIconf"
            arrSHORTCUT=($txtDATEIconf)
            arrSHORTCUTsc=${arrSHORTCUT[0]}
            arrSHORTCUTverzeichnis=${arrSHORTCUT[1]}
            arrSHORTCUTverzeichnisAUSWAHL=${arrSHORTCUT[2]}
            arrSHORTCUTquiet=${arrSHORTCUT[3]}
            if ( [[ "$arrSHORTCUTquiet" != "quietNEIN" ]] )
            then
                if ( [[ "$arrSHORTCUTquiet" == "quietQ" ]] )
                then
                    strg1=$strg1"q"
                fi
                if ( [[ "$arrSHORTCUTquiet" == "quietQQ" ]] )
                then
                    strg1=$strg1"qq"
                fi
                if ( [[ "$arrSHORTCUTquiet" == "quietQQQ" ]] )
                then
                    strg1=$strg1"qqq"
                fi
            fi
            if ( [[ "$arrSHORTCUTsc" != "$eingabeSC" ]] )
            then
                flagSCglobalGEFUNDEN="false"
                continue
            else
                flagSCglobalGEFUNDEN="true"
                if ( [[ "${#arrSHORTCUT[*]}" -gt 4 ]] )
                then
                    # -URLs einlesen:
                    for i in "${arrSHORTCUT[@]}"
                    do
                        if ( [[ "$i" == http*:\/\/* ]] )
                        then
                            if ( [[ "$arrSHORTCUTurl" == "" ]] )
                            then
                                arrSHORTCUTurl="$i"
                                continue
                            fi
                            arrSHORTCUTurl="$arrSHORTCUTurl $i"
                        fi
                    done
                    #eingabeURL=$arrSHORTCUTurl
                fi
                #echo -e "--- $arrSHORTCUTsc - $arrSHORTCUTverzeichnis - $arrSHORTCUTverzeichnisAUSWAHL - $arrSHORTCUTurl"
                break
            fi
            #echo -e "--- $arrSHORTCUTsc - $arrSHORTCUTverzeichnis - $arrSHORTCUTverzeichnisAUSWAHL - $arrSHORTCUTurl"
            #exit 0;
        fi
    done < $dateiCONF
    
    # -Shortcut konnte nicht gefunden werden:
    if ( [[ "$eingabeSC" != "" ]] && [[ "$flagSCglobalGEFUNDEN" == "false" ]] )
    then
        echo -e $txtKOPF
        echo -e "|- Der von Ihnen angegebene Shortcut '$eingabeSC' konnte in der Konfigurationsdatei"
        echo -e "|- nicht gefunden werden. Bitte kontrollieren Sie Ihre Eingabe!"
        echo -e "|- Weitere Hilfe erhalten Sie mit '-h'!"
        echo -e "|- "
        exit 2;
    fi
}
# +++++ ENDE function $datei.conf auslesen ++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------
function fncAUSGABEstdoutUNDlogdatei () {
    # -Erwartet einen String zum Ausgeben: $1
    # --Ausgabe am Bildschirm
    # --Ausgabe in die Logdatei
    if ( [[ "$1" != "" ]] )
    then
        echo -e "$1"
        echo -e "$1" >> $dateiLOGS
    fi
}

function fncECHOlx () {
    # -Erwartet einen String zum Ausgeben: $1
    # --Ausgabe am Bildschirm
    # --Ausgabe in die Logdatei
    if ( [[ "$1" != "" ]] )
    then
        echo -e "$1"
        echo -e "$1" >> $dateiLOGS
    fi
}
# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------






# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Config auslesen +++++++++++++++++++++++++++++
# -Zuerst die Konfigurationsdatei im Homeverzeichnis suchen und
#  auslesen: ~/.config/$strBefehlName/config
# -Nur wenn im Homeverzeichnis keine Konfigurationsdatei ist, wird
#  die globale Datei ausgelesen: /etc/$strBefehlName.conf
archivORIGINAL=""
function fncAUSLESENconfigARCHIV {
    while read txtCONFIG
    do
        #nix=1
        if ( [[ "$txtCONFIG" == --download-archiv* ]] )
        then
            archivORIGINAL=${txtCONFIG//\-\-download\-archiv /}
            #echo $archivORIGINAL
            break
        fi
    done < $pfadYOUTUBEDLconfig
}

if ( [[ -f "$strBefehlKonfigDatei" ]] )
then
    pfadYOUTUBEDLconfig="$strBefehlKonfigDatei"
    fncAUSLESENconfigARCHIV
elif ( [[ -f "/etc/$strBefehlName.conf" ]] )
then
    pfadYOUTUBEDLconfig="/etc/$strBefehlName.conf"
    fncAUSLESENconfigARCHIV
else
    # -Keine Konfigurationsdatei vorhanden! Deshalb wird hier eine
    #  Archivdatei definiert. Ansonsten kann die Force Option nicht
    #  funktionieren!
    #echo -e "DEBUG - Konfigurationsdatei: $pfadYOUTUBEDLconfig"
    archivORIGINAL=~/$strBefehlName.download.archiv
fi
# +++++ ENDE Config auslesen ++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++





strg1="-"
strg2="-"
strg3="-"
flagSCglobal="false"
flagMORE="false"
flagVERZEICHNISauswahl="false"
flagForceArgument="false"
flagForceGlobal="false"
flagFEHLERlogs="false"
flagFEHLERlogs2="false"

befehlAUSGABEmore=""
# -Die Argumente kontrollieren und neu aufteilen:
# --ALLE normalen Optionen (-q,-h,...) werden im $strg1 gespeichert
# --die Shutdown Optionen (-off...) werden im $strg2 gespeichert
#for i in $*
for i in "$@"
do
    eingabeSC=""
    eingabeSCurl=""
    if ( [[ "$flagSCglobal" == "true" ]] )
    then
        # -Prüfen ob globaler Shortcut in der $datei.conf steht:
        #eingabeURL=${i//\-/}
        #eingabeURL=${i//\-url=/}
        #echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL"
        eingabeSC=$i
        if ( [[ "$eingabeSC" != "" ]] )
        then
            fncDATEIconfAUSLESEN
        fi
        #continue
    fi
    if ( [[ "$i" == -sc ]] || [[ "$i" == -sccd ]] || [[ "$i" == -scl* ]] || [[ "$i" == -scq* ]] )
    then
        flagSCglobal="true"
        strg1=$strg1${i//\-/}
        #continue
    fi
    if ( [[ "$i" == -*M ]] )
    then
        flagMORE="true"
        #befehlAUSGABEmore="| more"
        #befehlAUSGABEmore="echo -e $befehlAUSGABEmore"
        #befehlAUSGABEmore="echo -e more"
        #befehlAUSGABEmore="| $befehlAUSGABEmore"
    fi
    if ( [[ "$i" == -cd* ]] )
    then
        flagVERZEICHNISauswahl="true"
    fi
done
for i in "$@"
do
    if ( [[ "$i" == -*conf* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"conf"
        break
    fi
    
    if ( [[ "$i" == -*f* ]] && [[ "$i" != -off* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"f"
        flagForceArgument="true"
        flagForceGlobal="true"
        #echo -e "|- \"$i\" * einzel Vergleich: -f gesetzt"
    fi
    if ( [[ "$i" == -*h* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"h"
    fi
    if ( [[ "$i" == -*hc* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"c"
    fi
    if ( [[ "$i" == -*l* ]] && [[ "$i" != -url* ]] )
    then
        if ( [[ "$i" == -*l\?* ]] )
        then
            strg1=$strg1"l?"
        elif ( [[ "$i" == -*scl* ]] )
        then
            strg1=$strg1"scl"
        else
            strg1=$strg1"l"
        fi
    fi
    if ( [[ "$i" == -*q* ]] )
    then
        # -Die Quietoptionen aus dem Befehlsaufruf sind mächtiiger als die Quietoptionen
        #  aus den Shortcuts in der Konfigurationsdatei!        
        # --Da die Shortcut Optionen bereits gesetzt sind, werden Sie komplett entfernt.
        # --Auslesen der aktuellen Quietoptionen aus dem Befehlsaufruf.
        strg1=${strg1//q/}
        strg1TMP=$strg1
        strg1=$strg1"q"
    fi
    if ( [[ "$i" == -*qq* ]] )
    then
        strg1=$strg1"q"
    fi
    if ( [[ "$i" == -*qqq* ]] )
    then
        strg1=$strg1"q"
    fi
    if ( [[ "$i" == "-off" ]] )
    then
        strg2=$strg2"off"
        #echo -e "|- \"$i\" * einzel Vergleich: -off gesetzt"
    elif ( [[ "$i" == -off=* ]] )
    then
        #echo -e "|- \"$i\" * einzel Vergleich: -off=* gesetzt"
        intOFFminuten=${i//*=/}
        #echo -e "|- \"$intOFFminuten\" * einzel Vergleich: intOFFminuten"
        strg2=$strg2"off="$intOFFminuten
    elif ( [[ "$i" == -off* ]] )
    then
        #echo -e "|- \"$i\" * einzel Vergleich: FEHLER -off* gesetzt"
        strg2=""
    elif ( [[ "$i" != -* ]] )
    then
        #echo -e "|- \"$i\" * einzel Vergleich: FEHLER kein gültiges Argument"
        flagFEHLERargument="true"
    fi
    if ( [[ "$i" == -url=* ]] )
    then        
        # -Prüfen ob Shortcut in der $datei.conf steht, falls nicht wird die Eingabe einfach
        #  als URL übernommen!
        #eingabeURL=${i//\-/}
        eingabeURL=${i//\-url=/}
        #echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL"
        eingabeSCurl=$i
        if ( [[ "$eingabeURL" != *.* ]] )
        then
            fncDATEIconfAUSLESEN
        fi
        if ( [[ "$flagURLconf" != "true" ]] )
        then
            # -Eingabe ist normale URL:
            eingabeURL=${i//\-url=/}
            eingabeURL=${eingabeURL//\&/aaaUNDaaa}
            if ( [[ "$eingabeURL" != http*:\/\/* ]] )
            then
                eingabeURL="http://"$eingabeURL
                #echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL"
            fi
            #eingabeURL=${eingabeURL//aaaUNDaaa/\&}
        fi
    fi
    if ( [[ "$i" == http*:\/\/* ]] )
    then
        eingabeURL="$eingabeURL $i"
        #echo -e "|- DEBUG-INFO:\\n|- eingabeURL mit i: $eingabeURL"
    fi
    
    # -Pfad aus Kommandozeile übernehmen:
    [[ -d "$i" ]] && pfad="$i"
done



# -Den Inhalt des im Shortcut gespeicherten Verzeichnisses $arrSHORTCUTverzeichnis anzeigen!
# -Wenn Verzeichnisauswahl gewünscht, wird mittels fncVERZEICHNISauswahl die Variable
#  $arbeitsVERZEICHNIS definiert.
if ( [[ "$strg1" == -*scls* ]] )
then
    if ( [[ "$arrSHORTCUTverzeichnis" != "" ]] )
    then
        # -In das Verzeichnis wechseln, den Inhalt auflisten, zurück in das ursprüngliche Verzeichnis wechseln
        #  und beenden.
        strVERZEICHNISaktuell=`pwd`
        cd $arrSHORTCUTverzeichnis
        xls
        cd $strVERZEICHNISaktuell
        exit 0;

    else
        echo -e $txtKOPF
        echo -e "|- Der Shortcut '$eingabeSC' wurde in der Konfigurationsdatei gefunden, aber der"
        echo -e "|- Eintrag enthält kein Arbeitsverzeichnis. Bitte kontrollieren Sie Ihre Eingabe"
        echo -e "|- und die Daten in der Konfigurationsdatei!"
        echo -e "|- Weitere Hilfe erhalten Sie mit '-h'!"
        echo -e "|- "
        exit 2;
    fi
fi




# -Das aktuelle Arbeitsverzeichnis in der Konsole abändern zu dem Verzeichnis
#  das im Shortcut gespeichert ist: $arrSHORTCUTverzeichnis
if ( [[ "$strg1" == -*sccd* ]] )
then
    if ( [[ "$arrSHORTCUTverzeichnis" != "" ]] )
    then
        # -Ein cd innerhalb eines Skripts wirkt sich nicht auf die Umgebung des Skripts aus!!!
        # --xcd funktioniert!
        # --Allerdings fehlt der Befehlsverlauf, da eine neue Shell gestartet wird.
        xcd $arrSHORTCUTverzeichnis
        exit 0;

        # --"cd WunschVerzeichnis..." wird in lxcd Skript geschrieben, lxcd muss ausführbar sein,
        #   das Hauptskript wird geschlossen mit dem Hinweis, dass lxcd der richtige Befehl ist!
        #echo -e "xcd $arrSHORTCUTverzeichnis" > /home/lx21/bin/lxcd
        #chmod a+x /home/lx21/bin/lxcd
        #echo -e "--- Bitte starten sie 'lxcd'!"        
        #exit 0;
    else
        echo -e $txtKOPF
        echo -e "|- Der Shortcut '$eingabeSC' wurde in der Konfigurationsdatei gefunden, aber der"
        echo -e "|- Eintrag enthält kein Arbeitsverzeichnis. Bitte kontrollieren Sie Ihre Eingabe"
        echo -e "|- und die Daten in der Konfigurationsdatei!"
        echo -e "|- Weitere Hilfe erhalten Sie mit '-h'!"
        echo -e "|- "
        exit 2;
    fi
fi





# echo -e "|- DEBUG-INFO: Ausgabe der String Variablen:"
# echo -e "|- DEBUG-INFO: *: $*"
# echo -e "|- DEBUG-INFO: strg1: $strg1 - strg1TMP: $strg1TMP --- strg2: $strg2 --- arrSHORTCUTsc: $arrSHORTCUTsc"
# echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL\\n|- eingabeURLneu: ${eingabeURL//aaaUNDaaa/\&}"
# exit 0;




# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# -Sonderfälle UPDATE, AUFRUF_INTERN, -q, -h, -l
if ( [[ "$flag_update" != "true" ]] && [[ "$flag_aufruf_intern" != "true" ]] && [[ "$strg1" != -*q* ]] && [[ "$strg1" != -*h* ]] && [[ "$strg1" != -*l* ]] && [[ "$strg1" != -*sccd* ]] && [[ "$strg1" != -*conf* ]] )
then
    # -Die Sicherheitsfrage:
    # --1. Argument: die Vorbelegung: WEITER oder ABBRECHEN
    # --2. Argument: die Datei die gestartet werden soll
    # --3. Argument: der Titel der Datei die gestartet werden soll
    flagSICHERHEITSFRAGE=`/home/lx21/bin/zz_inc_sicherheitsfrage.sh "WEITER" "$datei" "$txtTITEL"`
    flagSICHERHEITSFRAGE=$?
    # -Wenn der Rückgabewert nicht 0 ist, wurde entweder abgebrochen oder es gab einen Fehler!
    if ( [[ "$flagSICHERHEITSFRAGE" != "0" ]] )
    then
        # -Die Sicherheitsfrage beendet das Skript!
        #echo -e "--- Sicherheitsfrage: $flagSICHERHEITSFRAGE"
        exit 1;
    fi
fi
# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------





# -Einbindung einer Verlauf Datei:
# --im übergeordneten Ordner nach Verlauf suchen und wenn vorhanden einlesen
# --Verlauf als Liste (radio oder check) zur URL Auswahl anbieten, wenn keine Auswahl
#   erfolgt wird inputbox geöffnet, ansonsten geht es direkt zur Formatauswahl
# --nach der URL Eingabe diese im Verlauf speichern
# # +++++ START Config auslesen
# while read txtCONFIG
# do
#     #nix=1
#     if ( [[ "$txtCONFIG" == --download-archiv* ]] )
#     then
#         archivORIGINAL=${txtCONFIG//\-\-download\-archiv /}
#         #echo $archivORIGINAL
#         break
#     fi
# done < ~/.config/$strBefehlName/config
# # +++++ ENDE Config auslesen
# 
# # +++++ START archivTMP anhängen an archivORIGINAL
# while read txtTMP
# do
#     echo $txtTMP >> $archivORIGINAL
# done < $archivTMP
# # +++++ ENDE archivTMP anhängen an archivORIGINAL













# -Die Konfigurationsdatei anzeigen:
# --$dateiCONF
if ( [[ "$strg1" == -*hc* ]] )
then
    echo -e $txtHR\\n"|- Ausgabe $dateiCONF"\\t"-START-"\\n$txtHR
    cat $dateiCONF
    echo -e $txtHR\\n"|- Ausgabe $dateiCONF"\\t"-ENDE-"\\n$txtHR
    exit 0;
fi


# -Die Konfigurationsdatei bearbeiten:
# --$dateiCONF
if ( [[ "$strg1" == -*conf* ]] )
then
    echo -e $txtHR\\n"|- Bearbeiten $dateiCONF"\\t"-START-"\\n$txtHR
    #cat $dateiCONF
    echo -e "|- Sicherung der Konfigurationsdatei erstellen..."\\n"|-"
    #stsCONFcp=`cp $dateiCONF /home/$nutzer/bin/testCP/$datei.conf.bak.$zeitSTARTdateiname`
    cp $dateiCONF $dateiCONF.bak.$zeitSTARTdateiname 1>/dev/null 2>&1
    stsCONFcp=$?
    sleep 0.5
    if ( [[ "$stsCONFcp" -gt "0" ]] )
    then
        echo -e "|- Sicherung konnte nicht erstellt werden! Bitte prüfen Sie die Zugriffsrechte innerhalb"
        echo -e "|- des Zielordners und Ihre eigenen Benutzerrechte. Das Skript wird jetzt beendet."\\n"|-"
        exit 1;
    else
        echo -e "|- Sicherung erfolgreich erstellt!"
        echo -e "|- Dateiname: $datei.conf.bak.$zeitSTARTdateiname"\\n"|-"
    fi
    
    echo -e "|- Konfigurationsdatei bearbeiten:"
    echo -e "|- Befehl: 'vi $dateiCONF'"
    vi $dateiCONF
    stsCONFvi=$?
    
#     echo -e "|- Status: $stsCONFvi\\t0=Keine Fehler! Bearbeitung erfolgreich abgeschlossen."
#     echo -e "|-\\t\\t1=Fehler! Keine Rückmeldung über die Speichervorgänge. Bitte die Änderungen überprüfen!"
#     echo -e "|-\\t\\t2=Fehler! Bearbeitung wurde entweder durch Benutzer oder anderen Prozess abgebrochen."
    
    case "$stsCONFvi" in
        (0)
            txtCONFvi="Keine Fehler! Bearbeitung erfolgreich abgeschlossen."
            ;;
        (*)
            txtCONFvi="Fehlerhafter oder unklarer Status! Bitte die Änderungen überprüfen!"
            ;;
    esac
    
#    echo -e "|- Status: $stsCONFvi\\t$txtCONFvi"
    
    echo -e "|- Bearbeitung der Datei erfolgreich abgeschlossen!"\\n"|-"
    echo -e $txtHR\\n"|- Bearbeiten $dateiCONF"\\t"-ENDE-"\\n$txtHR
    exit 0;
fi






# -Die Hilfe anzeigen:
if ( [[ "$strg1" == -*h* ]] )
then
    #echo -e $txtKOPF
    #echo -e $txtKOPF $txtHILFE | more
    #echo -e $txtKOPF $txtHILFE $befehlAUSGABEmore
    
    if ( [[ "$flagMORE" == "false" ]] )
    then
        # -Normaler Aufruf ohne More-Option
        echo -e "$txtKOPF $txtHILFE"
    else
        echo -e "$txtKOPF $txtHILFE" | more
    fi
    exit 0;
fi


# -Die Logdatei anzeigen:
# --verschiedene Optionen: l?, scl ... oder nur l
# --l? startet Auswahlfenster für Logdatei im aktuellen Verzeichnis
# --scl ... Logdatei wird anhand der entsprechenden Shortcut Vorgaben angezeigt
# --l Falls vorhanden wird Logdatei im aktuellen Verzeichnis angezeigt, ansonsten startet Auswahlfenster

function fncEINGABElogdatei {
    #vorgabePFAD=`pwd`
    #vorgabeFILTER="Textdatei (*.txt)"
    eingabeDATEI=$(kdialog --title="Logdatei wählen:" --getopenfilename "$vorgabePFAD" "$vorgabeFILTER" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            checkDIALOGfehler="" ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Auswahl der Logdatei abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    fi
}

function fncAUSGABElogdatei {
    txtfncAUSGABE=$1
    #echo -e "$txtHRFullScreen"\\n"|- START Ausgabe: $txtfncAUSGABE"
    echo -e "$txtHRFullScreen"\\n"|- START Ausgabe: $txtfncAUSGABE"\\n"$txtHRFullScreen"
    # -Bei einem internen Aufruf (z.Bsp. strBEFEHLnachQUIT) darf more nicht
    #  verwendet werden, denn more erwartet eine Eingabe des Benutzers. More wurde allerdings
    #  in einer Subshell gestartet, deshalb ist keine Interaktion vom Benutzer möglich!
    # -???Terminaltest mittels tty: mit *dev* = Ausgabe über Display! = mit Benutzer!???
    # -Bei einem internen Aufruf wird ein entsprechendes Flag übertragen, damit more möglichst verhindert wird...
    #if ( [[ `tty` == *dev* ]] )
    if ( [[ "$flagMORE" == "false" ]] )
    then
        # -Interner Aufruf
        # --oder
        # -Normaler Aufruf ohne More-Option
        cat $txtfncAUSGABE
    else
        #echo -e "DEBUG: txtfncAUSGABE:\\t\\t$txtfncAUSGABE"
        #echo -e "DEBUG: befehlAUSGABEmore:\\t"`$befehlAUSGABEmore`
        #cat $txtfncAUSGABE `$befehlAUSGABEmore`
        #(cat $txtfncAUSGABE) `$befehlAUSGABEmore`
        #--- cat $txtfncAUSGABE | `$befehlAUSGABEmore` ---
        more $txtfncAUSGABE
    fi
    
    
    # -SONDERFALL: Ausgabe Logdatei in Bearbeitung UND laufender Download
    # -SONDERFALL: Zeile davor enthält kein Newline Zeichen (wegen 'echo -en')
    getCPos
    [ "$CPosSPALTE" -gt 1 ] && echo -e ""
    
    #echo -e "|- ENDE Ausgabe: $txtfncAUSGABE"\\n"$txtHRFullScreen"
    echo -e "$txtHRFullScreen"\\n"|- ENDE Ausgabe: $txtfncAUSGABE"\\n"$txtHRFullScreen"
    exit 0;
}

vorgabePFAD=`pwd`
vorgabeFILTER="Textdatei (*.txt)"


if ( [[ "$strg1" == -*l\?* ]] )
then
    [[ "$flagSCglobal" == "true" ]] && vorgabePFAD=$arrSHORTCUTverzeichnis
    fncEINGABElogdatei
    # -Pfad zur Logdatei übergeben, Daten ausgeben und Skript beenden:
    fncAUSGABElogdatei "$eingabeDATEI"
fi


if ( [[ "$strg1" == -*l* ]] )
then    
    if ( [[ "$strg1" != -*scl* ]] && [[ -f "$dateiLOGS" ]] )
    then
        # -Pfad zur Logdatei übergeben, Daten ausgeben und Skript beenden:
        fncAUSGABElogdatei "$dateiLOGS"
    else
        # -Keine Logdatei gefunden, deshalb Auswahlfenster aufrufen:
        # --Falls Shortcut gesetzt wurde, werden die Verzeichniseinstellungen
        #   übernommen.
        # --Ohne Shortcut wird das aktuelle Verzeichnis als Vorgabe gesetzt.
        vorgabePFAD=`pwd`
        vorgabeFILTER="Textdatei (*.txt)"
        
        if ( [[ "$flagSCglobal" == "true" ]] )
        then
            vorgabePFAD=$arrSHORTCUTverzeichnis
            # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
            if ( [[ "$arrSHORTCUTverzeichnisAUSWAHL" == "verzeichnisJA" ]] )
            then
                fncEINGABElogdatei
            else
                eingabeDATEI=$arrSHORTCUTverzeichnis"/"$dateiLOGS
            fi
        else
            fncEINGABElogdatei
        fi
        
        # -Pfad zur Logdatei übergeben, Daten ausgeben und Skript beenden:
        fncAUSGABElogdatei "$eingabeDATEI"
    fi
fi


echo -e $txtKOPF


txtINFOeingabeAUFRUF="|- -Aufruf mittels:\\t\\t$datei $*"
# -Wird nur noch in die Logdatei geschrieben und nicht noch zusätzlich am Bildschirm angezeigt:
#echo -e $txtINFOeingabeAUFRUF






















#if ( [[ "$strg1" != -*qq* ]] )
# ----- DEAKTIVIERT: -----
if ( [[ "$strg1" == -*ZEIT* ]] )
then
    # -----------------------------------------------------------------------------
    # ----- START Eingabe zeitversetztes Starten ----------------------------------
    eingabeZEITVERSETZT=$(kdialog --title="Zeitversetzt starten?" --warningcontinuecancel "<h3><center>|--- $datei ---|</center></h3><br>\
    Soll der Download zeitversetzt um 02:00 Uhr gestartet werden?" --continue-label="Nein!" --cancel-label="Ja, zeitversetzt starten." --geometry=600x500)

    flagFRAGE=$(echo -e "$?")
    if [[ "$flagFRAGE" == "1" ]]
    then
        # -Abbrechen/Zeitversetzt wurde gewählt:
        flagZEITVERSETZT="true"
        eingabeZEITVERSETZT="JA"
    else
        # -Weiter/Nicht-Zeitversetzt wurde gewählt:
        flagZEITVERSETZT="false"
        eingabeZEITVERSETZT="NEIN"
    fi
    # ----- ENDE Eingabe zeitversetztes Starten -----------------------------------
    # -----------------------------------------------------------------------------
else
    flagZEITVERSETZT="false"
    eingabeZEITVERSETZT="NEIN"
fi

#txtINFOeingabeZEITVERSETZT="|- -Zeitversetzt starten:\\t$eingabeZEITVERSETZT"
#echo -e $txtINFOeingabeZEITVERSETZT





#fncDEBUGstart "Bandbreite"

if ( [[ "$strg1" != -*qq* ]] )
then
    # -----------------------------------------------------------------------------
    # ----- START Begrenzung Bandbreite einstellen --------------------------------
    # -Standard ist keine maximale Bandbreite, aber der Nutzer kann den Wert auch
    #  selbst einstellen bzw in der Liste auswählen.

    txtUEBERSCHRIFT="<h3><center>|--- $datei ---|</center></h3><br>\
    Hier haben Sie die Möglichkeit, die Downloadrate des Skripts zu begrenzen. Diese<br>\
    Einstellung gilt nur für den aktuellen Aufruf, d.h. beim nächsten Skriptstart wird<br>\
    wieder standardmäßig 'keine Begrenzung' eingestellt.<br><br>\
    Bei dieser Liste können übrigens mehrere Einträge ausgewählt werden. Dabei werden die<br>\
    kB/s Werte einfach miteinander addiert.<br>\
    Beispiel:<br>\
    Auswahl: 100kB/s + 300kB/s = 400kB/s maximale Downloadrate<br>"
    strAUSWAHL="NEIN Keine Begrenzung on 1000 1000kB/s off 800 800kB/s off 500 500kB/s off 300 300kB/s off 200 200kB/s off 100 100kB/s off"
    #eingabeBANDBREITE=$(kdialog --title "Maximale Bandbreite?" --checklist "$txtUEBERSCHRIFT" $strAUSWAHL)
    eingabeBANDBREITE=$(kdialog --title "Maximale Bandbreite?" --checklist "$txtUEBERSCHRIFT" NEIN "Keine Begrenzung" on 1000 1000kB/s off 800 800kB/s off 500 500kB/s off 300 300kB/s off 200 200kB/s off 100 100kB/s off)
    eingabeBANDBREITE=${eingabeBANDBREITE//\"/}
    #eingabeBANDBREITE=${eingabeBANDBREITE// /}
    # DEBUG:
    #echo -e "--- eingabeBANDBREITE $eingabeBANDBREITE"
    
    if ( [[ "$eingabeBANDBREITE" == NEIN* ]] )
    then
        nix=0
        # DEBUG:
        #echo -e "--- if-then eingabeBANDBREITE $eingabeBANDBREITE"
        eingabeBANDBREITE="NEIN"
    elif ( [[ "$eingabeBANDBREITE" == "" ]] )
    then
        eingabeBANDBREITE="NEIN"
        # DEBUG:
        #echo -e "--- elif-then eingabeBANDBREITE $eingabeBANDBREITE"
    else
        # DEBUG:
        #echo -e "--- else eingabeBANDBREITE $eingabeBANDBREITE"
        eingabeBANDBREITEarr=($eingabeBANDBREITE)
        typeset -i eingabeBANDBREITEfertig=0
        typeset -i eingabeBANDBREITEarrWERT=0
        typeset -i zz=0
        for i in ${eingabeBANDBREITEarr[@]}
        do
            eingabeBANDBREITEarrWERT=${eingabeBANDBREITEarr[$zz]//\"/}
            eingabeBANDBREITEfertig=eingabeBANDBREITEfertig+eingabeBANDBREITEarrWERT
            zz=zz+1
        done
        eingabeBANDBREITE=$eingabeBANDBREITEfertig"kB/s"
        eingabeBANDBREITEfertigBEFEHL=$eingabeBANDBREITEfertig"k"
    fi
    # ----- ENDE Begrenzung Bandbreite einstellen ---------------------------------
    # -----------------------------------------------------------------------------
else
    eingabeBANDBREITE="NEIN"
fi

#txtINFOeingabeBANDBREITE="|- -Maximale Bandbreite:\\t"$eingabeBANDBREITE
#echo -e $txtINFOeingabeBANDBREITE

#fncDEBUGstop "Bandbreite"

txtINFOeingabeOPTIONEN="|- -Optionen:\\t\\t\\tZeitversetzt: $eingabeZEITVERSETZT - Bandbreite (max): $eingabeBANDBREITE"
echo -e "$txtINFOeingabeOPTIONEN"





arbeitsVERZEICHNIS=""
typeset -i intDONEfncVERZEICHNISauswahl=0
function fncVERZEICHNISauswahl {
    # -$arbeitsVERZEICHNIS muss von dieser Funktion gesetzt werden!
    # -$1: Verzeichnis in dem die Auswahl startet!
    #
    # -Wenn $1 NICHT gesetzt ist: Verzeichnisauswahl startet im aktuellen Verzeichnis (pwd)
    # -Wenn $1 gesetzt ist: Verzeichnisauswahl startet im Verzeichnis $1
    
    [ $1 ] || verzeichnisAUSWAHLstart="`pwd`"
    [ $1 ] && verzeichnisAUSWAHLstart="$1"
    [ ! -d "$verzeichnisAUSWAHLstart" ] && verzeichnisAUSWAHLstart="`pwd`"
    
    eingabeVERZEICHNIS=$(kdialog --title="Arbeitsverzeichnis wählen:" --getexistingdirectory "$verzeichnisAUSWAHLstart" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            #arrSHORTCUTverzeichnis=$eingabeVERZEICHNIS
            checkDIALOGfehler="" ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Verzeichnisauswahl abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    fi
    intDONEfncVERZEICHNISauswahl=intDONEfncVERZEICHNISauswahl+1
    #echo -e "$eingabeVERZEICHNIS"
    arbeitsVERZEICHNIS="$eingabeVERZEICHNIS"
}



if ( [[ "$flagSCglobal" == "true" ]] )
then
    arbeitsVERZEICHNIS="$arrSHORTCUTverzeichnis"
    # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
    if ( [[ "$arrSHORTCUTverzeichnisAUSWAHL" == "verzeichnisJA" ]] || [[ "$flagVERZEICHNISauswahl" == "true" ]] )
    then
        #arrSHORTCUTverzeichnis="`fncVERZEICHNISauswahl \"$arrSHORTCUTverzeichnis\"`"
        fncVERZEICHNISauswahl "$arrSHORTCUTverzeichnis"
    fi
    
    # -Flag anpassen: flagVERZEICHNISauswahl
    flagVERZEICHNISauswahl="false"
    # -Pfad Variable setzen:
    pfad="$arbeitsVERZEICHNIS"
    
    # -Arbeitsverzeichnis wechseln:
    cd $arbeitsVERZEICHNIS
fi




#if ( [[ "$flagVERZEICHNISauswahl" == "true" ]] && [[ "$intDONEfncVERZEICHNISauswahl" -lt 1 ]] )
if ( ([[ "$flagVERZEICHNISauswahl" == "true" ]] && [[ "$intDONEfncVERZEICHNISauswahl" -lt 1 ]] && [[ ! -d "$pfad" ]]) || [[ ! -d "$pfad" ]] )
then
    # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
    #arbeitsVERZEICHNIS="`fncVERZEICHNISauswahl`"
    fncVERZEICHNISauswahl
    
    # -Arbeitsverzeichnis wechseln:
    cd $arbeitsVERZEICHNIS
else
    # -Arbeitsverzeichnis wechseln:
    arbeitsVERZEICHNIS="$pfad"
    cd $arbeitsVERZEICHNIS
fi






# if ( [[ "$flagSCglobal" == "true" ]] )
# then
#     # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
#     if ( [[ "$arrSHORTCUTverzeichnisAUSWAHL" == "verzeichnisJA" ]] )
#     then
#         eingabeVERZEICHNIS=$(kdialog --title="Arbeitsverzeichnis wählen:" --getexistingdirectory $arrSHORTCUTverzeichnis 2>/dev/null)
#         checkDIALOG=$(echo -e "$?")
#         checkDIALOGfehler=""
#         # -Case für Fensterüberwachung:
#         case "$checkDIALOG" in
#             (0)
#                 # -Case für Eingabeüberwachung:
#                 arrSHORTCUTverzeichnis=$eingabeVERZEICHNIS
#                 checkDIALOGfehler="" ;;
#             (1)
#                 # -abbruchBENUTZER
#                 checkDIALOGfehler="|- Sie haben die Auswahl des Arbeitsverzeichnis abgebrochen. Das Skript wird daher beendet." ;;
#             (*)
#                 # -abbruchFEHLER
#                 checkDIALOGfehler="|- FEHLER:"\\n\
#     "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
#     "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
#     "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
#     "|-"\\n\
#     "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
#     "|- und die Ausgabe in der Konsole beachten." ;;
#         esac
#         # -Fehlerausgabe und Skript beenden:
#         if ( [[ "$checkDIALOGfehler" != "" ]] )
#         then
#             # -Fehlermeldung ausgeben und Skript beenden:
#             echo -e $checkDIALOGfehler
#             echo -e "|-"
#             exit $checkDIALOG;
#         fi
#     fi
#     
#     # -Arbeitsverzeichnis wechseln:
#     cd $arrSHORTCUTverzeichnis
# fi

txtINFOeingabeARBEITSVERZEICHNISpwd=`pwd`
txtINFOeingabeARBEITSVERZEICHNIS="|- -Arbeitsverzeichnis:\\t\\t$txtINFOeingabeARBEITSVERZEICHNISpwd"
echo -e $txtINFOeingabeARBEITSVERZEICHNIS















function fncDateienAuslesenAusgabe {
    # -Erwartet eine oder mehrere Dateien mittels $1, diese werden nacheinander
    #  ausgelesen, am Ende wird der Inhalt aller Dateien komplett ausgegeben!
    [[ -z "$1" ]] && echo -e "|- FEHLER:"\\t"1. Argument nicht angegeben!" && return 11
    #[[ -z "$2" ]] && echo -e "|- FEHLER:"\\t"2. Argument nicht angegeben!" && return 12
    
    arrDateien=($1)
    strFavoritenDateienAusgabe=""
    
    for i in "${arrDateien[@]}"
    do
        strFavoritenDateienInhaltTmp=""
        # -Inhalt auslesen und temporär speichern:
        [[ -n `cat $i` ]] && strFavoritenDateienInhaltTmp=`cat $i`
        [[ -z `cat $i` ]] && continue
        # -Da bei manchen Favoritendateien am Ende noch ein Leerzeichen steht, wird
        #  dieses hier entfernt:
        [[ "${strFavoritenDateienInhaltTmp: -1}" == " " ]] && strFavoritenDateienInhaltTmp="${strFavoritenDateienInhaltTmp:0: -1}"
        
        [[ -z $strFavoritenDateienAusgabe ]] && strFavoritenDateienAusgabe="$strFavoritenDateienInhaltTmp" && continue
        [[ -n $strFavoritenDateienAusgabe ]] && strFavoritenDateienAusgabe="$strFavoritenDateienAusgabe $strFavoritenDateienInhaltTmp"
    done
    
    [[ -z $strFavoritenDateienAusgabe ]] && echo -e "Die gewählten Dateien haben keinen Inhalt!" && return
    
    # -Doppelte URLs vermeiden:
    # --Da manche URLs in mehreren Favoritendateien aufgeführt sind und vielleicht auch die alte
    #   $dateiURLSfav als aktuelle Vorlage gewählt wurde, könnten URLs hier doppelt vorkommen.
    # --Alle URLs werden deshalb EINZELN mittels des arrFavoritenURLs miteinander verglichen!
    arrFavoritenURLs=($strFavoritenDateienAusgabe)
    strFavoritenURLs=""
    for i in "${arrFavoritenURLs[@]}"
    do
        [[ -z "$strFavoritenURLs" ]] && strFavoritenURLs="$i" && continue
        [[ "$strFavoritenURLs" != *$i* ]] && strFavoritenURLs="$strFavoritenURLs $i"
    done
    
    echo -e "$strFavoritenURLs"
}








function fncCheckURLDateiloeschenArray {
    [[ ! -f "$dateiURLS" ]] && return
    flagURLGespeichertPlural="false"
    arrAuslesenURLGespeichert=($(cat $dateiURLS))
    
    #while read -d ' ' eingabeURLgespeichert
    for eingabeURLgespeichert in "${arrAuslesenURLGespeichert[@]}"
    do
        #echo -e "--- DEBUG arrAuslesenURLGespeichert"
        nix=0
        txtFEHLERalteURLSgefunden="\
        Eine Sicherung der zuletzt verwendeten URLs wurde gefunden! Anscheinend<br>\
        konnten die letzten Downloads nicht ordnungsgemäß beendet werden.<br><br>\
        -Falls Sie sich nicht sicher sind, sollten Sie die Datei behalten und die<br>\
        &nbsp;URLs erneut aufrufen. Klicken Sie dazu auf 'Nicht löschen!' oder drücken<br>\
        &nbsp;Sie die 'Return' Taste.<br><br>\
        -Falls Sie die URLs nicht mehr benötigen, können Sie die Datei jetzt löschen.<br>\
        &nbsp;Klicken Sie dazu bitte auf 'Datei löschen!'. Die URLs finden Sie übrigens<br>\
        &nbsp;auch in der Logdatei.<br><br>\
        WICHTIG: Diese Aktion lässt sich <b>nicht rückgängig</b> machen.<br>"
        
        if ( [[ "$eingabeURLgespeichertKOMPLETT" != "" ]] )
        then
            #break;
            eingabeURLgespeichertKOMPLETT="$eingabeURLgespeichertKOMPLETT $eingabeURLgespeichert"
            flagURLGespeichertPlural="true"
        else
            eingabeURLgespeichertKOMPLETT="$eingabeURLgespeichert"
        fi
    done < $dateiURLS
    
    [[ "$flagURLGespeichertPlural" == "false" ]] && txtFEHLERalteURLSgefunden="$txtFEHLERalteURLSgefunden""<hr>Folgende URL wurde gesichert:<br>$eingabeURLgespeichertKOMPLETT<hr>"
    
    [[ "$flagURLGespeichertPlural" == "true" ]] && txtFEHLERalteURLSgefunden="$txtFEHLERalteURLSgefunden""<hr>Folgende URLs wurden gesichert:<br>${eingabeURLgespeichertKOMPLETT// /<br>}<hr>"
    
    eingabeSicherheitsfrageURLDateiLoeschen=$(kdialog --title="URL Sicherung löschen?" --warningcontinuecancel="<h3><center>|--- $datei ---|</center></h3><br>\
    $txtFEHLERalteURLSgefunden<br>\
    <b>Die URL Sicherung endgültig löschen?</b><br>" --continue-label="Nicht löschen!" --cancel-label="Datei löschen!" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    eingabeSicherheitsfrageURLDateiLoeschen="$checkDIALOG"
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -warningcontinuecancel
            # --0 ist continue
            checkDIALOGfehler="" ;;
        (1)
            # -warningcontinuecancel
            # --1 ist cancel
            checkDIALOGfehler="|- Die URL Sicherung wird gelöscht." ;;
        (2)
            # -WICHTIG: continue und cancel wurden getauscht
            # --2 ist cancel
            checkDIALOGfehler="|- Sie haben den Vorgang abgebrochen. Das Skript wird nun beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER: Status $checkDIALOG"\\n\ 
            "|- Ihre Eingabe konnte nicht gespeichert werden, da der Prozess beendet wurde. Entweder"\\n\
            "|- gab es einen internen Fehler oder ein anderer Benutzer/Prozess hat das Programm"\\n\
            "|- geschlossen. Bitte starten Sie $datei neu!"\\n\
            "|-"\\n\
            "|- Nähere Informationen finden Sie in der Logdatei und in der Ausgabe der Konsole. Zum Aufrufen"\\n\
            "|- der Hilfe geben Sie bitte '$datei -h' ein." ;;
    esac
    # -Fehlerausgabe und Datei löschen:
    [[ "$checkDIALOG" -gt 1 ]] && echo -e "$checkDIALOGfehler" && echo -e "|-" && exit $checkDIALOG;
    #[[ "$checkDIALOG" == "1" ]] && echo -e "$checkDIALOGfehler"
    [[ "$checkDIALOG" == "1" ]] && echo -e "$checkDIALOGfehler" && rm $dateiURLS
    
}

fncCheckURLDateiloeschenArray










function fncCheckURLDateiloeschen {
    [[ ! -f "$dateiURLS" ]] && return
    flagURLGespeichertPlural="false"
    while read -d ' ' eingabeURLgespeichert
    do
        echo -e "--- DEBUG while read URLs"
        nix=0
        txtFEHLERalteURLSgefunden="\
        Eine Sicherung der zuletzt verwendeten URLs wurde gefunden! Anscheinend<br>\
        konnten die letzten Downloads nicht ordnungsgemäß beendet werden.<br><br>\
        -Falls Sie sich nicht sicher sind, sollten Sie die Datei behalten und die<br>\
        &nbsp;URLs erneut aufrufen. Klicken Sie dazu auf 'Nicht löschen!' oder drücken<br>\
        &nbsp;Sie die 'Return' Taste.<br><br>\
        -Falls Sie die URLs nicht mehr benötigen, können Sie die Datei jetzt löschen.<br>\
        &nbsp;Klicken Sie dazu bitte auf 'Datei löschen!'. Die URLs finden Sie übrigens<br>\
        &nbsp;auch in der Logdatei.<br><br>\
        WICHTIG: Diese Aktion lässt sich <b>nicht rückgängig</b> machen.<br>"
        
        if ( [[ "$eingabeURLgespeichertKOMPLETT" != "" ]] )
        then
            #break;
            eingabeURLgespeichertKOMPLETT="$eingabeURLgespeichertKOMPLETT $eingabeURLgespeichert"
            flagURLGespeichertPlural="true"
        else
            eingabeURLgespeichertKOMPLETT="$eingabeURLgespeichert"
        fi
    done < $dateiURLS
    
    [[ "$flagURLGespeichertPlural" == "false" ]] && txtFEHLERalteURLSgefunden="$txtFEHLERalteURLSgefunden""<hr>Folgende URL wurde gesichert:<br>$eingabeURLgespeichertKOMPLETT<hr>"
    
    [[ "$flagURLGespeichertPlural" == "true" ]] && txtFEHLERalteURLSgefunden="$txtFEHLERalteURLSgefunden""<hr>Folgende URLs wurden gesichert:<br>${eingabeURLgespeichertKOMPLETT// /<br>}<hr>"
    
    eingabeSicherheitsfrageURLDateiLoeschen=$(kdialog --title="URL Sicherung löschen?" --warningcontinuecancel="<h3><center>|--- $datei ---|</center></h3><br>\
    $txtFEHLERalteURLSgefunden<br>\
    <b>Die URL Sicherung endgültig löschen?</b><br>" --continue-label="Nicht löschen!" --cancel-label="Datei löschen!" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    eingabeSicherheitsfrageURLDateiLoeschen="$checkDIALOG"
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -warningcontinuecancel
            # --0 ist continue
            checkDIALOGfehler="" ;;
        (1)
            # -warningcontinuecancel
            # --1 ist cancel
            checkDIALOGfehler="|- Die URL Sicherung wird gelöscht." ;;
        (2)
            # -WICHTIG: continue und cancel wurden getauscht
            # --2 ist cancel
            checkDIALOGfehler="|- Sie haben den Vorgang abgebrochen. Das Skript wird nun beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER: Status $checkDIALOG"\\n\ 
            "|- Ihre Eingabe konnte nicht gespeichert werden, da der Prozess beendet wurde. Entweder"\\n\
            "|- gab es einen internen Fehler oder ein anderer Benutzer/Prozess hat das Programm"\\n\
            "|- geschlossen. Bitte starten Sie $datei neu!"\\n\
            "|-"\\n\
            "|- Nähere Informationen finden Sie in der Logdatei und in der Ausgabe der Konsole. Zum Aufrufen"\\n\
            "|- der Hilfe geben Sie bitte '$datei -h' ein." ;;
    esac
    # -Fehlerausgabe und Datei löschen:
    [[ "$checkDIALOG" -gt 1 ]] && echo -e "$checkDIALOGfehler" && echo -e "|-" && exit $checkDIALOG;
    #[[ "$checkDIALOG" == "1" ]] && echo -e "$checkDIALOGfehler"
    [[ "$checkDIALOG" == "1" ]] && echo -e "$checkDIALOGfehler" && rm $dateiURLS
    
}

#fncCheckURLDateiloeschen












function fncEINGABEdateiFAVORITEN {
    # -Falls es mehrere Dateien gibt, wird ein Auswahlfenster für Dateien geöffnet!
    
    vorgabePFAD=`pwd`
    vorgabeFILTER="Favoritendatei (*.FAV.*txt)"
    
    # -Es können mehrere Favoritendateien ausgewählt werden, diese werden ausgelesen, zusammengefasst und dann
    #  in $dateiURLSfav gespeichert!
    eingabeDATEIfavoriten=$(kdialog --title="Favoriten wählen:" --getopenfilename --multiple "$vorgabePFAD" "$vorgabeFILTER" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            checkDIALOGfehler=""
            flagFavoritenAuswahlStatus="erfolgreich"
            ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Auswahl der Favoritendatei abgebrochen, daher wird die URL Eingabe gestartet."
            flagFavoritenAuswahlStatus="Abbruch durch Benutzer"
            ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
            "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
            "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
            "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
            "|-"\\n\
            "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
            "|- und die Ausgabe in der Konsole beachten."
            flagFavoritenAuswahlStatus="Abbruch durch Fehler"
            ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        [[ "$checkDIALOG" -gt 1 ]] && exit $checkDIALOG;
    fi
    
    # -einzelne Favoritendatei:
    #cp $eingabeDATEIfavoriten $dateiURLSfav
    
    # -eine oder mehrere Favoritendateien:
    [[ "$checkDIALOG" == "0" ]] && echo -e "`fncDateienAuslesenAusgabe \"$eingabeDATEIfavoriten\"`" > $dateiURLSfav
    #echo -e "$checkDIALOG"
}


#fncDEBUGstart "Favoritenauswahl"

# -Check auf gespeicherte URLS und FAVORITEN
# -Auswahlmenü:
# --Sicherung der URLs löschen.
# --Sicherung der FAVORITEN löschen.
# --Neue Favoriten auswählen und sichern.


flagFAVORITEN="false"
flagFavoritenAuswahl="automatisch"
flagFavoritenAuswahlStatus=""
#if ( [[ ! -f "$dateiURLS" ]] && [[ -f "$dateiURLSfav" ]] )
iaLSarray=(`ls *$datei".URLS.FAV"*"txt" 2>/dev/null`)
iaLSarrayANZAHL=${#iaLSarray[@]}
if ( [[ ! -f "$dateiURLS" ]] && [[ $iaLSarrayANZAHL -gt 0 ]] )
then
    if ( [[ $iaLSarrayANZAHL -gt 1 ]] )
    then
        fncEINGABEdateiFAVORITEN
        flagFavoritenAuswahl="durch-benutzer"
    fi
    
    # -DEBUG: kdialog msgbox
    #kdialog --title "DEBUG -VOR CP- $datei" --msgbox "VOR Kopiervorgang:<br><br>dateiURLSfav zu dateiURLS<br>Favoritendatei zu SicherungURLs"
    
    # -Die gewählte Favoritendatei wird zur $dateiURLS kopiert:
    [[ -f "$dateiURLSfav" ]] && cp $dateiURLSfav $dateiURLS && flagFAVORITEN="true"
fi

#fncDEBUGstop "Favoritenauswahl"






# -DEBUG: kdialog msgbox
#kdialog --title "DEBUG -NACH CP- $datei" --msgbox "NACH Kopiervorgang:<br><br>dateiURLSfav zu dateiURLS<br>Favoritendatei zu SicherungURLs"






eingabeURLgespeichert=""
eingabeURLgespeichertKOMPLETT=""
txtFEHLERalteURLSgefunden=""

if ( [[ -f "$dateiURLS" ]] )
then
    while read eingabeURLgespeichert
    do
        nix=0
#         echo -e "|--- $eingabeURLgespeichert"
#         echo -e "|- Eine Sicherung ('$dateiURLS') der zuletzt verwendeten URLs wurde gefunden!"
#         echo -e "|- Anscheinend konnten die letzten Downloads nicht ordnungsgemäß beendet werden."
#         echo -e "|- Falls Sie sich nicht sicher sind ob alle Downloads fehlerfrei abgeschlossen wurden,"
#         echo -e "|- lassen Sie einfach das Skript mit den alten URLs noch einmal laufen. Dabei werden"
#         echo -e "|- keine Dateien doppelt heruntergeladen!"
#         echo -e "|-"
        if ( [[ "$eingabeURLgespeichertKOMPLETT" != "" ]] )
        then
            #break;
            eingabeURLgespeichertKOMPLETT="$eingabeURLgespeichertKOMPLETT $eingabeURLgespeichert"
        else
            eingabeURLgespeichertKOMPLETT="$eingabeURLgespeichert"
        fi
    done < $dateiURLS
    
    # -Die Standard URLs Sicherung wurde geladen:
    txtFEHLERalteURLSgefunden="<hr><b>INFO:</b><br>\
    Die Sicherung der zuletzt verwendeten URLs wurde geladen! Falls Sie<br>\
    nicht sicher sind, ob alle Downloads fehlerfrei abgeschlossen wurden,<br>\
    können Sie das Skript mit den gesicherten URLs jetzt noch einmal<br>\
    starten.<br>\
    Dabei werden unterbrochene Downloads verlustfrei fortgesetzt und nur die<br>\
    noch fehlenden Dateien neu heruntergeladen!<hr>"
    if ( [[ "$flagFAVORITEN" == "true" ]] )
    then
    #             txtFEHLERalteURLSgefunden="<hr><b>INFO:</b><br>\
    #             Die URLs aus den Favoritendateien wurden erfolgreich importiert. Sie können nun<br>\
    #             einzelne (oder auch alle) URLs aus der Auflistung entfernen, neue URLs hinzufügen<br>\
    #             oder einfach direkt den Download-Prozess starten.<hr>"
        txtFEHLERalteURLSgefunden="<hr><b>INFO:</b><br>\
        Status Favoriten Import: $flagFavoritenAuswahlStatus<br>\
        Die URLs aus den Favoritendateien wurden erfolgreich importiert. Sie können nun<br>\
        einzelne (oder auch alle) URLs löschen, neue URLs hinzufügen oder direkt den<br>\
        Download-Prozess starten.<hr>"
        
        if ( [[ "$flagFavoritenAuswahlStatus" == "Abbruch durch Benutzer" ]] )
        then
            txtFEHLERalteURLSgefunden="<hr><b>INFO:</b><br>\
            Status Favoriten Import: $flagFavoritenAuswahlStatus<br>\
            Sie haben zwar keine Favoritendatei ausgewählt, allerdings gibt es noch eine<br>\
            Favoriten Sicherung (...URLS.FAV.txt), deren Inhalt erfolgreich importiert<br>\
            wurde.<hr>"
        fi
        
    fi
    
fi






# -Falls vorhanden erfolgt hier das einbinden der globalen Shortcut URLs. Allerdings haben die
#  normale URLs Datei und die Favoriten Datei eine höhere Priorität!!!
if ( [[ "$arrSHORTCUTurl" != "" ]] && [[ "$eingabeURLgespeichertKOMPLETT" == "" ]] )
then
    eingabeURLgespeichertKOMPLETT="$arrSHORTCUTurl"
fi




# -DEBUG-INFO:
#echo -e "--- eingabeURL: $eingabeURL --- eingabeURLgespeichertKOMPLETT: $eingabeURLgespeichertKOMPLETT --- arrSHORTCUTurl: $arrSHORTCUTurl"



if ( [[ "$eingabeURL" == "" ]] )
then
    # eingabeURL=$(kdialog --title="URL eingeben!" --inputbox "<hr><b style='align:middle;font-size:bigger'>$datei</b><hr><br>Bitte geben Sie die URLs der Dateien an, die das Skript herunterladen soll. Bei manchen Anbietern kann auch eine komplette Playliste angegeben werden.<br><br>Der WGET Befehl erwartet eine URL zu einem Verzeichnis mit Index Datei oder zu einer gültigen HTML Datei<br><br>Mehrere URLs müssen immer durch Leerzeichen getrennt werden!<br>$txtFEHLERalteURLSgefunden" "$eingabeURLgespeichert" --geometry=400x400)
    eingabeURL=$(kdialog --title="URL eingeben!" --inputbox "<h3><center>|--- $datei ---|</center></h3><br>\
    Bitte geben Sie die URLs der Dateien an, die das Skript herunterladen<br>\
    soll. Bei manchen Anbietern können Sie komplette Playlisten verwenden.<br><br>\
    Bei Webseiten erwartet das Skript entweder eine URL zu einem Verzeichnis<br>\
    (mit einer Index Datei darin) oder eine URL zu einer HTML Datei.<br><br>\
    Mehrere URLs müssen immer durch Leerzeichen getrennt werden!<br><br>\
    $txtFEHLERalteURLSgefunden<br>" "$eingabeURLgespeichertKOMPLETT")
    #$txtFEHLERalteURLSgefunden" "$eingabeURLgespeichertKOMPLETT" --geometry=600x500)
    checkDIALOG=$(echo -e "$?")
else
    checkDIALOG="0"
fi
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            case "$eingabeURL" in
                ( http://???* )
                    checkDIALOGfehler="" ;;
                ( https://???* )
                    checkDIALOGfehler="" ;;
                ( url:?? )
                    checkDIALOGfehler="" ;;
                (*)
                    checkDIALOGfehler="|- FEHLER:\\n|- Sie haben keine gültige URL eingegeben! Das Skript wird daher beendet." ;;
            esac ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die URL-Eingabe abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    
    
    # -Damit URLs nicht wegen der www. Angabe als unterschiedlich gelten:
    eingabeURL=${eingabeURL//:\/\/www./:\/\/}
    
    # -Doppelte Eingaben einfach aus dem String entfernen:
    eingabeURL="`fncCheckEingabeDoppelteEntfernen $eingabeURL`"
    
    
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        if ( [[ "$eingabeURL" != "" ]] )
        then
            echo -e "|- Ihre Eingabe:\\t\\t$eingabeURL"
        fi
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    else
        txtINFOeingabeURL="|- -URL Eingabe:\\t\\t$eingabeURL"
        echo -e $txtINFOeingabeURL
    fi

# -die URL Eingabe wird in einer datei gesichert! $dateiURLS
# --wenn das Skript mit einem Fehler abgebrochen wird, müssen die URLs also nicht
#   noch einmal eingegeben werden
# --wenn das Skript korrekt beendet wird kann die datei gelöscht werden, allerdings
#   solte die Logdatei noch kontrolliert werden... (grep -i "error")
echo -e "$eingabeURL" > $dateiURLS




# ---------------------------------------------------------------------------------------------
# ----- START Force Option abfragen -----------------------------------------------------------
# -das $flagForceGlobal ersetzt -f
if ( [[ "$strg1" != -*qq* ]] )
then
    # -Falls -f schon als Argument beim Befehlsaufruf gesetzt wurde, wird diese Abfrage übersprungen.
    if ( [[ "$flagForceArgument" != "true" ]] )
    then
        kdialog --title="Force Download?" --warningcontinuecancel="<h3><center>|--- $datei ---|</center></h3><br>\
        Um einen erneuten Download zu erzwingen, kann die Force Option<br>\
        gesetzt werden. (\"-f\" beim Aufruf in der Konsole)<br><br>\
        Die IDs der bereits heruntergeladenen Videodateien werden gespeichert<br>\
        um keine Datei doppelt herunterzuladen. Wenn die Datei jedoch erneut<br>\
        oder in einem neuen Format gespeichert werden soll, MUSS die<br>\
        Force Option gesetzt werden.<br><br><br>\
        Möchten Sie die Force Download Option einschalten?" \
        --continue-label="Weiter, OHNE Force Download." --cancel-label="Weiter, MIT Force Download."

        flagFRAGE=$(echo -e "$?")
        if [[ "$flagFRAGE" == "1" ]]
        then
            # -Abbrechen wurde gewählt:
            flagForceGlobal="true"
        else
            # -Weiter wurde gewählt:
            nix=1
        fi
    else
        # -f wurde beim Befehlsaufruf gesetzt
        flagForceGlobal="true"
    fi
fi
# ----- ENDE Force Option abfragen ------------------------------------------------------------
# ---------------------------------------------------------------------------------------------







# ---------------------------------------------------------------------------------------------
# ----- START Reihenfolge und Downloadformat festlegen ----------------------------------------
if ( [[ "$strg1" != -*qqq* ]] )
then
    # -Dieser Teil wird nicht unterdrückt:
    #  Playlistreihenfolge festlegen und Downloadformat auswählen!
    #
    # -Playlistreihenfolge festlegen:
    actionBEFEHLreihenfolge=""
    txtActionBefehlReihenfolge=""
    if ( [[ "$eingabeURL" == *list* ]] || [[ "$eingabeURL" == *channel* ]] )
    then
        # -Bei Playlisten mit verschiedenen Videos/Musiktiteln kann von NEU-zu-ALT (--playlist-reverse)
        #  sinnvoll sein, aber bei Playlisten mit kompletten Musik Alben ist die korrekte Reihenfolge
        #  der Titel dann nicht mehr gegeben!!!
        
        kdialog --title="Reihenfolge?" --yesnocancel="<h3><center>|--- $datei ---|</center></h3><br>\
        Beim Herunterladen von Playlisten kann es sinnvoll sein, die vorgegebene<br>\
        Reihenfolge (von alt zu neu) umzudrehen.<br>\
        Standardmäßig wird beim ersten Video in der Liste begonnen.<br>\
        Alternativ kann aber auch mit dem letzten Video begonnen werden.<br><br>\
        <b>TIPP:</b> Standard bestätigen: [RETURN]<br><br><br>\
        -Vom Ersten Video zum Letzten. (Standard)<br>\
        -1., 2., ... 15., 16.<br><br>\
        -Vom Letzten Video zum Ersten.<br>\
        -16., 15., ... 2., 1.<br><br>" \
        --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!"
#         --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!" >/dev/null 2>&1
        
#         --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!" || echo -e "|- Bei der Auswahl der Reihenfolge ist ein Fehler aufgetreten."
#         --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!" || strFEHLERcode="kdialog:reihenfolge:NA" && echo -e "|- Bei der Auswahl der Reihenfolge ist ein Fehler aufgetreten."
#         D.h. die neu hinzugefügten Videos werden am Ende heruntergeladen.<br><br>\
#         D.h. die neu hinzugefügten Videos werden am Anfang heruntergeladen.<br><br><br>\


        
#         kdialog --title="Reihenfolge?" --warningyesnocancel="<h3><center>|--- $datei ---|</center></h3><br>\
#         Da Playlisten zum Herunterladen angegeben wurden, kann jetzt festgelegt<br>\
#         werden, mit welchen Videos innerhalb der Liste der Download starten soll.<br><br><br>\
#         -Von ALT zu NEU. (Standard)<br>\
#         -1., 2., 3., ... 14., 15., 16.<br>\
#         D.h. neu hinzugefügte Videos am Ende. (Sinnvoll bei Musik Alben!)<br><br>\
#         -Von NEU zu ALT.<br>\
#         -16., 15., 14., ... 3., 2., 1.<br>\
#         D.h. neu hinzugefügte Videos am Anfang.<br><br><br>\
#         <i>TIPP:</i> Standard bestätigen: [RETURN]<br>" \
#         --yes-label="Von ALT zu NEU!" --no-label="Von NEU zu ALT!" --cancel-label="Beenden!"

        flagFRAGE=$(echo -e "$?")
        
        # -Case für Eingabeüberwachung:
        case "$flagFRAGE" in
            ("2")
                # -CANCEL wurde gewählt!
                # -Skript beenden:
                checkDIALOGfehler="|- Sie haben die Auswahl abgebrochen. Das Skript wird daher beendet."
                echo -e $checkDIALOGfehler
                echo -e "|-"
                exit 1;
                ;;
            ("1")
                # -NO wurde gewählt!
                # -Reihenfolge umdrehen:
                actionBEFEHLreihenfolge=" --playlist-reverse"
                txtActionBefehlReihenfolge=", Reihenfolge: vom Letzten zum Ersten"
                ;;
            ("0")
                # -YES wurde gewählt!
                # -Reihenfolge bleibt unverändert:
                actionBEFEHLreihenfolge=""
                txtActionBefehlReihenfolge=", Reihenfolge: vom Ersten zum Letzten"
                ;;
            (*)
                # -Wegen aboutToFinish-Handling...
                # -Skript beenden:
                checkDIALOGfehler="|- Sie haben die Auswahl abgebrochen. Das Skript wird daher beendet."
                echo -e $checkDIALOGfehler
                echo -e "|-"
                exit 2;
                ;;
        esac
        
        
#         if ( [[ "$flagFRAGE" == "2" ]] )
#         then
#             # -CANCEL wurde gewählt!
#             # -Skript beenden:
#             checkDIALOGfehler="|- Sie haben die Eingabe abgebrochen. Das Skript wird daher beendet."
#             echo -e $checkDIALOGfehler
#             echo -e "|-"
#             exit 1;
#         elif ( [[ "$flagFRAGE" == "1" ]] )
#         then
#             # -NO wurde gewählt!
#             # -Reihenfolge umdrehen:
#             actionBEFEHLreihenfolge=" --playlist-reverse"
#         elif ( [[ "$flagFRAGE" == "0" ]] )
#         then
#             # -YES wurde gewählt!
#             # -Reihenfolge bleibt unverändert:
#             actionBEFEHLreihenfolge=""
#             nix=1
#         else
#             # -Wegen aboutToFinish-Handling...
#             # -Reihenfolge bleibt unverändert:
#             actionBEFEHLreihenfolge=""
#             nix=1
#         fi

    fi


    # -Downloadformat auswählen:
    auswahlACTION=$(kdialog --title="Format auswählen!" --radiolist="<h3><center>|--- $datei ---|</center></h3><br>\
    Bitte wählen Sie in welchen Formaten die Daten gespeichert werden sollen.<hr><br>\
    Bei Audiodateien wird automatisch das Video Thumbnail als Cover in der<br>\
    mp3 Datei gespeichert! Nur wenn das Thumbnail zusätzlich als eigenständige<br>\
    Grafikdatei abgespeichert werden soll, wählen Sie eine der Optionen mit \"Thumbnail\".<br>\
    Wenn Sie HTML-Seiten mit allen Ebenen herunterladen, kann die Datenmenge sehr<br>\
    umfangreich werden.<br><br>\
    Standard: \"Nur Video\"<hr><br>\
    Dateiformate auswählen:<br>" \
    "Nur Video" "Nur Video (mp4)" on \
    "Nur Audio" "Nur Audio (mp3)" off \
    "Audio und Thumbnail" "Audio und Thumbnail (mp3, jpg)" off \
    "Video und Audio" "Video und Audio (mp4, mp3)" off \
    "Video, Audio und Thumbnail" "Video, Audio und Thumbnail (mp4, mp3, jpg)" off \
    "HTML-Seiten Ebenen:1" "HTML-Seiten (rekursiv, Ebenen: 1)" off \
    "HTML-Seiten Ebenen:2" "HTML-Seiten (rekursiv, Ebenen: 2)" off \
    "HTML-Seiten Ebenen:alle" "HTML-Seiten (rekursiv, Ebenen: alle)" off)
    #actionGRAFIK "Nur Grafik (wget)" off  --geometry="600x500")
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            case "$auswahlACTION" in
                ("Nur Video")
                    actionBEFEHL="$actionDATEIoptionen $actionFORMAT"
                    txtStandardDownloadSingular="Video"
                    txtStandardDownloadPlural="Videos"
                    ;;
                ("Nur Audio")
                    actionBEFEHL="$actionDATEIoptionen -x --audio-format mp3 --audio-quality 0 --embed-thumbnail"
                    txtStandardDownloadSingular="Audiodatei"
                    txtStandardDownloadPlural="Audiodateien"
                    ;;
                ("Audio und Thumbnail")
                    actionBEFEHL="$actionDATEIoptionen -x --audio-format mp3 --audio-quality 0 --embed-thumbnail --write-thumbnail"
                    txtStandardDownloadSingular="Audiodatei"
                    txtStandardDownloadPlural="Audiodateien"
                    ;;
                ("Video und Audio")
                    actionBEFEHL="$actionDATEIoptionen $actionFORMAT -x -k --audio-format mp3 --audio-quality 0 --embed-thumbnail"
                    txtStandardDownloadSingular="Video/Audiodatei"
                    txtStandardDownloadPlural="Videos/Audiodateien"
                    ;;
                ("Video, Audio und Thumbnail")
                    actionBEFEHL="$actionDATEIoptionen $actionFORMAT -x -k --audio-format mp3 --audio-quality 0 --embed-thumbnail --write-thumbnail"
                    txtStandardDownloadSingular="Video/Audiodatei"
                    txtStandardDownloadPlural="Videos/Audiodateien"
                    ;;
                ("HTML-Seiten Ebenen:1")
                    actionBEFEHL="wget -np -r -l 1 -k -E -p$actionLoginDatenWGET"
                    txtStandardDownloadSingular="HTML-Seite"
                    txtStandardDownloadPlural="HTML-Seiten"
                    ;;
                ("HTML-Seiten Ebenen:2")
                    actionBEFEHL="wget -np -r -l 2 -k -E -p$actionLoginDatenWGET"
                    txtStandardDownloadSingular="HTML-Seite"
                    txtStandardDownloadPlural="HTML-Seiten"
                    ;;
                ("HTML-Seiten Ebenen:alle")
                    actionBEFEHL="wget -np -r -l inf -k -E -p$actionLoginDatenWGET"
                    txtStandardDownloadSingular="HTML-Seite"
                    txtStandardDownloadPlural="HTML-Seiten"
                    ;;
                (*)
                    checkDIALOGfehler="|- FEHLER:\\n|- Die Formatauswahl hat keine Daten übermittelt! Bitte erneut auswählen."
                    ;;
            esac ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Eingabe abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    else
        nix=0
    fi
else
    # -qqq wurde gesetzt, daher müssen die Standard Werte geladen werden!
    actionBEFEHL="$actionDATEIoptionen $actionFORMAT"
    auswahlACTION="Nur Video"
fi

txtINFOauswahlACTION="|- -Speichern:\\t\\t\\t$auswahlACTION"
#echo -e $txtINFOauswahlACTION
# ----- ENDE Reihenfolge und Downloadformat festlegen -----------------------------------------
# ---------------------------------------------------------------------------------------------














# ---------------------------------------------------------------------------------------------
# ----- START Modus actionBEFEHL für Playlist festlegen ---------------------------------------
FlagModusBefehlPlaylist="komplett"
if ( [[ "$strg1" != -*qqqq* ]] && [[ "$eingabeURL" == *list* ]] || [[ "$eingabeURL" == *channel* ]] )
then
    # -Modus actionBEFEHL für Playlist festlegen:
    # --komplett: die komplette Playliste wird zum Download übergeben
    # --einzeln: die Videos der Playliste werden einzeln zum Download übergeben
    
    ModusBefehlPlaylist=$(kdialog --title="Modus wählen!" --radiolist="<h3><center>|--- $datei ---|</center></h3><br>\
    Beim Download von Playlisten oder Channels können Sie zwischen 2 verschiedenen<br>\
    Modi auswählen:<br><br>\
    <b>-komplette Playliste:</b><br>\
    (+) schnelle Verarbeitung<br>\
    (-) kein Zugriff auf einzelne Videos<br><br>\
    <b>-einzelne Videos:</b><br>\
    (+) Zugriff auf einzelne Videos<br>\
    (-) langsame Verarbeitung<br><br>\
    Bitte den Playlist Download Modus wählen:<br>\
    (Standard: \"$FlagModusBefehlPlaylist\")" \
    "komplett" "komplette Playliste" `fncAUSGABEstandardONOFF komplett $FlagModusBefehlPlaylist` \
    "einzeln" "einzelne Videos" `fncAUSGABEstandardONOFF einzeln $FlagModusBefehlPlaylist`)
    #actionGRAFIK "Nur Grafik (wget)" off  --geometry="600x500")
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            case "$ModusBefehlPlaylist" in
                ("komplett")
                    FlagModusBefehlPlaylist=$ModusBefehlPlaylist
                    ;;
                ("einzeln")
                    FlagModusBefehlPlaylist=$ModusBefehlPlaylist
                    ;;
                (*)
                    FlagModusBefehlPlaylist=$ModusBefehlPlaylist
                    ;;
            esac ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Eingabe abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|- Status: $checkDIALOG"
        echo -e "|-"
        exit $checkDIALOG;
    else
        nix=0
    fi
else
    # -qqqq wurde gesetzt, daher müssen die Standard Werte geladen werden!
    nix=0
fi

#txtINFOauswahlModusBefehl="|- -Modus:\\t\\t\\t$FlagModusBefehlPlaylist"
#echo -e $txtINFOauswahlModusBefehl
txtInfoAnzahlVideosMax=", Videos pro URL: $intAnzahlVideosMax"
txtINFOauswahlModusBefehl=" (Pls Modus: $FlagModusBefehlPlaylist""$txtInfoAnzahlVideosMax""$txtActionBefehlReihenfolge)"
txtINFOauswahlACTION="$txtINFOauswahlACTION""$txtINFOauswahlModusBefehl"
echo -e $txtINFOauswahlACTION
# ----- ENDE Modus actionBEFEHL für Playlist festlegen -----------------------------------------------------
# ---------------------------------------------------------------------------------------------





















# --------------------------------------------------------------------
# ----- START actionBEFEHL Korrekturen -------------------------------
# -Nur bei $strBefehlName Aufrufen:
if ( [[ "$actionBEFEHL" == $strBefehlName* ]] )
then
    # -Reihenfolge innerhalb von Playlisten einbauen:
    actionBEFEHL="$actionBEFEHL$actionBEFEHLreihenfolge"

    # -Den eingebauten Downloader anstatt ffmpeg nutzen, da ffmpeg kein Resume unterstützt und
    #  der Beendet-Status nicht korrekt an das Skript weitergeleitet wird!
    #  --hls-prefer-native ODER --hls-prefer-ffmpeg ODER keine Angabe
    #sactionBEFEHL="$actionBEFEHL --hls-prefer-native"
    
    # -Zusatz wegen HTTP-Fehler 412, precondition failed, urllib2
    #actionBEFEHL="$actionBEFEHL --add-header Accept:'*/*'"
    #actionBEFEHL="$actionBEFEHL --no-geo-bypass"
fi
# ----- ENDE actionBEFEHL Korrekturen --------------------------------
# --------------------------------------------------------------------







# -Die Bandbreite begrenzen:
if ( [[ "$eingabeBANDBREITE" != "" ]] && [[ "$eingabeBANDBREITE" != "NEIN" ]] )
then
    actionBEFEHL="$actionBEFEHL --limit-rate $eingabeBANDBREITEfertigBEFEHL"
fi


# -Dateiinfos in die Logdatei schreiben:
echo -e $txtKOPFlogs > $dateiLOGS
echo -e $txtINFOeingabeAUFRUF >> $dateiLOGS
#echo -e $txtINFOeingabeZEITVERSETZT >> $dateiLOGS
#echo -e $txtINFOeingabeBANDBREITE >> $dateiLOGS
echo -e $txtINFOeingabeOPTIONEN >> $dateiLOGS
echo -e $txtINFOeingabeARBEITSVERZEICHNIS >> $dateiLOGS
echo -e $txtINFOeingabeURL >> $dateiLOGS
echo -e $txtINFOauswahlACTION >> $dateiLOGS










# -die Force Download Option einbinden:
#  wenn die Datei bereits heruntergeladen wurde, existiert ein Eintrag im Archiv. um den erneuten Download
#  zu erzwingen wird ein temporäres Archiv benutzt, damit neue Download Einträge auch im Original-Archiv gespeichert
#  werden, wird der Inhalt des archivTMP an das Original-Archiv kopiert. Das archivTMP wird danach wieder gelöscht.
archivTMP="ytdl-archive.tmp"
if ( [[ "$flagForceGlobal" == "true" ]] )
then
    actionBEFEHL="$actionBEFEHL --download-archive $archivTMP"
    #echo -e "--- DEBUG Das temporäre Verzeichnis wird genutzt."
fi






# --------------------------------------------------------------------------------------------------
# -Befehl in Logdatei schreiben:
txtINFObefehl="|- -Befehl:\\t\\t\\t"

# -Umleitung der Ausgabe in die Logdatei:
umleitungLOGDATEI=">> $dateiLOGS 2>> $dateiLOGS"

####################################################################################################
# -Befehl wird nicht mehr am Bildschirm ausgegeben, sondern nur noch in die Logdatei geschrieben,
#  daher wird auch nichts mehr auf intSTATUSzeichenMAX begrenzt.
####################################################################################################
# # -Länge der Ausgabe begrenzen:
# intSTATUSzeichenMAX=220
# typeset -i intSTATUSzeichenKONTROLLE=0
# # -da Position mit null beginnt muss der Kontrollwert intSTATUSzeichenKONTROLLE nicht
# #  um eins erhöht werden
# # -wenn nach der maximalen Anzahl Zeichen der String noch weitergeht wird er gekürzt:
# intSTATUSzeichenKONTROLLE=$intSTATUSzeichenMAX
# intSTATUSzeichen=`echo $actionBEFEHL | awk '{print length($actionBEFEHL)}'`
# 
# txtINFObefehl="|- -Befehl:\\t\\t\\t"
# if ( [[ "$intSTATUSzeichen" -gt $intSTATUSzeichenMAX ]] && [[ "$txtSTATUS" != *%\ of* ]] )
# then
#     #actionBEFEHL=${actionBEFEHL:0:$intSTATUSzeichenMAX}"..."
#     txtINFObefehl=$txtINFObefehl${actionBEFEHL:0:$intSTATUSzeichenMAX}
# else
#     txtINFObefehl=$txtINFObefehl$actionBEFEHL
# fi
# #txtINFObefehl1="|- -Befehl:\\t\\t\\t$actionBEFEHL"
# txtINFObefehl1=$txtINFObefehl
# txtINFObefehl2="|-\\t\\t\\t\\t[URL] $umleitungLOGDATEI"\\n"|-"
# 
# # -Wird nur noch in die Logdatei geschrieben und nicht noch zusätzlich am Bildschirm angezeigt:
# #echo -e $txtINFObefehl1
# #echo -e $txtINFObefehl2
# echo -e "|-"
# 
# echo -e $txtINFObefehl1 >> $dateiLOGS
# echo -e $txtINFObefehl2 >> $dateiLOGS
####################################################################################################
####################################################################################################

txtINFObefehl=$txtINFObefehl$actionBEFEHL" [...URLs...] $umleitungLOGDATEI"
echo -e "|-"
echo -e $txtINFObefehl >> $dateiLOGS


# -Ausgabe der Force Download Option:
if ( [[ "$flagForceGlobal" == "true" ]] )
then
    txtINFOforceDOWNLOAD="|- -Force Download ist eingeschaltet!"
else
    txtINFOforceDOWNLOAD=""
fi
# -Ausgabe der Shutdown Option:
if ( [[ "$strg2" == "-off" ]] )
then
    txtINFOshutdown="|- -Nach erfolgreichem Beenden wird das System abgeschaltet! Wartezeit: 1 min"\\n"|-"
    intOFFminuten=1
elif ( [[ "$strg2" == -off=* ]] )
then
    txtINFOshutdown="|- -Nach erfolgreichem Beenden wird das System abgeschaltet! Wartezeit: $intOFFminuten min"\\n"|-"
elif ( [[ "$strg2" == "-" ]] || [[ "$strg2" == "" ]] )
then
    txtINFOshutdown=""
    intOFFminuten=""
fi
# -Zusatzinfos (Force und Shutdown Option) in Logdatei schreiben:
if ( [[ "$txtINFOforceDOWNLOAD" != "" ]] )
then
    echo -e $txtINFOforceDOWNLOAD
    echo -e $txtINFOforceDOWNLOAD >> $dateiLOGS
fi
if ( [[ "$txtINFOshutdown" != "" ]] )
then
    echo -e $txtINFOshutdown
    echo -e $txtINFOshutdown >> $dateiLOGS
fi










function fncKILLpid {
#     if ( [[ "$1" == "" ]] )
#     then
#         return 10
#     fi

    # -EINSCHALTEN: Tastatureingaben ausgeben/darstellen:
    #stty echo
    
    strKILLsignal=""
    if ( [[ "$2" != "" ]] )
    then
        strKILLsignal="$2 "
    fi
    
    if ( [[ "$1" != "" ]] )
    then
        intKILLpid="$1"
#         if ( [[ `ps -p $intKILLpid | grep -i $intKILLpid` == $intKILLpid* ]] )
#         then
#             #kill $intKILLpid >/dev/null 2>&1
#             # -Die Ausgabe wegen Fehlermeldungen nach Kill abschalten:
#             #exec >/dev/null 2>&1
#             # -Der Kill Befehl:
#             #kill $intKILLpid >/dev/null 2>&1
#             kill $intKILLpid >/dev/null 2>&1
#             # -Die Ausgabe wieder auf den Bildschirm legen:
#             #exec >`tty` 2>&1
#         fi
        typeset -i zKILL=0
        flagDONEkill="false"
        #while ( [[ `ps -p $intKILLpid | grep -i $intKILLpid` == $intKILLpid* ]] )
        #while ( [[ `ps -p $intKILLpid -o pid=` == "$intKILLpid" ]] )
        while ( [[ `ps -p $intKILLpid -o pid=` != "" ]] )
        do
            txtPROZESSname="`ps -p $intKILLpid -o comm=`"
            if ( [[ "$flagDONEkill" != "true" ]] )
            then
                #fncECHOlx "|- "`fncHHMMSS`" INFO $intID: "\ "+- Befehl: Kill SIGTERM $intKILLpid Prozess $txtPROZESSname"
                exec >/dev/null 2>&1
                # -Die Ausgabe in /dev/null umleiten wegen Fehlermeldungen nach Kill Befehl:
                kill $strKILLsignal$intKILLpid >/dev/null 2>&1 &
                exec >`tty` 2>&1
            fi
            #kdialog --title "Status.KILL.`fncHHMMSS 'norm.mS2'`" --passivepopup "--- KILL PID: $intKILLpid<br><br>--- Taste: $eingabeTASTE" 10 --geometry=260x100 &
            zKILL=zKILL+1
            sleep 0.05
            # -Maximale Wartezeit: 10 Sekunden
            #  10 Sekunden / sleep 0.05 = 200 Durchläufe der while Schleife
            #  8 Sekunden / sleep 0.05 = 160 Durchläufe der while Schleife
            [ $zKILL -ge 199 ] && flagDONEkill="true"
            #[ $zKILL -ge 40 ] && fncECHOlx "|- "`fncHHMMSS`" INFO $intID: "\ "+- Befehl: Kill SIGKILL Prozess $txtPROZESSname"
            [ $zKILL -ge 200 ] && kill -9 $intKILLpid >/dev/null 2>&1 &
            [ $zKILL -ge 200 ] && break
            
        done
    fi
    #xset +dpms >/dev/null 2>&1
}




















# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# ::::: Kontrolle erfolgreich NEUSTART ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# -Falls Fehler aufgetreten sind, wird mittels read abgefragt ob das Skript noch einmal mit den
#  gleichen Einstellungen und URLs gestartet werden soll!
# -WHILE Schleife zur Kontrolle und ggf Neustarten
# -Funktion fncKOPFZEILENsicherung speichert die Kopfzeilen in einer Variablen, damit bei Neustart
#  der Bildschirm gelöscht werden kann und die Kopfzeilen nochmals angezeigt werden können

function fncKOPFZEILENsicherung () {
    txtKOPFZEILENsicherung=""
    while read txtKOPFZEILENsicherungTMP
    do
        if ( [[ "$txtKOPFZEILENsicherung" == "" ]] )
        then
            txtKOPFZEILENsicherung="$txtKOPFZEILENsicherungTMP"
        else
            txtKOPFZEILENsicherung="$txtKOPFZEILENsicherung"\\n"$txtKOPFZEILENsicherungTMP"
        fi
    done < $dateiLOGS
}
fncKOPFZEILENsicherung

flagERFOLGREICHabgeschlossen="false"
flagNEUSTART="false"

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# ::::: START While Kontrolle erfolgreich NEUSTART ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
while ( [[ "$flagERFOLGREICHabgeschlossen" == "false" ]] )
do
    if ( [[ "$flagNEUSTART" == "true" ]] )
    then
        fncClearX
        echo -e "$txtKOPFZEILENsicherung"
        # -Zusätzliche Infos für die Logdatei:
        zeitSTARTutc=`date '+%s'`
        zeitSTART=`date -d @$zeitSTARTutc`
        echo -e "|-"\\n"|- Neustart"\\n"|- $zeitSTART"\\n"|-" >> $dateiLOGS
        echo -e $txtKOPFZEILENsicherung >> $dateiLOGS
    fi




    
    
# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------
# ----- START Befehl zusammen bauen und aufrufen: -------------------------------------------------
#
# -Eingegebene URLS in Array umwandeln, damit jede URL einen eigenen $strBefehlName Befehl
#  erhält, erforderlich für Unterverzeichnis pro Playlist!!!
#  read -a eingabeURLarray < $eingabeURL
actionBefehlStderrDevNull="2>/dev/null"
checkBEFEHLinternRETURN=""
checkBEFEHLinternPID=""

intPLAYLISTitemsMAX=0
intPLAYLISTitems=0

flagQUITpsTasteF="false"
flagNEXTurl="false"
flagNEXTdatei="false"
flagCHECKurlsKOMPLETT="false"
FlagModusBefehlKOMPLETTquit=""


# -URL Array bilden:
read -a eingabeURLarray <<zzzTRENNERzzz
$eingabeURL
zzzTRENNERzzz


# -Wenn nur eine Playliste angegeben wurde und gleichzeitig als Download Modus "einzeln"
#  ausgewählt wurde: Videos können über die Id oder einen Zahlenraum definiert werden!
typeset -i intAnzUrlsGesamt=${#eingabeURLarray[@]}
#[ $intAnzUrlsGesamt -eq 1 ] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]]




################################################################################
function fncBefehlOutputOptionen {
    # -Output Optionen für Videos:
    actionPOSTbefehl=" --exec 'echo {} $txtPLAYLISTaktuell{}'"
    #actionBEFEHLoutputVIDEO=" -o %(title)s-%(id)s.%(ext)s"
    #actionBEFEHLoutputVIDEO=" -o %(title)s_%(id)s.%(ext)s"
    actionBEFEHLoutputVIDEO=" --autonumber-start $zURL -o %(autonumber)03d_%(title)s.%(ext)s"
    # -Output Optionen für Playliste:
    # --playlist: Name oder ID der Playliste
    # --playlist_id: ID der Playliste
    # --playlist_title: Titel der Playliste
    actionBEFEHLoutputPLAYLIST=" -o %(playlist)s/%(playlist_index)s_%(title)s.%(ext)s"
    actionBEFEHLoutputPLAYLISTyoutube=" -o %(playlist_title)s/%(playlist_index)s_%(title)s.%(ext)s"
    actionBEFEHLoutput="$actionBEFEHLoutputVIDEO"
}
################################################################################






function fncBEFEHLaufrufen {
    typeset -i z=0
    typeset -i zURL=1
#     read -a eingabeURLarray <<zzzTRENNERzzz
#     $eingabeURL
# zzzTRENNERzzz
    
#     ################################################################################
#     # -Output Optionen für Videos:
#     actionPOSTbefehl=" --exec 'echo {} $txtPLAYLISTaktuell{}'"
#     #actionBEFEHLoutputVIDEO=" -o %(title)s-%(id)s.%(ext)s"
#     #actionBEFEHLoutputVIDEO=" -o %(title)s_%(id)s.%(ext)s"
#     actionBEFEHLoutputVIDEO=" --autonumber-start $zURL -o %(autonumber)03d_%(title)s.%(ext)s"
#     # -Output Optionen für Playliste:
#     # --playlist: Name oder ID der Playliste
#     # --playlist_id: ID der Playliste
#     # --playlist_title: Titel der Playliste
#     actionBEFEHLoutputPLAYLIST=" -o %(playlist)s/%(playlist_index)s_%(title)s.%(ext)s"
#     actionBEFEHLoutputPLAYLISTyoutube=" -o %(playlist_title)s/%(playlist_index)s_%(title)s.%(ext)s"
#     actionBEFEHLoutput=$actionBEFEHLoutputVIDEO
#     ################################################################################
    
    
    # -------------------------------------------------------------------------------
    # ----- PLS-Modus-Einzeln START -------------------------------------------------
    # -----
    while ( [[ "${eingabeURLarray[$z]}" != "" ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
    do
        # -Output Optionen integrieren:
        fncBefehlOutputOptionen
        
        # -Download von Playlisten splitten anhand von playlist_items=1 usw.
        # -Gesamtanzahl der Items auslesen und damit WHILE-Schleife bauen.
        #
        # $strBefehlName --flat-playlist --dump-single-json https://www.youtube.com/watch?v=Q-oOwHlEtmU | grep -i -o '{"url"' | wc -l
        # $strBefehlName --flat-playlist --dump-single-json https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -i -o '{"url"' | wc -l
        # $strBefehlName --flat-playlist --dump-single-json https://www.youtube.com/watch?v=pFkzeRthzVU&list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -i -o '{"url"' | wc -l
        # $strBefehlName --flat-playlist https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -i -o 'Downloading video' | wc -l
        
        
        [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
        
        #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS` >> $dateiLOGS
        #echo -e "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        [ $zURL -eq ${#eingabeURLarray[@]} ] && flagCHECKurlsKOMPLETT="true" && echo -e "true" > $dateiCACHEflagCHECKurlsKOMPLETT
        
        # -DEBUG
        #kdialog --title "$datei DEBUG" --msgbox "--- DEBUG" --geometry=400x200 &
        #kdialog --title "$datei DEBUG" --msgbox "--- DEBUG $FlagModusBefehlPlaylist<br>--- DEBUG flagCHECKurlsKOMPLETT: $flagCHECKurlsKOMPLETT<br>--- DEBUG zURL: $zURL" &
        
        zURL=zURL+1
        
        typeset -i intPLAYLISTitemsMAX=1
        # -Alte doppelte Abfrage, vor Einbau !=*.youtube.*
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && strPLAYLISTflatJSON=`$strBefehlName --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -i -o '{"url"' | wc -l 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && strPLAYLISTflatJSON=`$strBefehlName --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -i -o '{"url"' | wc -l 2>/dev/null`
        
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && strPLAYLISTflatJSON=`$strBefehlName --flat-playlist ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -i -o 'Downloading video' | wc -l 2>/dev/null`
        
        
        function fncPlaylistVideoIDs {
            vorgabePlaylistVideoIDs="1-$intPLAYLISTitemsMAX"
            eingabePlaylistVideoIDs="$vorgabePlaylistVideoIDs"
            
            [ -n "$flagEingabeVideoIDs" ] && eingabePlaylistVideoIDs=$(kdialog --title="$datei.Info" --inputbox "<h3><center>|--- $datei ---|</center></h3><br>\
            Bitte geben Sie anhand der Nummerierung, die Videos an,<br>\
            die Sie herunterladen möchten. Dafür gibt es mehrere<br>\
            Möglichkeiten:<br><br>\
            -> Die IDs der gewünschten Videos:<br>\
            --> \"2 3 4 9 10 11 12\"<br>\
            -> Der Zahlenraum der entsprechenden Videos:<br>\
            --> \"2-4 9-12\"<br>\
            Alle Eingaben müssen mittels Leerzeichen getrennt werden.<br><br>\
            <b>Aktuelle Playliste: ${eingabeURLarray[$z]}</b><br>\
            Standard: Alle Videos ($vorgabePlaylistVideoIDs)<br>" "$vorgabePlaylistVideoIDs")
            
            #IFS="," read -a arrPlaylistEingabe <<<$eingabePlaylistVideoIDs
            arrPlaylistEingabe=($eingabePlaylistVideoIDs)
            
            strArrEingabe=""
            strArrTRENNER=""
            typeset -i iEingabeStart=0 iEingabeEnde=0 iEingabeZ=0
            for iEingabe in ${arrPlaylistEingabe[@]}
            do
                if ( [[ "$iEingabe" == *-* ]] )
                then
                    iEingabeStart=${iEingabe//\-*/}
                    iEingabeEnde=${iEingabe//*\-/}
                    iEingabeZ=$iEingabeStart
                    iEingabeEnde=iEingabeEnde+1
                    while [ $iEingabeZ -lt $iEingabeEnde ]
                    do
                        iEingabe=$iEingabeZ
                        strArrEingabe="$strArrEingabe""$strArrTRENNER""$iEingabe"
                        [ -z $strArrTRENNER ] && strArrTRENNER=" "
                        iEingabeZ=iEingabeZ+1
                    done
                    
                else
                    #[ -z $strArrEingabe ] && strArrEingabe="$iEingabe" && continue
                    strArrEingabe="$strArrEingabe""$strArrTRENNER""$iEingabe"
                    [ -z $strArrTRENNER ] && strArrTRENNER=" "
                fi
            done
            arrPlaylistVideoIDs=($strArrEingabe)
        }
        
        [ $intPLAYLISTitemsMAX -lt 1 ] && intPLAYLISTitemsMAX=1
        
        flagEingabeVideoIDs=""
        arrPlaylistVideoIDs=""
        [ $intAnzUrlsGesamt -eq 1 ] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] && flagEingabeVideoIDs="true" && fncPlaylistVideoIDs
        
        
        
        typeset -i zzIDs=0
        typeset -i intPLAYLISTitems=0
        typeset -i intPLAYLISTitemsENDE=1
        typeset -i intPLAYLISTitemsREVERSE=0
        intPLAYLISTitemsREVERSE=$intPLAYLISTitemsMAX
        echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
        #while [ $intPLAYLISTitems -lt $intPLAYLISTitemsMAX ]
        while ( ( [ $intPLAYLISTitems -lt $intPLAYLISTitemsMAX ] && [ -z $flagEingabeVideoIDs ] ) || [[ "${arrPlaylistVideoIDs[$zzIDs]}" != "" ]] )
        do
            #[ ! -f $dateiCACHEplsINFOS ] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            
            [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
            [[ "$flagNEXTurl" == "true" ]] && break
            
            #[ $intPLAYLISTitems -eq 0 ] && intPLAYLISTitems=intPLAYLISTitems+1 && echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            intPLAYLISTitems=intPLAYLISTitems+1
            intPLAYLISTitemsENDE=intPLAYLISTitemsENDE+1
            #echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            
            
            # -Sonderfall: VideoIDs konnten durch Benutzereingabe festgelegt werden:
            [ -n $flagEingabeVideoIDs ] && intPLAYLISTitems=${arrPlaylistVideoIDs[$zzIDs]} && zzIDs=zzIDs+1
            
            
            #echo -e "["`fncHHMMSS`"]"
            #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
            
            #echo -e "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            fncECHOplatzhalter "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            
            echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
            actionBEFEHLitems=""
            if ( [[ "${eingabeURLarray[$z]}" == *list* ]] || [ $intPLAYLISTitemsMAX -gt 1 ] )
            then
                actionBEFEHLoutput=$actionBEFEHLoutputPLAYLIST
                #actionBEFEHLitems=" --playlist-items $intPLAYLISTitems"
                #actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems --max-downloads 1"
                
                #[[ -z "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems"
                #[[ -n "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitemsREVERSE --playlist-end $intPLAYLISTitemsREVERSE"
                
                actionBEFEHLitems=" --playlist-items $intPLAYLISTitems"
                intPLAYLISTitemsREVERSE=intPLAYLISTitemsREVERSE-1
            fi
            #echo -e "|--- $actionBEFEHL$actionPOSTbefehl ${eingabeURLarray[$z]}"
            #echo -e "|--- $actionBEFEHL$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            checkBEFEHL="echo -e $actionBEFEHL ${eingabeURLarray[$z]}"
            if ( [[ "$actionBEFEHL" == $strBefehlName* ]] )
            then
                #checkBEFEHL="echo -e $actionBEFEHL$actionBEFEHLitems$actionBEFEHLoutput ${eingabeURLarray[$z]}  $actionBefehlStderrDevNull"
                checkBEFEHL="echo -e $actionBEFEHL$actionBEFEHLitems$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            fi
            `$checkBEFEHL` >> $dateiLOGS 2>> $dateiLOGS &
            checkBEFEHLinternRETURN=$?
            checkBEFEHLinternPID=$!
            
            # -Limit erhöhen und Zeitbedarf checken: 
            cpulimit -p $checkBEFEHLinternPID -q -z -c 2 -l 10 &
            
            
            #echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
            #echo -e `wait $checkBEFEHLinternPID` > "$datei.AUSGABEwait.tmp" 2>&1
            #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
            #echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
            
            echo -e "$checkBEFEHLinternPID" > $dateiCACHEflagQUIT
            kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
            while ( [[ "$kontrollePID" != "" ]] )
            do
                sleep 0.1
                kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
                
                [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && flagQUITpsTasteF="true"
                
                # -taste-U-pls-modus-komplett
                [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
                
                # -taste-D-pls-modus-einzeln
                [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTdatei" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTdatei="true" && break
                
                #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
                #echo -e "arbeitet.$checkBEFEHLinternRETURN" > "$datei.$$.cacheBEFEHLinternRETURN.tmp"
                #echo -e "$checkBEFEHLinternPID" > "$datei.$$.cacheBEFEHLinternPID.tmp"
                #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.01.tmp"
                
#                 intUTCsekunden=`date '+%s'`
#                 if ( [[ "$intUTCsekunden" == *0 ]] || [[ "$intUTCsekunden" == *2 ]] || [[ "$intUTCsekunden" == *4 ]] || [[ "$intUTCsekunden" == *6 ]] || [[ "$intUTCsekunden" == *8 ]] )
#                 then
#                     intPLAYLISTitemLOGS=`cat $dateiCACHEplsINFOSitem`
#                     [ $intPLAYLISTitems -lt $intPLAYLISTitemLOGS ] && intPLAYLISTitems=$intPLAYLISTitemLOGS && fncKILLpid $checkBEFEHLinternPID
#                     kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
#                     #intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 12" | bc`
#                     #fncStatusLogsAnzeigen
#                     #flagSTATUSvorbereiten="true"
#                 fi
            done
            # -cpulimit mit --monitor-forks erzeugt dutzende weitere Aufrufe, daher:
            #kill -9 `ps -C cpulimit -o pid=` >/dev/null 2>&1
            
            function fncKILLpidLISTE {
            [ ! $1 ] && echo -e "--- Fehler: \$1 (Prozessname) nicht übergeben!" && exit 20;
            vorgabeTTY=`tty`
            vorgabeTTY=${vorgabeTTY//\/dev\//}
            
            #iaLSarray=(`ps -C cpulimit --tty $iaTERMINAL -o pid=`)
            iaLSarray=(`ps -C cpulimit -o pid=`)
            typeset -i zz=0
            typeset -i zzTTY=0
            for ia in ${iaLSarray[@]}
            do
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+ $zz - PS: $ia + "
                
                iaTTY=`ps -p $ia -o tty=`
                #[[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && echo -en "+ TTY: $iaTTY --- "
                [[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && fncKILLpid $ia >/dev/null 2>&1
                
                
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+++ Index $zz: $ia "
                #[ $zz -lt ${#iaLSarray[@]} ] && echo -e "--- $zz -lt ${#iaLSarray[@]}"
                #[ 17 -eq ${#iaLSarray[@]} ] && echo -e "--- -eq ${#iaLSarray[@]}"
                zz=zz+1
            done
            }
            fncKILLpidLISTE "cpulimit" >/dev/null 2>&1
            
            #[ -f $dateiCACHEplsINFOS ] &&
            #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.02.tmp"
        done
        [ -f $dateiCACHEplsINFOS ] && rm $dateiCACHEplsINFOS
        [ -f $dateiCACHEplsINFOSitem ] && rm $dateiCACHEplsINFOSitem
        flagNEXTurl="false"
        flagNEXTdatei="false"
        z=z+1
    done
    # -----
    # ----- PLS-Modus-Einzeln ENDE --------------------------------------------------
    # -------------------------------------------------------------------------------
    
    
    # -------------------------------------------------------------------------------
    # ----- PLS-Modus-Komplett START ------------------------------------------------
    # -----
    while ( [[ "${eingabeURLarray[$z]}" != "" ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
    do
        # -das flagNEXTurl wegen der Anzahl Videos zurücksetzen:
        echo -e "" > $dateiCACHEflagQUIT
        
        # -Output Optionen integrieren:
        fncBefehlOutputOptionen
        
        # -Download von Playlisten splitten anhand von playlist_items=1 usw.
        # -Gesamtanzahl der Items auslesen und damit WHILE-Schleife bauen.
        #
        # $strBefehlName --flat-playlist --dump-single-json https://www.youtube.com/watch?v=Q-oOwHlEtmU | grep -i -o '{"url"' | wc -l
        # $strBefehlName --flat-playlist --dump-single-json https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -i -o '{"url"' | wc -l
        # $strBefehlName --flat-playlist --dump-single-json https://www.youtube.com/watch?v=pFkzeRthzVU&list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -i -o '{"url"' | wc -l
        # $strBefehlName --flat-playlist https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -i -o 'Downloading video' | wc -l
        
        
        [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
        
        #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS` >> $dateiLOGS
        #echo -e "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        [ $zURL -eq ${#eingabeURLarray[@]} ] && flagCHECKurlsKOMPLETT="true" && echo -e "true" > $dateiCACHEflagCHECKurlsKOMPLETT
        #echo -e "--- $zURL - flagCHECKurlsKOMPLETT: $flagCHECKurlsKOMPLETT"
        
        # -DEBUG
        #kdialog --title "$datei DEBUG" --msgbox "--- DEBUG" --geometry=400x200 &
        #kdialog --title "$datei DEBUG" --msgbox "--- DEBUG $FlagModusBefehlPlaylist<br>--- DEBUG flagCHECKurlsKOMPLETT: $flagCHECKurlsKOMPLETT<br>--- DEBUG zURL: $zURL" &
        
        zURL=zURL+1
        
        typeset -i intPLAYLISTitemsMAX=1
        # -Alte doppelte Abfrage, vor Einbau !=*.youtube.*
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && strPLAYLISTflatJSON=`$strBefehlName --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -i -o '{"url"' | wc -l 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && strPLAYLISTflatJSON=`$strBefehlName --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -i -o '{"url"' | wc -l 2>/dev/null`
        
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && strPLAYLISTflatJSON=`$strBefehlName --flat-playlist ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -i -o 'Downloading video' | wc -l 2>/dev/null`
        
        
        [ $intPLAYLISTitemsMAX -lt 1 ] && intPLAYLISTitemsMAX=1
        
        typeset -i intPLAYLISTitems=0
        typeset -i intPLAYLISTitemsENDE=1
        typeset -i intPLAYLISTitemsREVERSE=0
        intPLAYLISTitemsREVERSE=$intPLAYLISTitemsMAX
        echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
#         while [ $intPLAYLISTitems -lt $intPLAYLISTitemsMAX ]
#         do
            #[ ! -f $dateiCACHEplsINFOS ] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            
            [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
            [[ "$flagNEXTurl" == "true" ]] && break
            
            #[ $intPLAYLISTitems -eq 0 ] && intPLAYLISTitems=intPLAYLISTitems+1 && echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            intPLAYLISTitems=intPLAYLISTitems+1
            intPLAYLISTitemsENDE=intPLAYLISTitemsENDE+1
            #echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            
            #echo -e "["`fncHHMMSS`"]"
            #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
            
            #echo -e "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            fncECHOplatzhalter "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            
            echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
            actionBEFEHLitems=""
            if ( [[ "${eingabeURLarray[$z]}" == *list* ]] || [ $intPLAYLISTitemsMAX -gt 1 ] )
            then
                actionBEFEHLoutput=$actionBEFEHLoutputPLAYLIST
                #actionBEFEHLitems=" --playlist-items $intPLAYLISTitems"
                #actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems --max-downloads 1"
#                 [[ -z "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems"
#                 [[ -n "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitemsREVERSE --playlist-end $intPLAYLISTitemsREVERSE"
#                 intPLAYLISTitemsREVERSE=intPLAYLISTitemsREVERSE-1
            fi
            
            #echo -e "|--- $actionBEFEHL$actionPOSTbefehl ${eingabeURLarray[$z]}"
            #echo -e "|--- $actionBEFEHL$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            checkBEFEHL="echo -e $actionBEFEHL ${eingabeURLarray[$z]}"
            if ( [[ "$actionBEFEHL" == $strBefehlName* ]] )
            then
                #checkBEFEHL="echo -e $actionBEFEHL$actionBEFEHLitems$actionBEFEHLoutput ${eingabeURLarray[$z]} $actionBefehlStderrDevNull"
                checkBEFEHL="echo -e $actionBEFEHL$actionBEFEHLitems$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            fi
            `$checkBEFEHL` >> $dateiLOGS 2>> $dateiLOGS &
            checkBEFEHLinternRETURN=$?
            checkBEFEHLinternPID=$!
            
            # -Limit erhöhen und Zeitbedarf checken: 
            cpulimit -p $checkBEFEHLinternPID -q -z -c 2 -l 10 &
            
            
            # -DEBUG START
            #intSSpopup=10
            #kdialog --passivepopup "--- INFO: $datei ---<br><br>PID 'checkBEFEHL': $checkBEFEHLinternPID<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
            # -DEBUG ENDE
            
            echo -e "$checkBEFEHLinternPID" > $dateiCACHEflagQUIT
            kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
            while ( [[ "$kontrollePID" != "" ]] )
            do
                sleep 0.1
                kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
                
                [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && flagQUITpsTasteF="true"
                
                [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
                
                #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
                #echo -e "arbeitet.$checkBEFEHLinternRETURN" > "$datei.$$.cacheBEFEHLinternRETURN.tmp"
                #echo -e "$checkBEFEHLinternPID" > "$datei.$$.cacheBEFEHLinternPID.tmp"
                #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.01.tmp"
                
#                 intUTCsekunden=`date '+%s'`
#                 if ( [[ "$intUTCsekunden" == *0 ]] || [[ "$intUTCsekunden" == *2 ]] || [[ "$intUTCsekunden" == *4 ]] || [[ "$intUTCsekunden" == *6 ]] || [[ "$intUTCsekunden" == *8 ]] )
#                 then
#                     intPLAYLISTitemLOGS=`cat $dateiCACHEplsINFOSitem`
#                     [ $intPLAYLISTitems -lt $intPLAYLISTitemLOGS ] && intPLAYLISTitems=$intPLAYLISTitemLOGS && fncKILLpid $checkBEFEHLinternPID
#                     kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
#                     #intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 12" | bc`
#                     #fncStatusLogsAnzeigen
#                     #flagSTATUSvorbereiten="true"
#                 fi
            done
            # -cpulimit mit --monitor-forks erzeugt dutzende weitere Aufrufe, daher:
            #kill -9 `ps -C cpulimit -o pid=` >/dev/null 2>&1
            
            function fncKILLpidLISTE {
            [ ! $1 ] && echo -e "--- Fehler: \$1 (Prozessname) nicht übergeben!" && exit 20;
            vorgabeTTY="pts/6"
            vorgabeTTY=`tty`
            vorgabeTTY=${vorgabeTTY//\/dev\//}
            
            #iaLSarray=(`ps -C cpulimit --tty $iaTERMINAL -o pid=`)
            iaLSarray=(`ps -C cpulimit -o pid=`)
            typeset -i zz=0
            typeset -i zzTTY=0
            for ia in ${iaLSarray[@]}
            do
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+ $zz - PS: $ia + "
                
                iaTTY=`ps -p $ia -o tty=`
                #[[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && echo -en "+ TTY: $iaTTY --- "
                [[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && fncKILLpid $ia >/dev/null 2>&1
                #[[ "$iaTTY" != "$vorgabeTTY" ]] && echo -e "--- Fehler: 'Vorgabe Terminal' NICHT-GLEICH 'Terminal aus Prozessliste'" && beep -l 400 -f 300 -r 3 -D 20
                
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+++ Index $zz: $ia "
                #[ $zz -lt ${#iaLSarray[@]} ] && echo -e "--- $zz -lt ${#iaLSarray[@]}"
                #[ 17 -eq ${#iaLSarray[@]} ] && echo -e "--- -eq ${#iaLSarray[@]}"
                zz=zz+1
            done
            }
            #fncKILLpidLISTE "cpulimit" >/dev/null 2>&1
            #fncKILLpidLISTE "cpulimit" >>$dateiLOGS 2>>&1
            fncKILLpidLISTE "cpulimit"
            
            
            #[ -f $dateiCACHEplsINFOS ] &&
            #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.02.tmp"
            
#         done
        
        [ -f $dateiCACHEplsINFOS ] && rm $dateiCACHEplsINFOS
        [ -f $dateiCACHEplsINFOSitem ] && rm $dateiCACHEplsINFOSitem
        flagNEXTurl="false"
        z=z+1
    done
    # -----
    # ----- PLS-Modus-Komplett ENDE -------------------------------------------------
    # -------------------------------------------------------------------------------
    
    
    #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.03.tmp"
}

fncBEFEHLaufrufen &
checkBEFEHLreturn=$?
checkBEFEHLpid=$!
checkBEFEHLreturnORIGINAL=$checkBEFEHLreturn
#echo -e "--- DEBUG-INFO: BEFEHLpid: $checkBEFEHLpid - BEFEHLreturn: $checkBEFEHLreturn"


# -----------------------------------------------------------------------------
# ----- START interne PID sichern und prüfen ----------------------------------
function fncAUSLESENbefehlINTERN {
    strAUSLESENdatei="$datei.$$.cache.internRETURN.01.tmp"
    # -Falls Cache Datei noch nicht erstellt wurde, wird darauf gewartet:
    while ( [[ ! -f "$strAUSLESENdatei" ]] )
    do
        sleep 0.1
        #beep -l 100 -f 120 -d 100
    done
    
    # -Den RETURN des internen Befehls auslesen:
    while read checkBEFEHLinternRETURNcache
    do
        checkBEFEHLinternRETURN=$checkBEFEHLinternRETURNcache
    done < $strAUSLESENdatei
    [ -f $strAUSLESENdatei ] && rm $strAUSLESENdatei

    checkBEFEHLreturn=`wait $checkBEFEHLpid`
    #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
}


#fncAUSLESENbefehlINTERN
#echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
# ----- ENDE interne PID sichern und prüfen -----------------------------------
# -----------------------------------------------------------------------------


# checkBEFEHL="echo -e $actionBEFEHL $eingabeURL"
# #echo -e "*** DEBUG: checkBEFEHL"\\n"*** "$checkBEFEHL" "$umleitungLOGDATEI
# #echo -e "*** DEBUG: checkBEFEHL"
# #echo -e "*** "$checkBEFEHL" "$umleitungLOGDATEI
# `$checkBEFEHL` >> $dateiLOGS 2>> $dateiLOGS &
# checkBEFEHLreturn=$?
# checkBEFEHLpid=$!
# #checkBEFEHLreturn=$?
# #checkBEFEHLpid=$!
#
# ----- ENDE Befehl zusammen bauen und aufrufen: --------------------------------------------------
# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------





function fncCHECKzugriffeLOGS {
    # -Um laufende Schreibzugriffe auf die Logdatei nicht zu stören, wird
    #  bei Bedarf eine kurze Pause eingebaut:
    #while ( [[ `lsof $dateiLOGS | grep -i $strBefehlName 2>/dev/null` != "" ]] )
    #while ( [[ `lsof "$dateiLOGS" | grep -i $strBefehlName 2>/dev/null` != "" ]] && [[ `lsof "$dateiLOGS" | grep -i "$datei" 2>/dev/null` != "" ]] )
    while ( [[ `lsof "$dateiLOGS" 2>/dev/null | grep -i $strBefehlName 2>/dev/null` != "" ]] && [[ `lsof "$dateiLOGS" 2>/dev/null | grep -i "$datei" 2>/dev/null` != "" ]] )
    do
        #beep -l 60 -f 220 -r 1 -D 40
        sleep 0.1
    done
}

function fncCheckZugriffeDatei {
    # -Um laufende Zugriffe auf die Datei $1 durch das Programm $2 zu
    #  erkennen, diese ggf zu überwachen und auf deren Beendung zu warten.
    [[ -z "$1" ]] && echo -e "|- FEHLER:"\\t"1. Argument nicht angegeben!" && return 11
    [[ -z "$2" ]] && echo -e "|- FEHLER:"\\t"2. Argument nicht angegeben!" && return 12
    strCheckZugriffeDatei="$1"
    strCheckZugriffeProgramm="$2"
    
    #while ( [[ `lsof $dateiLOGS | grep -i $strBefehlName 2>/dev/null` != "" ]] )
    while ( [[ `lsof "$strCheckZugriffeDatei" 2>/dev/null | grep -i "$strCheckZugriffeProgramm" 2>/dev/null` != "" ]] && [[ `lsof "$strCheckZugriffeDatei" 2>/dev/null | grep -i "$datei" 2>/dev/null` != "" ]] )
    do
        #beep -l 60 -f 220 -r 1 -D 40
        sleep 0.1
    done
    return 0
}




function fncMOVEkreisel {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.02
    done
}

function fncMOVEkreiselSlow005 {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.05
    done
}

function fncMOVEkreiselSlow010 {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.1
    done
}

function fncMOVEkreiselSlow015 {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.15
    done
}

function fncMOVEkreiselSlow025 {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.25
    done
}




function fncMOVEasciiKREISEL {
    asciiKREISEL[0]="-"
    asciiKREISEL[1]="\\"
    asciiKREISEL[2]="|"
    asciiKREISEL[3]="/"
    tput cup $cursorZEILEkreisel 38
    echo -ne "\b${asciiKREISEL[0]}"
    #echo -n "-"
    #beep -l 60 -f 700 -D 100
    actionKONTROLLE="start"
    intUTCsekunden=`date '+%s'`
    #intUTCreloadSTATUS="$intUTCsekunden"
    intUTCreloadSTATUS=`echo -e "$intUTCsekunden - 1" | bc`
    intUTCReloadStatusAnzeigen=`echo -e "$intUTCsekunden + 5" | bc`
    flagSTATUSvorbereiten="true"
    # -Das flagStatusAnzeigeSek10 legt hier fest ob die Aktualisierung der Anzeige direkt
    #  durchgeführt wird (true), oder erst nachdem fncStatusLogsKopieren angestossen wurde (false).
    flagStatusAnzeigeSek10="false"
    
    # -DEBUG START
    intSSpopup=10
    txtDebugPassivePopup="fncMOVEasciiKREISEL: Starte While!"
    #kdialog --passivepopup "--- INFO: $datei<br>--- INFO: `fncHHMMSS 'norm.mS3'`<br><br>$txtDebugPassivePopup<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
    txtDebugPassivePopup=""
    # -DEBUG ENDE
    
    while ( [[ "$actionKONTROLLE" == "start" ]] )
    do
        intUTCsekunden=`date '+%s'`
        #if ( [[ "$intUTCsekunden" -ge "$intUTCreloadSTATUS" ]] && [[ "$intUTCsekunden" == *0 ]] )
        
        
        # -Wegen Verzögerungen bei der Anzeige des Status wird die Funktion gesplittet:
        # --Die beiden Funktionen fncStatusLogsKopieren und fncStatusLogsAuslesen brauchen
        #   teilweise 15 Sekunden und mehr für die Ausführung. Um sicherzustellen, dass das
        #   Auslesen abgeschlossen ist, werden beide zum gleichen Zeitpunkt gestartet!
        # --Die fncStatusLogsAuslesen wird jetzt im Hintergrund ausgeführt.
        # --Die $dateiLOGStmpSTATUS wird nicht mehr nach jeder Aktualisierung gelöscht.
        # --Nur das aktuelle Ende der ständig länger werdenden %-Download-Zeile wird in die
        #   $dateiLOGStmpSTATUS geschrieben.
        # --Die fncStatusLogsAnzeigen muss nur die minimierte $dateiLOGStmpSTATUS auslesen und
        #   kann dann sofort die Statuszeilen anzeigen.
        
        
        if ( [[ "$intUTCsekunden" -gt "$intUTCreloadSTATUS" ]] )
        then
            nix=1
            if ( [[ "$flagSTATUSvorbereiten" == "true" ]] && [[ "$intUTCsekunden" -gt "$intUTCReloadStatusAnzeigen" ]] )
            then
                #fncDEBUGstart
                
                fncMOVEkreiselSlow010
                fncStatusLogsKopieren &
                pidStatusLogsKopieren=$!
                
                fncMOVEkreiselSlow010
                
                #fncMOVEkreiselSlow010 &
                fncStatusLogsAuslesen &
                pidStatusLogsAuslesen=$!
                
                #fncDEBUGstop
                #[[ -n $pidStatusLogsKopieren ]] && fncKILLpid "$pidStatusLogsKopieren" "-15" &
                #[[ -n $pidStatusLogsAuslesen ]] && fncKILLpid "$pidStatusLogsAuslesen" "-15" &
                flagSTATUSvorbereiten="false"
            fi
            if ( ( [[ "$intUTCsekunden" == *00 ]] || [[ "$intUTCsekunden" == *20 ]] || [[ "$intUTCsekunden" == *40 ]] || [[ "$intUTCsekunden" == *60 ]] || [[ "$intUTCsekunden" == *80 ]] ) && [[ "$intUTCsekunden" -gt "$intUTCReloadStatusAnzeigen" ]] )
            then
                # -Wird alle 20 Sekunden ausgeführt:
                # -DEBUG START
                intSSpopup=10
                txtDebugPassivePopup="20 Sekunden Ausführung!"
                #kdialog --passivepopup "--- INFO: $datei<br>--- INFO: `fncHHMMSS 'norm.mS3'`<br><br>$txtDebugPassivePopup<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                txtDebugPassivePopup=""
                # -DEBUG ENDE
                
                #intUTCreloadSTATUS="$intUTCsekunden"
                intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 5" | bc`
                intUTCReloadStatusAnzeigen=`echo -e "$intUTCsekunden + 15" | bc`
                
#                 if ( ( [[ -z $pidStatusLogsKopieren ]] ) || ( [[ -n $pidStatusLogsKopieren ]] && [[ `ps -p $pidStatusLogsKopieren | grep -i $pidStatusLogsKopieren` == "" ]] ) )
#                 then
#                     fncStatusLogsKopieren &
#                     pidStatusLogsKopieren=$!
#                     #fncStatusLogsAnzeigen
#                     flagSTATUSvorbereiten="true"
#                     flagStatusAnzeigeSek10="true"
#                 fi
                #fncStatusLogsKopieren &
                #pidStatusLogsKopieren=$!
                #fncStatusLogsAnzeigen
                flagSTATUSvorbereiten="true"
                flagStatusAnzeigeSek10="true"
            fi
            #if ( [[ "$intUTCsekunden" == *0 ]] && [[ "$flagStatusAnzeigeSek10" == "true" ]] )
            if ( [[ "$flagStatusAnzeigeSek10" == "true" ]] )
            then
                # -Wird alle 10/20 Sekunden ausgeführt:
                #fncMOVEkreiselSlow025
                #[[ ! -f $dateiLOGStmp ]] && fncStatusLogsKopieren && fncStatusLogsAnzeigen && break
                
                [[ ! -f $dateiLOGStmp ]] && fncMOVEkreiselSlow010 &
                [[ ! -f $dateiLOGStmp ]] && fncStatusLogsKopieren && pidStatusLogsKopieren=$! && fncStatusLogsAuslesen && pidStatusLogsAuslesen=$!
                
#                 fncMOVEkreiselSlow010 &
#                 fncStatusLogsKopieren
#                 pidStatusLogsKopieren=$!
#                 fncStatusLogsAuslesen
#                 pidStatusLogsAuslesen=$!
                
                
                #fncStatusLogsAnzeigen
                fncMOVEkreiselSlow010 &
                [[ -f $dateiLOGStmp ]] && fncStatusLogsAnzeigen
                # -Das flagStatusAnzeigeSek10 legt hier fest ob die Aktualisierung der Anzeige
                #  alle 10 Sekunden (true) oder alle 20 Sekunden (false) durchgeführt wird.
                flagStatusAnzeigeSek10="false"
                
                #[[ -n $pidStatusLogsKopieren ]] && fncKILLpid "$pidStatusLogsKopieren" "-15" & >/dev/null 2>&1
                #[[ -n $pidStatusLogsAuslesen ]] && fncKILLpid "$pidStatusLogsAuslesen" "-15" & >/dev/null 2>&1
                
                
                #fncMOVEkreiselSlow010 &
                #[[ -f $dateiLOGStmp ]] && rm $dateiLOGStmp
                #[[ -f $dateiLOGStmpSTATUS ]] && rm $dateiLOGStmpSTATUS
                
                
                # -Kopieren der Logs im Hintergrund funzt nicht, daher in Vordergrund verschoben:
                #fncStatusLogsKopieren &
                #fncStatusLogsKopieren
                #pidStatusLogsKopieren=$!
                #fncMOVEkreiselSlow010
            fi
        fi
        fncMOVEkreisel
        if ( [[ `ps -p $checkBEFEHLpid | grep -i $checkBEFEHLpid` == "" ]] )
        then
            # -Den checkBEFEHLreturn Status kontrollieren und ggf korrigieren!
            # --Skript wurde normal beendet: 0
            if ( [[ "$checkBEFEHLreturn" == "" ]] )
            then
                checkBEFEHLreturn="0"
            fi
            # -Das Quit-Flag-PS in TMP Datei schreiben:
            echo -e "flagQUITps" > "$dateiCACHEflagQUIT"
            eingabeTASTE="e"
            actionKONTROLLE="stop"
            #beep -l 60 -f 700 -D 200 --new -l 60 -f 700 -D 200 --new -l 60 -f 700 -D 200
            #flagERFOLGREICHabgeschlossen="true"
            break
        fi
        if ( [[ "$actionKONTROLLE" == "stop" ]] )
        then
            break
        fi
    done
}

function CHECKeingabeTASTE {
    # -Variablen innerhalb der Funktion übernehmen:
    #strFNC1=$1
    
    if ( [[ "$eingabeTASTE" != "e" ]] )
    then
        eingabeTASTE=""
        flagQUIT=""
        #stty raw echo
        #while ( [[ "$eingabeTASTE" != "q" ]] )
        #while ( [[ `dd bs=1 count=1 2>/dev/null` != "q" ]] && [[ `read "$dateiCACHEflagQUIT"` != "flagQUITps" ]] )
        
        #while ( [[ "$eingabeTASTE" != "q" ]] && [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` != flagQUITps* ]] )
        while ( [[ "$eingabeTASTE" != "q" ]] && [[ `cat $dateiCACHEflagQUIT 2>/dev/null` != flagQUITps* ]] )
        do
            #eingabeTASTE=`dd bs=1 count=1 2>/dev/null`
            #tput cup $cursorZEILEkreisel 39
            read -n 1 -t 0.05 -s eingabeTASTE
            #tput cub 1
            #echo -n " "
            #tput cub 1
            #beep -l 350 -f 392 -D 100 --new -l 250 -f 311.1 -D 100
#             if ( [[ "$eingabeTASTE" == "p" ]] )
#             then
#                 kdialog --passivepopup "-- PAUSE --<br><br>Das Skript wurde von Ihnen angehalten und kann<br>mittels \"p\" fortgesetzt werden." 20
#             fi
            
            
            # -FlagModusBefehlPlaylist: einzeln
            # -d: Datei abbrechen, nächste Datei bearbeiten
            if ( [[ "$eingabeTASTE" == "d" ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
            then
                [ -f $dateiCACHEflagQUIT ] && txtCACHEinternPID=`cat $dateiCACHEflagQUIT`
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'd'<br>Die aktuelle Datei ($txtCACHEinternPID) wird abgebrochen und dann die nächste Datei bearbeitet.<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'd' - Datei abbrechen, dann nächste Datei bearbeiten" >> $dateiLOGS &
                echo -e "flagNEXTdatei" > $dateiCACHEflagQUIT
                fncKILLpid "$txtCACHEinternPID"
            fi
            
            
            # -Wegen Kontrolle max Video Anzahl:
            if ( [[ `cat $dateiCACHEflagQUIT 2>/dev/null` == *flagNEXTurl* ]] )
            then
                typeset -i zzAuslesen=0
                while read auslesenDatei
                do
                    #echo -e "$auslesenDatei" > $dateiCACHEflagQUIT
                    # -Die Pid des Befehls der von fncBEFEHLaufrufen gestartet wurde:
                    (( $zzAuslesen == 0 )) && dateiCacheFlagQuitPidGesichert="$auslesenDatei"
                    (( $zzAuslesen == 1 )) && dateiCacheFlagQuitFlagGesichert="$auslesenDatei"
                    (( $zzAuslesen == 2 )) && dateiCacheFlagQuitPlsGesichert="$auslesenDatei"
                    zzAuslesen=zzAuslesen+1
                done < $dateiCACHEflagQUIT
                echo -e "$dateiCacheFlagQuitPidGesichert" > $dateiCACHEflagQUIT
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Die maximale Video-Anzahl ($intAnzahlVideosMax) wurde erreicht. Pls: $dateiCacheFlagQuitPlsGesichert" >> $dateiLOGS &
                flagNEXTurl="true"
                eingabeTASTE="u"
            fi
            
            
            # -FlagModusBefehlPlaylist: einzeln
            # -u: Datei fertigstellen, nächste URL bearbeiten
            if ( [[ "$eingabeTASTE" == "u" ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
            then
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'u'<br>Die aktuelle Datei wird fertig gestellt und danach die nächste URL bearbeitet.<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                echo -e "flagNEXTurl" > $dateiCACHEflagQUIT
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'u' - Datei fertigstellen, dann nächste URL bearbeiten" >> $dateiLOGS &
            fi
            
            
            # -FlagModusBefehlPlaylist: komplett
            # -u: Datei abbrechen, nächste URL bearbeiten
            if ( [[ "$eingabeTASTE" == "u" ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
            then
                [ -f $dateiCACHEflagQUIT ] && txtCACHEinternPID=`cat $dateiCACHEflagQUIT`
                [[ "$txtCACHEinternPID" == "flagNEXTurl" ]] && continue
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'u'<br>Die aktuelle Datei ($txtCACHEinternPID) wird abgebrochen und dann die nächste URL bearbeitet.<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'u' - Datei abbrechen, dann nächste URL bearbeiten" >> $dateiLOGS &
                echo -e "flagNEXTurl" > $dateiCACHEflagQUIT
                fncKILLpid "$txtCACHEinternPID"
                FlagModusBefehlKOMPLETTquit="Taste-U"
            fi
            
            
            if ( [[ "$eingabeTASTE" == "f" ]] )
            then
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'f'<br>Die aktuelle Datei/URL wird fertig gestellt und danach das Skript beendet!<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && echo -e $txtCACHEplsINFOS"flagQUITpsTasteF" > $dateiCACHEplsINFOS && flagQUITpsTasteF="true"
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'f' - Datei/URL fertigstellen, dann Skript beenden" >> $dateiLOGS &
            fi
        done
        #stty -raw echo
        [ -f $dateiCACHEflagQUIT ] && txtCACHEstatus=`cat $dateiCACHEflagQUIT`
        #if ( [[ "$eingabeTASTE" == "q" ]] && [[ `cat $dateiCACHEflagQUIT` != "flagQUITps" ]] )
        if ( [[ "$eingabeTASTE" == "q" ]] && [[ "$txtCACHEstatus" != flagQUITps* ]] )
        then
            # -Q && NICHT flagQUITps* = Beendet durch: nur die Taste q, trueQ
            [[ "$flagQUIT" != *trueQ* ]] && flagQUIT=$flagQUIT"trueQ"
        fi
        #if ( [[ "$eingabeTASTE" != "q" ]] && [[ `cat $dateiCACHEflagQUIT` == "flagQUITps" ]] )
        if ( [[ "$eingabeTASTE" != "q" ]] && [[ "$txtCACHEstatus" == flagQUITps* ]] )
        then
            # -NICHT Q && flagQUITps* = Beendet durch: nur durch Prozesskontrolle ps
            [[ "$flagQUIT" != *truePS* ]] && flagQUIT=$flagQUIT"truePS"
        fi
        #if ( [[ "$eingabeTASTE" == "q" ]] && [[ `cat $dateiCACHEflagQUIT` == "flagQUITps" ]] )
        if ( [[ "$eingabeTASTE" == "q" ]] && [[ "$txtCACHEstatus" == flagQUITps* ]] )
        then
            # -Q && flagQUITps* = Beendet durch: Taste q und Prozesskontrolle ps
            [[ "$flagQUIT" != *trueQ-PS* ]] && flagQUIT=$flagQUIT"trueQ-PS"
        fi
        
        # -Beenden mittels Taste f: Weitergeleitet durch $dateiCACHEflagQUIT
        [[ "$txtCACHEstatus" == "flagQUITpsTasteF" ]] && [[ "$flagQUIT" != *tasteF-status-0* ]] && flagQUIT=$flagQUIT"tasteF-status-0"
        # -Beenden mittels Taste f: Weitergeleitet durch $flagQUITpsTasteF
        [[ "$flagQUITpsTasteF" == "true" ]] && [[ "$flagQUIT" != *tasteF-status-0* ]] && flagQUIT=$flagQUIT"tasteF-status-0"
    fi
    # -zur Aktualisierung des Status
    #fncStatusLogsAnzeigen
}

function CHECKeingabeTASTEeinmal {
    if ( [[ "$eingabeTASTE" != "e" ]] )
    then
        eingabeTASTE=""
        stty raw echo
        eingabeTASTE=`dd bs=1 count=1 2>/dev/null`
        # if ( [[ "$eingabeTASTE" != "q" ]] )
        # then
        #     tput cub 1
        #     echo -n "   "
        #     tput cub 3
        # fi
        stty -raw echo
    fi
}












# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Status aus Logdatei anzeigen ++++++++++++++++++++++++++++++++++++
echo -e "|----------------------------------------\n|- Status der Programmausführung:"
txtZEIT="["`date '+%T'`"]"
txtSTATUSausgabe="Warte auf Daten..."
txtPLAYLIST=""
echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabe${fmtRESET}"
echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabe${fmtRESET}"
echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabe${fmtRESET}"
if ( [[ "$txtPLAYLIST" != "" ]] )
then
    #echo -e "|- Playlist Infos: $txtPLAYLIST\n|-"
    echo -e "|- Bearbeitet wird: $txtPLAYLIST\n|----------------------------------------"
else
    echo -e "|- Aktuelle Datei wird ermittelt:\n|----------------------------------------"
fi
#echo -e "|----------------------------------------"

# function fncCURSORposition {
#     # -Zum Prüfen ob das Gesamtskript noch läuft: flagQUITps existiert nicht in  $dateiCACHEflagQUIT
#     # -positionieren: tput cup Zeile Spalte
#     typeset -i cursorZEILE=0
#     typeset -i cursorZEILEstatus=0
#     function getCPos { 
#         local v=() t=$(stty -g)
#         stty -echo
#         printf "\033[6n"
#         IFS='[;' read -ra v -d R
#         stty $t
#         CPos=(${v[@]:1})
#     }
#     getCPos
#     cursorZEILE=$CPos
#     zeileDELETE=`tput dl1`
#     zeileINSERT=`tput il1`
#     #cursorZEILEstatus=$cursorZEILE-2
#     cursorZEILEstatus=$cursorZEILE-4
#     while ( [[ "$actionKONTROLLE" != "stop" ]] )
#     do
#         sleep 10
#         while read txtSTATUS
#         do
#             txtSTATUSausgabe=$txtSTATUS
#         done < $dateiLOGS
#         tput cup $cursorZEILEstatus 0
#         echo $zeileDELETE
#         tput cup $cursorZEILEstatus 0
#         echo -e "|- ${fmtFETT}\"$txtSTATUSausgabe\"${fmtRESET}"
#     done
# }


# -positionieren: tput cup Zeile Spalte
typeset -i cursorZEILE=0
typeset -i intANZAHLstatusZEILEN=0
typeset -i cursorZEILEstatus=0
typeset -i cursorZEILEkreisel=0

getCPos
cursorZEILE=$CPos
zeileDELETE=`tput dl1`
zeileINSERT=`tput il1`
intANZAHLstatusZEILEN=3
#cursorZEILEstatus=cursorZEILE-6
cursorZEILEstatus=cursorZEILE-6
cursorZEILEkreisel=cursorZEILE+3



# -Die txtSTATUS und txtPLAYLIST Variablen definieren, damit diese global sind!
txtSTATUS=""
txtSTATUSausgabe=""
txtSTATUSausgabeX0x=""
txtSTATUSausgabeX1x=""
txtSTATUSausgabeX2x=""
txtSTATUSausgabeX3x=""
txtSTATUSausgabeX4x=""
txtSTATUSausgabeX5x=""
txtPLAYLIST=""
txtURLanzeige="URL: -/-"
txtVIDPLSbearbeitungAKTUELL=""
txtPLAYLISTaktuell=""
txtPLAYLISTende=""
txtPLAYLISTvideo=""
txtTRENNERplaylist=""

#typeset -i txtURLanzeigeAKTUELL=0
#typeset -i txtURLanzeigeGESAMT=0
txtURLanzeigeAKTUELL=0
txtURLanzeigeGESAMT=0



function fncStatusLogsKopieren {
#     ############################################################
#     typeset -i intUTCSekDifferenzStart=0
#     typeset -i intUTCSekDifferenzEnde=0
#     typeset -i intUTCSekDifferenz=0
#     intUTCSekDifferenzStart=`date '+%s'`
#     kdialog --title "fncStatusLogsKopieren - START" --passivepopup "`fncHHMMSS 'norm.mS2'` -:- PID: $actionCPlogsPID<br><br>UTC Start: $intUTCSekDifferenzStart<br>UTC Ende: $intUTCSekDifferenzEnde<br>UTC Differenz: $intUTCSekDifferenz" 10 &
#     ############################################################
    
#     # -Die temporäre Logs Datei löschen:
#     if ( [[ -f "$dateiLOGStmp" ]] )
#     then
#         rm "$dateiLOGStmp"
#     fi
#     
#     # -Die temporäre Logs Status Datei löschen:
#     if ( [[ -f "$dateiLOGStmpSTATUS" ]] )
#     then
#         rm "$dateiLOGStmpSTATUS"
#     fi
    
    
    #cp $dateiLOGS $dateiLOGStmp
    #cp $dateiLOGS $dateiLOGStmp &
    tail -n 6 $dateiLOGS > $dateiLOGStmp &
    # -Wenn tail im Vordergrund ausgeführt wird verweist $! auf die fncBEFEHLaufrufen...
    actionCPlogsPID=$!
    
    #kdialog --title "$datei.Info `fncHHMMSS 'norm.mS2'`" --passivepopup "fncStatusLogsKopieren -:- CP PID: #actionCPlogsPID<br><br>'cp $dateiLOGS $dateiLOGStmp'" 10 &
    #fncCheckZugriffeDatei "$dateiLOGStmp" "tail"
    while ( [[ `ps -p $actionCPlogsPID | grep -i $actionCPlogsPID` != "" ]] )
    do
        #fncMOVEkreiselSlow005
        sleep 0.4
        fncKILLpid "$actionCPlogsPID" "-9"
    done
    
    echo -e "" >> $dateiLOGStmp
    echo -e "---EOF---" >> $dateiLOGStmp
    txtZEIT="["`date '+%T'`"]"
    txtPLAYLIST=""
    txtPLAYLISTvideo=""
    txtPLAYLISTaktuell=""
    txtPLAYLISTende=""
    typeset -i x=0
    
    # -Die fncStatusLogsAuslesen wertet die Logs aus und erstellt die reine
    #  Status Datei $dateiLOGStmpSTATUS.
    # -Damit Skript nicht auf die Verarbeitung warten muss, geschieht dies im Hintergrund
    #  und wird mittels while überwacht.
    #fncStatusLogsAuslesen &
    #fncStatusLogsAuslesen
    #pidStatusLogsAuslesen=$!
    #fncMOVEkreiselSlow005
    #while ( [[ `ps -p $pidStatusLogsAuslesen | grep -i $pidStatusLogsAuslesen` != "" ]] )
#     while ( [[ `ps -p $pidStatusLogsAuslesen -o pid=` != "" ]] )
#     do
#         #fncMOVEkreiselSlow025
#         sleep 0.02
#     done
    
#     # -Die Status Anzeige aktualisieren:
#     fncStatusLogsAnzeigen
    
#     ############################################################
#     intUTCSekDifferenzEnde=`date '+%s'`
#     intUTCSekDifferenz=intUTCSekDifferenzEnde-intUTCSekDifferenzStart
#     [ $intUTCSekDifferenz -lt 1 ] && intUTCSekDifferenz=1
#     kdialog --title "fncStatusLogsKopieren - ENDE" --passivepopup "`fncHHMMSS 'norm.mS2'` -:- PID: $actionCPlogsPID<br><br>UTC Start: $intUTCSekDifferenzStart<br>UTC Ende: $intUTCSekDifferenzEnde<br>UTC Differenz: $intUTCSekDifferenz" 10 &
#     ############################################################
    actionCPlogsPID=""
}


function fncStatusLogsAuslesen {
#     ############################################################
#     typeset -i intUTCSekDifferenzStart=0
#     typeset -i intUTCSekDifferenzEnde=0
#     typeset -i intUTCSekDifferenz=0
#     intUTCSekDifferenzStart=`date '+%s'`
#     kdialog --title "fncStatusLogsAuslesen - START" --passivepopup "`fncHHMMSS 'norm.mS2'` -:- PID: $actionCPlogsPID<br><br>UTC Start: $intUTCSekDifferenzStart<br>UTC Ende: $intUTCSekDifferenzEnde<br>UTC Differenz: $intUTCSekDifferenz" 10 &
#     ############################################################
    
    fncCheckZugriffeDatei "$dateiLOGStmp" "tail"
    fncCheckZugriffeDatei "$dateiLOGStmp" "echo"
    txtPLAYLISTende=""
    txtVIDPLSbearbeitungAKTUELL=""
    flagPLAYLIST="false"
    # -Die richtige oder die temporäre Logdatei wird zeilenweise eingelesen und verarbeitet:
    
    # ??????????
    #https://www.youtube.com/playlist?list=PLC7bEKm4tFmNK94pZvdR6mfmpqxC6LGvUdo
    # ???????????????
    
    # -Wegen Kontrolle max Video Anzahl:
    # --Timestamp für Reload muss außerhalb des While gesetzt werden
    typeset -i intTimestampCheckReload=0
    while read txtSTATUS
    do
        # -Wenn keine Playlist wird am Ende $txtVIDPLSbearbeitungAKTUELL hinzugefügt:
        [[ "$txtSTATUS" == *\ playlist* ]] && flagPLAYLIST="true"
        
        # -Text für Video bzw Playlist Infos auslesen:
        # -Bsp: [lxDOWNLOAD] 11:44:55 URL 1 von 6
        #[[ "$txtSTATUS" == \[$datei\]*URL*von* ]] && txtURLanzeigeKOMPLETT=${txtSTATUS//*URL /} && txtURLanzeigeAKTUELL=${txtURLanzeigeKOMPLETT// von*/} && txtURLanzeigeGESAMT=${txtURLanzeigeKOMPLETT//*von /} && txtURLanzeige="URL: $txtURLanzeigeAKTUELL/$txtURLanzeigeGESAMT"
        [[ "$txtSTATUS" == \[$datei\]*URL*von* ]] && txtURLanzeigeKOMPLETT=${txtSTATUS//*URL /} && txtURLanzeigeAKTUELL=${txtURLanzeigeKOMPLETT// von*/} && txtURLanzeigeGESAMT=${txtURLanzeigeKOMPLETT//*von /} && txtURLanzeigeGESAMT=${txtURLanzeigeGESAMT// \-*/} && txtURLanzeige="URL: $txtURLanzeigeAKTUELL/$txtURLanzeigeGESAMT" && strDownloadUvzAktuell=""
        
        
        # -Bsp: [download] Destination: Folge_10_-_Liebe_und_Monster_S02_E10-89087280.mp4
        # -Bsp: [download] Destination: playlist_7844175181/22_Stanton-Warriors_UWS-Brighton.mp4
        # -Bsp: [download] Stanton Warriors UWS Brighton has already been recorded in archive
        #
        # -NEU: Wegen Wechsel von youtube-dl zu yt-dlp!
        # -Beispiele:
        #  [Youtube] 'Video ID': 'Video Titel' has already been recorded in the archive
        #  [download] 'Video ID': 'Video Titel' has already been recorded in the archive
        # -UND:
        #  [download] 'Video Titel' has already been downloaded
        #
        
        txtVIDPLSbearbeitungAKTUELL=""
        [[ "$txtSTATUS" == \[download\]*Destination:* ]] && txtVIDPLSbearbeitungAKTUELL=${txtSTATUS//*Destination: /} && strDownloadUvzAktuell="${txtVIDPLSbearbeitungAKTUELL//\/*/}"
#         # *****************************************************************************************
#         # ***** START Live Kontrolle max Video Anzahl *********************************************
#         # *****************************************************************************************
#         #
#         if ( [[ "$txtVIDPLSbearbeitungAKTUELL" != "" ]] )
#         then
#             #break;
#             [[ "$arbeitsVERZEICHNIS" == "" ]] && arbeitsVERZEICHNIS="`pwd`"
#             #strDownloadUvzAktuell="${txtVIDPLSbearbeitungAKTUELL//\/*/}"
#             [[ ! -d "$strDownloadUvzAktuell" ]] && strDownloadUvzAktuell="$arbeitsVERZEICHNIS"
#             #typeset -i intAnzahlVideosMax=50
#             typeset -i intAnzahlVideosLive=0
#             typeset -i intTimestamp=0
#             intAnzahlVideosLive=$(find $strDownloadUvzAktuell -maxdepth 1 -type f | wc -l)
#             intTimestamp=`date '+%s'`
#             #(( intTimestamp > intTimestampCheckReload )) && intTimestampCheckReload=intTimestamp+120 && kdialog --title "#.video" --passivepopup "Video-Anzahl:<br><br>$intAnzahlVideosLive von $intAnzahlVideosMax<br>Verzeichnis: $strDownloadUvzAktuell" 10 &
#             (( intTimestamp > intTimestampCheckReload )) && intTimestampCheckReload=intTimestamp+120
#             
#             #[[ "$txtTMPstatus" == URL:* ]] && intAnzahlVideosLive=${txtTMPstatus//*Video: /} && intAnzahlVideosLive=${intAnzahlVideosLive//\/*/}
#             #[[ "$intAnzahlVideosLive" != URL:* ]] && kdialog --title "#.video" --passivepopup "Video Anzahl<br><br>$intAnzahlVideosLive<br>" 10 &
#             (( $intAnzahlVideosLive > $intAnzahlVideosMax )) && [[ "$flagNEXTurl" != "true" ]] && echo -e "flagNEXTurl" >> $dateiCACHEflagQUIT && kdialog --title "max.video" --passivepopup "Video-Anzahl:<br> Maximum erreicht!<br>$intAnzahlVideosLive von $intAnzahlVideosMax<br>Verzeichnis: $strDownloadUvzAktuell" 10 &
#         fi
#         #
#         # *****************************************************************************************
#         # ***** ENDE Live Kontrolle max Video Anzahl **********************************************
#         # *****************************************************************************************
        
        
        
        #[[ "$txtSTATUS" == \[download\]*has\ already\ been\ recorded\ in\ archive ]] && txtVIDPLSbearbeitungAKTUELL=${txtSTATUS//*download\] /} && txtVIDPLSbearbeitungAKTUELL=${txtVIDPLSbearbeitungAKTUELL// has already been recorded in archive/}
        #[[ "$txtSTATUS" == \[download\]*has\ already\ been\ recorded\ in\ archive ]] && txtVIDPLSbearbeitungAKTUELLanfang=${txtSTATUS//*download\] /} && txtVIDPLSbearbeitungAKTUELL=${txtVIDPLSbearbeitungAKTUELLanfang// has already been recorded in archive/ (Bereits heruntergeladen.)}
        
        # -Neu wegen yt-dlp:
        [[ "$txtSTATUS" == \[*\]*:\ has\ already\ been\ recorded\ in\ the\ archive ]] && txtVIDPLSbearbeitungAKTUELLanfang=${txtSTATUS//*\] /} && txtVIDPLSbearbeitungAKTUELL=${txtVIDPLSbearbeitungAKTUELLanfang// has already been recorded in the archive/ (Bereits heruntergeladen.)}
        [[ "$txtSTATUS" == \[*\]*\ has\ already\ been\ downloaded ]] && txtVIDPLSbearbeitungAKTUELLanfang=${txtSTATUS//*\] /} && txtVIDPLSbearbeitungAKTUELL=${txtVIDPLSbearbeitungAKTUELLanfang// has already been downloaded/ (Bereits heruntergeladen.)}
        
        
        # -Neu wegen yt-dlp:
        # -Bsp yt-dlp: [download] Downloading item 42 of 70
        #
        # -FlagModusBefehlPlaylist: einzeln
        #if ( [[ "$txtSTATUS" == *\]\ Downloading\ video*of* ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
        if ( [[ "$txtSTATUS" == *\]\ Downloading*of* ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
        then
            #txtPLAYLISTvideoLOGS=${txtSTATUS//*video /}
            txtPLAYLISTvideoLOGS=${txtSTATUS//*item /}
            txtPLAYLISTvideoLOGS=${txtPLAYLISTvideoLOGS//of/von}
            txtPLAYLISTvideoLOGSitem=${txtPLAYLISTvideoLOGS// von*/}
            txtPLAYLISTvideoLOGS=" (Video $txtPLAYLISTvideoLOGS)"
            
            [ -f $dateiCACHEplsINFOS ] && txtPLAYLISTzaehlerGESAMT=`cat $dateiCACHEplsINFOS`
            [ -n "$txtPLAYLISTzaehlerGESAMT" ] && txtPLAYLISTzaehlerGESAMTsicherung="$txtPLAYLISTzaehlerGESAMT" && txtPLAYLISTbeenden=""
            [ -z "$txtPLAYLISTzaehlerGESAMT" ] && [ -n "$txtPLAYLISTzaehlerGESAMTsicherung" ] && txtPLAYLISTzaehlerGESAMT="$txtPLAYLISTzaehlerGESAMTsicherung" && txtPLAYLISTbeenden=" Beenden (f) eingeleitet!"
            txtPLAYLISTvideo=" (Video $txtPLAYLISTzaehlerGESAMT)$txtPLAYLISTbeenden"
            #txtPLAYLIST=" $txtPLAYLISTaktuell$txtPLAYLISTvideo$txtTRENNERplaylist$txtPLAYLIST"
            #txtVIDEOstatus=" $txtPLAYLISTzaehlerGESAMT"
        fi
        # -FlagModusBefehlPlaylist: komplett
        #if ( [[ "$txtSTATUS" == *\]\ Downloading\ video*of* ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
        if ( [[ "$txtSTATUS" == *\]\ Downloading*of* ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
        then
            #txtPLAYLISTvideoLOGS=${txtSTATUS//*video /}
            txtPLAYLISTvideoLOGS=${txtSTATUS//*item /}
            txtPLAYLISTvideoLOGS=${txtPLAYLISTvideoLOGS//of/von}
            txtPLAYLISTvideoLOGSitem=${txtPLAYLISTvideoLOGS// von*/}
            txtPLAYLISTvideoLOGS=" (Video $txtPLAYLISTvideoLOGS)"
            
            txtPLAYLISTvideo="$txtPLAYLISTvideoLOGS""$txtPLAYLISTbeenden"
            #txtPLAYLIST=" $txtPLAYLISTaktuell$txtPLAYLISTvideo$txtTRENNERplaylist$txtPLAYLIST"
            #txtVIDEOstatus=" $txtPLAYLISTzaehlerGESAMT"
        fi
        
        
#         # -Status auslesen: Playliste (aktuelle, fertige)
#         #  [download] Downloading playlist: abc002
#         #  [download] Finished downloading playlist: abc001
#         if ( [[ "$txtSTATUS" == *\]\ Downloading\ playlist:* ]] )
#         then
#             txtPLAYLISTaktuellKONTROLLE=${txtSTATUS//*playlist: /}
#             if ( [[ "$txtPLAYLISTende" != "" ]] )
#             then
#                 txtTRENNERaufzaehlung=", "
#             else
#                 txtTRENNERaufzaehlung=""
#             fi
#             if ( [[ "$txtPLAYLISTaktuell" != "" ]] && [[ "$txtPLAYLISTaktuell" != "$txtPLAYLISTaktuellKONTROLLE" ]] )
#             then
#                 txtPLAYLISTende="$txtPLAYLISTaktuell$txtTRENNERaufzaehlung$txtPLAYLISTende"
#             fi
#             if ( [[ "$txtPLAYLISTende" != "" ]] )
#             then
#                 txtTRENNERplaylist="- Fertig: "
#             else
#                 txtTRENNERplaylist=""
#             fi
#             txtPLAYLISTaktuell=${txtSTATUS//*playlist: /}
#             #txtPLAYLISTende="$txtTRENNERplaylist$txtPLAYLISTaktuell"
#         #else
#             #txtPLAYLISTaktuell="$txtVIDEOstatus"
#         fi
        
        
        # -Status auslesen: Playliste (aktuelle, fertige)
        #  [download] Downloading playlist: abc002
        #  [download] Finished downloading playlist: abc001
        #
        # -Aktuelle Playliste:
        if ( [[ "$txtSTATUS" == *\]\ Downloading\ playlist:* ]] )
        then
            txtPLAYLISTaktuell=${txtSTATUS//*playlist: /}
            txtPLAYLISTaktuellKONTROLLE=$txtPLAYLISTaktuell
        fi
        if ( [[ "$txtPLAYLISTende" == "" ]] )
        then
            txtTRENNERplaylist=""
            txtTRENNERaufzaehlung=""
        fi
        # -Fertige Playliste:
        # -Beispiel für Zusammenbau: 001 --- 001, 004 --- 001, 002, 003
        # -Beispiel für Zusammenbau: 001 --- 001, 004 --- 003, 002, 001
        if ( [[ "$txtSTATUS" == *\]\ Finished\ downloading\ playlist:* ]] )
        then
            txtPLAYLISTfertig=${txtSTATUS//*playlist: /}
            #txtPLAYLISTende="$txtPLAYLISTende""$txtTRENNERaufzaehlung""$txtPLAYLISTfertig"
            txtPLAYLISTende="$txtPLAYLISTfertig""$txtTRENNERaufzaehlung""$txtPLAYLISTende"
            txtTRENNERplaylist="Fertig: "
            txtTRENNERaufzaehlung=", "
        fi
        
#         if ( [[ "$txtPLAYLISTaktuell" != "" ]] && [[ "$txtPLAYLISTaktuell" != "$txtPLAYLISTaktuellKONTROLLE" ]] )
#         then
#             txtPLAYLISTende="$txtPLAYLISTaktuell$txtTRENNERaufzaehlung$txtPLAYLISTende"
#         fi
#         if ( [[ "$txtPLAYLISTende" != "" ]] )
#         then
#             txtTRENNERplaylist="Fertig: "
#         else
#             txtTRENNERplaylist=""
#         fi
#         txtPLAYLISTaktuell=${txtSTATUS//*playlist: /}
#         #txtPLAYLISTende="$txtTRENNERplaylist$txtPLAYLISTaktuell"
#         #else
#         #txtPLAYLISTaktuell="$txtVIDEOstatus"
        
        
        # -Statuszeile kürzen, damit kein Umbruch erfolgt und Status in eine Zeile passt!
        #  maximale Anzahl Zeichen: intLayoutMaxSpalten-intAnzahlZeichenRandUhrzeit
        typeset -i intAnzahlZeichenRandUhrzeit=`fncANZAHLzeichen "|- [09:31:37] "`
        intSTATUSzeichenMAX=intLayoutMaxSpalten-intAnzahlZeichenRandUhrzeit
        
        typeset -i intSTATUSzeichenKONTROLLE=0
        # -da Position mit null beginnt muss der Kontrollwert intSTATUSzeichenKONTROLLE nicht
        #  um eins erhöht werden
        # -wenn nach der maximalen Anzahl Zeichen der String noch weitergeht wird er gekürzt:
        intSTATUSzeichenKONTROLLE=$intSTATUSzeichenMAX
        #intSTATUSzeichen=`echo $txtSTATUS | awk '{print length($txtSTATUS)}'`
        intSTATUSzeichen=${#txtSTATUS}
        #strSTATUSzeichenKONTROLLE=${txtSTATUS:$intSTATUSzeichenKONTROLLE:1}
        #if ( [[ "$strSTATUSzeichenKONTROLLE" != "" ]] )
        
        if ( [[ "$intSTATUSzeichen" -gt $intSTATUSzeichenMAX ]] && [[ "$txtSTATUS" != *%\ of* ]] )
        then
            # -KEINE %-Download-Zeile:
            # -Ausschneiden: Zeichen von 0 bis $intSTATUSzeichenMAX
            txtSTATUS=${txtSTATUS:0:$intSTATUSzeichenMAX}
        fi
#         if ( [[ "$intSTATUSzeichen" -gt $intSTATUSzeichenMAX ]] && [[ "$txtSTATUS" == *%\ of* ]] )
#         then
#             # -%-Download-Zeile:
#             # -Ausschneiden: Die letzten $intSTATUSzeichenMAX Zeichen der Zeile:
#             txtSTATUS=${txtSTATUS: -$intSTATUSzeichenMAX}
#         fi
    done < $dateiLOGS
    actionReadLogsPID=$!
    #fncKILLpid "$actionReadLogsPID" "-9" &
    
    # *****************************************************************************************
    # ***** START Live Kontrolle max Video Anzahl *********************************************
    # *****************************************************************************************
    #
    if ( [[ "$strDownloadUvzAktuell" != "" ]] )
    then
        #break;
        [[ "$arbeitsVERZEICHNIS" == "" ]] && arbeitsVERZEICHNIS="`pwd`"
        #strDownloadUvzAktuell="${txtVIDPLSbearbeitungAKTUELL//\/*/}"
        [[ ! -d "$strDownloadUvzAktuell" ]] && strDownloadUvzAktuell="$arbeitsVERZEICHNIS"
        #typeset -i intAnzahlVideosMax=50
        typeset -i intAnzahlVideosLive=0
        typeset -i intTimestamp=0
        intAnzahlVideosLive=$(find $strDownloadUvzAktuell -maxdepth 1 -type f | wc -l)
        intTimestamp=`date '+%s'`
        #(( intTimestamp > intTimestampCheckReload )) && intTimestampCheckReload=intTimestamp+120 && kdialog --title "#.video" --passivepopup "Video-Anzahl:<br><br>$intAnzahlVideosLive von $intAnzahlVideosMax<br>Verzeichnis: $strDownloadUvzAktuell" 10 &
        (( intTimestamp > intTimestampCheckReload )) && intTimestampCheckReload=intTimestamp+120
        
        (( $intAnzahlVideosLive > $intAnzahlVideosMax )) && [[ "$flagNEXTurl" != "true" ]] && echo -e "flagNEXTurl" >> $dateiCACHEflagQUIT && echo -e "$strDownloadUvzAktuell" >> $dateiCACHEflagQUIT && kdialog --title "max.video" --passivepopup "Video-Anzahl:<br> Maximum erreicht!<br>$intAnzahlVideosLive von $intAnzahlVideosMax<br>Verzeichnis: $strDownloadUvzAktuell" 10 &
    fi
    #
    # *****************************************************************************************
    # ***** ENDE Live Kontrolle max Video Anzahl **********************************************
    # *****************************************************************************************
    
    
    
    # -Die richtige oder die temporäre Logdatei wird zeilenweise eingelesen und verarbeitet:
    flagStatusDownloadZeileGefunden="false"
    while read txtSTATUS
    do
        #[[ "$txtSTATUS" != "" ]] && [[ `fncANZAHLzeichen $txtSTATUS` -gt $intSTATUSzeichenMAX ]] && txtSTATUS=${txtSTATUS:0:$intSTATUSzeichenMAX}
        #txtSTATUS=${txtSTATUS:0:$intSTATUSzeichenMAX}
        
        # -Ausschneiden: % Download-Zeile: Die letzten $intSTATUSzeichenMAX Zeichen der Zeile
        if ( [[ "$txtSTATUS" == *%\ of* ]] )
        then
            [[ "${#txtSTATUS}" -gt "$intSTATUSzeichenMAX" ]] && txtSTATUS=${txtSTATUS: -$intSTATUSzeichenMAX}
        else
            # -Ausschneiden: Zeichen von 0 bis $intSTATUSzeichenMAX
            txtSTATUS=${txtSTATUS:0:$intSTATUSzeichenMAX}
        fi
        
        txtSTATUSausgabeX5x="$txtSTATUSausgabeX4x"
        txtSTATUSausgabeX4x="$txtSTATUSausgabeX3x"
        txtSTATUSausgabeX3x="$txtSTATUSausgabeX2x"
        txtSTATUSausgabeX2x="$txtSTATUSausgabeX1x"
        txtSTATUSausgabeX1x="$txtSTATUSausgabeX0x"
        txtSTATUSausgabeX0x="$txtSTATUS"
        
        # -Alte Variable wird teilweise noch abgefragt:
        txtSTATUSausgabe="$txtSTATUS"
        if ( [[ "$flagStatusDownloadZeileGefunden" == "false" ]] )
        then
            #[[ "$txtSTATUSausgabeX0x" == \[download\]* ]] && [[ "$txtSTATUSausgabeX1x" == \[download\]*Destination:* ]] && txtStatusDownloadDestination=$txtSTATUSausgabeX1x && txtStatusDownloadProzente=$txtSTATUSausgabeX0x && break
            [[ "$txtSTATUSausgabeX0x" == \[download\]* ]] && [[ "$txtSTATUSausgabeX1x" == \[download\]*Destination:* ]] && txtStatusDownloadDestination=$txtSTATUSausgabeX1x && txtStatusDownloadProzente=$txtSTATUSausgabeX0x && flagStatusDownloadZeileGefunden="true"
        fi
        
    done < $dateiLOGStmp
    
    actionReadLogsPID=$!
    #fncKILLpid "$actionReadLogsPID" "-9" &
    
    
    
    [[ "$flagPLAYLIST" != "true" ]] && [ -n "$txtVIDPLSbearbeitungAKTUELL" ] && txtURLanzeige="$txtURLanzeige - $txtVIDPLSbearbeitungAKTUELL"
    #echo -e "--- DEBUG flagPLAYLIST: $flagPLAYLIST - txtVIDPLSbearbeitungAKTUELL: $txtVIDPLSbearbeitungAKTUELL"
    
    #[[ "$txtPLAYLISTaktuell" != "" ]] && [[ "$txtPLAYLISTaktuell" != -* ]] && txtPLAYLISTaktuell="- $txtPLAYLISTaktuell"
    
#     echo $txtSTATUS > $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabe >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX0x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX1x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX2x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX3x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX4x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX5x >> $dateiLOGStmpSTATUS
#     echo $txtPLAYLIST >> $dateiLOGStmpSTATUS
#     echo -e "$txtURLanzeige $txtPLAYLISTaktuell" >> $dateiLOGStmpSTATUS
#     echo $txtPLAYLISTende >> $dateiLOGStmpSTATUS
#     echo $txtPLAYLISTvideo >> $dateiLOGStmpSTATUS
#     echo -e "$txtTRENNERplaylist" >> $dateiLOGStmpSTATUS
    
    
    
    # -YoutubeDL setzt in der %-Download-Zeile keine Zeilenumbrüche. Damit $dateiLOGStmpSTATUS nicht
    #  unnötig groß wird, wird die aktuelle %-Download-Zeile $txtSTATUSausgabeX1x beschnitten!
    if ( [[ ${#txtSTATUSausgabeX1x} -gt $intSTATUSzeichenMAX ]] && [[ "$txtSTATUSausgabeX1x" == *%\ of* ]] )
    then
        # -%-Download-Zeile Ausschneiden: Nur die letzten $intSTATUSzeichenMAX Zeichen
        #  der Zeile werden gebraucht:
        txtSTATUSausgabeX1x=${txtSTATUSausgabeX1x: -$intSTATUSzeichenMAX}
    fi
    
    fncCheckZugriffeDatei "$dateiLOGStmpSTATUS" "cp"
    
    #tail --lines 6 "$dateiLOGStmp" >> $dateiLOGStmpSTATUS
#     typeset -i zzSts=0
#     while read txtStatusNeu
#     do
#         nix=0
#         arrStatusAusgabeNeu[$zzSts]="$txtStatusNeu"
#         zzSts=zzSts+1
#     done < `tail --lines 6 "$dateiLOGStmp"`
#     
#         txtSTATUSausgabeX0x=${arrStatusAusgabeNeu[0]}
#         txtSTATUSausgabeX1x=${arrStatusAusgabeNeu[1]}
#         txtSTATUSausgabeX2x=${arrStatusAusgabeNeu[2]}
#         txtSTATUSausgabeX3x=${arrStatusAusgabeNeu[3]}
#         txtSTATUSausgabeX4x=${arrStatusAusgabeNeu[4]}
#         txtSTATUSausgabeX5x=${arrStatusAusgabeNeu[5]}
    #echo -e "$txtSTATUSausgabe"\\n"$txtSTATUSausgabeX0x"\\n"$txtSTATUSausgabeX1x"\\n"$txtSTATUSausgabeX2x"\\n"$txtSTATUSausgabeX3x"\\n"$txtSTATUSausgabeX4x"\\n"$txtSTATUSausgabeX5x"\\n"$txtPLAYLIST"\\n"$txtURLanzeige $txtPLAYLISTaktuell"\\n"$txtPLAYLISTende"\\n"$txtPLAYLISTvideo"\\n"$txtTRENNERplaylist" >> $dateiLOGStmpSTATUS
    #echo -e "$txtSTATUSausgabeX5x"\\n"$txtPLAYLIST"\\n"$txtURLanzeige $txtPLAYLISTaktuell"\\n"$txtPLAYLISTende"\\n"$txtPLAYLISTvideo"\\n"$txtTRENNERplaylist" >> $dateiLOGStmpSTATUS

    
    # -Die temporäre Logs Status Datei löschen:
    #[[ -f "$dateiLOGStmpSTATUS" ]] && rm "$dateiLOGStmpSTATUS"
    #[[ -f "$dateiLOGStmpSTATUS" ]] && echo -e "42" > $dateiLOGStmpSTATUS

    
    echo -e "$txtSTATUS" > $dateiLOGStmpSTATUS
    #echo -e "$txtSTATUSausgabe" >> $dateiLOGStmpSTATUS
    
    echo -e "$txtSTATUSausgabe"\\n"$txtSTATUSausgabeX0x"\\n"$txtSTATUSausgabeX1x"\\n"$txtSTATUSausgabeX2x"\\n"$txtSTATUSausgabeX3x"\\n"$txtSTATUSausgabeX4x"\\n"$txtSTATUSausgabeX5x"\\n"$txtURLanzeige"\\n"$txtPLAYLIST"\\n"$txtPLAYLISTaktuell"\\n"$txtPLAYLISTende"\\n"$txtPLAYLISTvideo"\\n"$txtTRENNERplaylist" >> $dateiLOGStmpSTATUS
    #echo -e "`date '+%T'`" >> $dateiLOGStmpSTATUS
    
    
    # DEBUGINFO
    #kdialog --title "fncStatusLogsAuslesen" --passivepopup "`fncHHMMSS 'norm.mS2'` Info:<br><br>FERTIG - fncStatusLogsAuslesen<br>$$" 10 &
    
    
#     ############################################################
#     intUTCSekDifferenzEnde=`date '+%s'`
#     intUTCSekDifferenz=intUTCSekDifferenzEnde-intUTCSekDifferenzStart
#     [ $intUTCSekDifferenz -lt 1 ] && intUTCSekDifferenz=1
#     kdialog --title "fncStatusLogsAuslesen - ENDE" --passivepopup "`fncHHMMSS 'norm.mS2'` -:- PID: $actionCPlogsPID<br><br>UTC Start: $intUTCSekDifferenzStart<br>UTC Ende: $intUTCSekDifferenzEnde<br>UTC Differenz: $intUTCSekDifferenz" 10 &
#     ############################################################
}


function fncStatusLogsAnzeigen {
    while ( [[ ! -f "$dateiLOGStmpSTATUS" ]] )
    do
        sleep 0.1
    done
    
    typeset -i x=0
    arrTMPstatus=()
    while read txtTMPstatus
    do
        arrTMPstatus[$x]=$txtTMPstatus
        x=x+1
        
        # *****************************************************************************************
        # ***** START Live Kontrolle max Video Anzahl *********************************************
        # *****************************************************************************************
        #
        #[[ "$txtTMPstatus" == URL:* ]] && intAnzahlVideosLive=${txtTMPstatus//*Video: /} && intAnzahlVideosLive=${intAnzahlVideosLive//\/*/}
        #[[ "$intAnzahlVideosLive" != URL:* ]] && kdialog --title "#.video" --passivepopup "Video Anzahl<br><br>$intAnzahlVideosLive<br>" 10
        #
        # *****************************************************************************************
        # ***** ENDE Live Kontrolle max Video Anzahl **********************************************
        # *****************************************************************************************
        
    done < $dateiLOGStmpSTATUS
    
    
    txtSTATUS=""
    txtSTATUSausgabe=""
    txtSTATUSausgabeX0x=""
    txtSTATUSausgabeX1x=""
    txtSTATUSausgabeX2x=""
    txtSTATUSausgabeX3x=""
    txtSTATUSausgabeX4x=""
    txtSTATUSausgabeX5x=""
    txtSTATUSausgabeX0=""
    txtSTATUSausgabeX1=""
    txtSTATUSausgabeX2=""
    txtSTATUSausgabeX3=""
    
    
    x=0
    txtSTATUS="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabe="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX0x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX1x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX2x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX3x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX4x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX5x="${arrTMPstatus[$x]}"
    x=x+1
    txtURLanzeige="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLIST="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLISTaktuell="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLISTende="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLISTvideo="${arrTMPstatus[$x]}"
    x=x+1
    txtTRENNERplaylist="${arrTMPstatus[$x]}"
    x=x+1
    
#     #rm $dateiLOGStmpSTATUS >/dev/null 2>&1
#     # -Die temporäre Logs Status Datei löschen:
#     if ( [[ -f "$dateiLOGStmpSTATUS" ]] )
#     then
#         rm "$dateiLOGStmpSTATUS"
#     fi

    # -Zum Prüfen ob das Gesamtskript noch läuft: flagQUITps existiert nicht in  $dateiCACHEflagQUIT
        #cursorZEILEstatus=cursorZEILE-6
        cursorZEILEstatus=cursorZEILE-6
#       
#       Ehemalige Position: cp Logs und auslesen!!!
#       
        #txtPLAYLIST="$txtPLAYLISTaktuell $txtPLAYLISTvideo $txtTRENNERplaylist $txtPLAYLISTende"
        #txtPLAYLIST="A""$txtPLAYLISTaktuell""A"" V""$txtPLAYLISTvideo""V"" T""$txtTRENNERplaylist""T"" E""$txtPLAYLISTende""E"
        #txtPLAYLIST="U.""$txtURLanzeige"".U"" P.""$txtPLAYLIST"".P"" A.""$txtPLAYLISTaktuell"".A"" V.""$txtPLAYLISTvideo"".V"" T.""$txtTRENNERplaylist"".T"" E.""$txtPLAYLISTende"".E"
        #U.URL: 3/3.U P..P A.- playlist/79967001.A V.(Video 28 von 30).V T.- Fertig:.T E.playlist/79299221, playlist/77936882.E
        #txtPLAYLISTvideoLOGS=${txtSTATUS//*video /}
        
        txtURLanzeigeOriginal="$txtURLanzeige"
        txtPLAYLISTvideoOriginal="$txtPLAYLISTvideo"
        
        txtPlaylistAnzahlURL=${txtURLanzeige//URL\: /}
        [[ "$txtPlaylistAnzahlURL" == "" ]] && txtPlaylistAnzahlURL="-/-"
        
        txtPlaylistAnzahlVideo=${txtPLAYLISTvideo//(Video /}
        txtPlaylistAnzahlVideo=${txtPlaylistAnzahlVideo//)/}
        txtPlaylistAnzahlVideo=${txtPlaylistAnzahlVideo// von //}
        [[ "$txtPlaylistAnzahlVideo" == "" ]] && txtPlaylistAnzahlVideo="-/-"
        [[ "$txtPlaylistAnzahlVideo" == *\]\ Downloading\ playlist:* ]] && txtPlaylistAnzahlVideo="-/-"
        
        [[ "$txtPLAYLISTaktuell" == "" ]] && txtPLAYLISTaktuell="Playlist..."
        
        #txtPLAYLIST="$txtURLanzeige $txtPLAYLISTaktuell $txtPLAYLISTvideo $txtTRENNERplaylist $txtPLAYLISTende"
        #txtPLAYLIST="URL: $txtPlaylistAnzahlURL, Video: $txtPlaylistAnzahlVideo, PLS: $txtPLAYLISTaktuell $txtTRENNERplaylist $txtPLAYLISTende"
        txtPLAYLIST="URL: $txtPlaylistAnzahlURL, Video: $txtPlaylistAnzahlVideo, Pls: $txtPLAYLISTaktuell, $txtTRENNERplaylist $txtPLAYLISTende"
        [[ "$txtPLAYLISTende" == "" ]] && txtPLAYLIST="URL: $txtPlaylistAnzahlURL, Video: $txtPlaylistAnzahlVideo, Pls: $txtPLAYLISTaktuell"
        
        
        txtSTATUSausgabeX0=$txtSTATUSausgabeX0x
        txtSTATUSausgabeX1=$txtSTATUSausgabeX1x
        txtSTATUSausgabeX2=$txtSTATUSausgabeX2x
        #echo -e "|- --- 0: $txtSTATUSausgabeX0 - 1: $txtSTATUSausgabeX1 - 2: $txtSTATUSausgabeX2 - 3: $txtSTATUSausgabeX3"
        if ( [[ "$txtSTATUSausgabe" == "---EOF---" ]] || [[ "$txtSTATUSausgabe" == "" ]] )
        then
            txtSTATUSausgabeX0=$txtSTATUSausgabeX1x
            txtSTATUSausgabeX1=$txtSTATUSausgabeX2x
            txtSTATUSausgabeX2=$txtSTATUSausgabeX3x
            txtSTATUSausgabe=$txtSTATUSausgabeX0
            if ( [[ "$txtSTATUSausgabe" == "---EOF---" ]] || [[ "$txtSTATUSausgabe" == "" ]] )
            then
                txtSTATUSausgabeX0=$txtSTATUSausgabeX2x
                txtSTATUSausgabeX1=$txtSTATUSausgabeX3x
                txtSTATUSausgabeX2=$txtSTATUSausgabeX4x
                txtSTATUSausgabe=$txtSTATUSausgabeX0
                if ( [[ "$txtSTATUSausgabe" == "---EOF---" ]] || [[ "$txtSTATUSausgabe" == "" ]] )
                then
                    txtSTATUSausgabeX0=$txtSTATUSausgabeX3x
                    txtSTATUSausgabeX1=$txtSTATUSausgabeX4x
                    txtSTATUSausgabeX2=$txtSTATUSausgabeX5x
                    txtSTATUSausgabe=$txtSTATUSausgabeX0
                fi
            fi
        fi
        #txtSTATUSausgabe=${txtSTATUSausgabe//*[download]/}
        #txtSTATUSausgabe=${txtSTATUSausgabe//*[/[}
        txtSTATUSausgabeX2=${txtSTATUSausgabeX2//*[/[}
        txtSTATUSausgabeX1=${txtSTATUSausgabeX1//*[/[}
        txtSTATUSausgabeX0=${txtSTATUSausgabeX0//*[/[}
        
        # -Ausgabe: Status Zeile 3 (oben)
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        txtZEIT="["`date '+%T'`"]"
        echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabeX2${fmtRESET}"
        
        # -Ausgabe: Status Zeile 2 (mitte)
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        txtZEIT="["`date '+%T'`"]"
        echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabeX1${fmtRESET}"
        
        # -Ausgabe: Status Zeile 1 (unten)
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        txtZEIT="["`date '+%T'`"]"
        echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabeX0${fmtRESET}"
        
#         cursorZEILEstatus=cursorZEILEstatus+1
#         tput cup $cursorZEILEstatus 0
#         echo $zeileDELETE
#         tput cup $cursorZEILEstatus 0
#         echo $zeileINSERT
#         tput cup $cursorZEILEstatus 0
#         echo -e "|-"
        #rm $dateiLOGStmp
        
        # -Ausgabe: Komplette Playlist Zeile
        if ( [[ "$txtPLAYLIST" != "" ]] )
        then
            txtZeileStart="|- "
            intSTATUSzeichenMAX=intLayoutMaxSpalten-${#txtZeileStart}
            cursorZEILEstatus=cursorZEILEstatus+1
            tput cup $cursorZEILEstatus 0
            echo $zeileDELETE
            tput cup $cursorZEILEstatus 0
            echo $zeileINSERT
            tput cup $cursorZEILEstatus 0
            #echo -e "|- Video Infos: $txtPLAYLIST"
            echo -e "|- ${txtPLAYLIST:0:$intSTATUSzeichenMAX}"
        fi
        
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        echo -e "|----------------------------------------"
        
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        echo -e "|-"
        
        # -Lange Statuszeilen werden teilweise fehlerhaft und nicht innerhalb des Statistik
        #  Bereichs angezeigt. Um dies zu verhindern, werden die Inhalte der Variablen
        #  gelöscht:
        txtSTATUS=""
        txtSTATUSausgabe=""
        txtSTATUSausgabeX0x=""
        txtSTATUSausgabeX1x=""
        txtSTATUSausgabeX2x=""
        txtSTATUSausgabeX3x=""
        txtSTATUSausgabeX4x=""
        txtSTATUSausgabeX5x=""
        txtSTATUSausgabeX0=""
        txtSTATUSausgabeX1=""
        txtSTATUSausgabeX2=""
        txtSTATUSausgabeX3=""
        
    #done
}
#fncStatusLogsAnzeigen &
# +++++ ENDE Status aus Logdatei anzeigen +++++++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++








# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Hintergrund Funktionen aufrufen: ++++++++++++++++++++++++++++++++
#
# -fncBEFEHLaufrufen: Download der URLs wird einzeln gestartet
# -fncMOVEasciiKREISEL: Um anzuzeigen dass das Skript noch arbeitet
#
# fncBEFEHLaufrufen &
# checkBEFEHLreturn=$?
# checkBEFEHLpid=$!

echo -e "|-"
#echo -e "|- Skript sofort beenden: 'q' --- Skript nach der aktuellen Datei beenden: 'f'"
#echo -e "|- Skript sofort beenden: 'q' --- Aktuelle Datei fertigstellen, dann Skript beenden: 'f'"

# echo -e "|- 'q':\\tAktuelle Datei abbrechen, dann das Skript beenden."
# if ( [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
# then
#     echo -e "|- 'f':\\tAktuelle Datei fertigstellen, dann das Skript beenden."
#     echo -e "|- 'u':\\tAktuelle Datei fertigstellen, dann die nächste URL/Playliste bearbeiten."
# elif ( [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
# then
#     echo -e "|- 'f':\\tAktuelle URL fertigstellen, dann das Skript beenden."
#     echo -e "|- 'u':\\tAktuelle URL abbrechen, dann die nächste URL/Playliste bearbeiten."
# fi



if ( [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
then
    #echo -e "|- 'q':\\tSkript beenden, aktuelle Datei wird abgebrochen.\\t\\t'f':\\tSkript beenden, aktuelle Datei wird fertiggestellt."
    #echo -e "|- 'q':\\tAktuelle Datei abbrechen und Skript beenden.\\t\\t'f':\\tAktuelle Datei fertigstellen und Skript beenden."
    #echo -e "|- 'f':\\tSkript beenden, aktuelle Datei wird fertiggestellt."
    #echo -e "|- 'd':\\tAktuelle Datei abbrechen und nächste Datei bearbeiten. (URL/Playliste unverändert)"
    #echo -e "|- 'u':\\tAktuelle Datei fertigstellen, dann die nächste URL/Playliste bearbeiten."
    
    echo -e "|- 'q':\\tDownload abbrechen und das Skript beenden.\\t\\t | 'f': Datei fertig downloaden und dann das Skript beenden."
    echo -e "|- 'u':\\tDatei fertigstellen und die nächste URL/Playliste\\t | 'd': Download abbrechen und nächste Datei bearbeiten."
    echo -e "|-\\tbearbeiten.\\t\\t\\t\\t\\t\\t |"
elif ( [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
then
    echo -e "|- 'q':\\tDownload abbrechen und das Skript beenden.\\t\\t | 'f': URL/Playliste fertig downloaden und dann das Skript beenden."
    echo -e "|- 'u':\\tDownload abbrechen und die nächste URL/Playliste\\t |"
    echo -e "|-\\tbearbeiten.\\t\\t\\t\\t\\t\\t |"
fi





echo -n "|- $datei wird ausgeführt... "

fncMOVEasciiKREISEL &
fncMOVEasciiKREISELpid=$!
#
# +++++ ENDE Hintergrund Funktionen aufrufen: +++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++










# -Die Ausgabe abschalten. Wegen kill Status/Fehler Meldungen.
##exec >/dev/null 2>&1


while ( [[ `ps -p $checkBEFEHLpid | grep -i $checkBEFEHLpid` != "" ]] && [[ "$actionKONTROLLE" != "stop" ]] )
do
    nix=1
    CHECKeingabeTASTE
    CHECKeingabeTASTEpid=$!
    if ( [[ "$eingabeTASTE" == "q" ]] )
    then
        #flagERFOLGREICHabgeschlossen="true"
        #kill -9 $CHECKeingabeTASTEpid
        fncKILLpid $CHECKeingabeTASTEpid
        break
    fi
    #kill -9 $CHECKeingabeTASTEpid
    fncKILLpid $CHECKeingabeTASTEpid
done

#fncDEBUGstart


# -Der Exitstatus wird anhand von $eingabeTASTE und $actionKONTROLLE erneut
#  ausgewertet und im $flagQUITkontrolle gespeichert:
flagQUITkontrolle=""
tput cub 1
if ( [[ "$eingabeTASTE" == "q" ]] || [[ "$eingabeTASTE" == "f" ]] )
then
    # -Den checkBEFEHLreturn Status kontrollieren und ggf korrigieren!
    # --Skript wurde normal beendet: 0
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="1"
    flagQUITkontrolle=$eingabeTASTE"-1"
elif ( [[ "$FlagModusBefehlKOMPLETTquit" == "Taste-U" ]] )
then
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="1"
    flagQUITkontrolle="ModusKomplettTaste-U-1"
elif ( [[ "$actionKONTROLLE" == "stop" ]] )
then
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="0"
    flagQUITkontrolle="ps-KREISEL-$checkBEFEHLreturn"
else
    # -Nicht Q && $actionKONTROLLE == start
    # -Die WhilePSdoCHECKeingabeTASTE hat den Fehler (kein Prozess) erkannt
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="2"
    flagQUITkontrolle="ps-WHILE-$checkBEFEHLreturn"
fi

#checkKILLreturnKREISEL=`kill -9 $fncMOVEasciiKREISELpid >/dev/null 2>/dev/null`
#`kill -9 $fncMOVEasciiKREISELpid >/dev/null 2>&1`
if ( [[ "$actionKONTROLLE" != "stop" ]] )
then
    #kill -9 $fncMOVEasciiKREISELpid
    fncKILLpid $fncMOVEasciiKREISELpid
fi

#tput cub 1



# -SONDERFALL: Zeile davor enthält kein Newline Zeichen (wegen 'echo -en')
getCPos
[ "$CPosSPALTE" -gt 1 ] && echo -e ""
#echo -e "--- $CPosSPALTE"

fncKILLallePROZESSE "EIGENESTTY" >/dev/null 2>&1
#$0 "-PSK" "EIGENESTTY" >/dev/null 2>&1










# -die temporäre Logdatei wird wieder entfernt:
[ -f $dateiLOGStmp ] && rm $dateiLOGStmp



# -------------------------------------------------------------------
# -ABLAGE: Alte Befehle:
# `$checkBEFEHL` >> $dateiLOGS
#`$checkBEFEHL` >> $dateiLOGS 2> `tty`
#checkBEFEHLreturn=$?
#echo -e "|- checkBEFEHL: $?"
# -------------------------------------------------------------------

# -die Original Archiv Datei aus der Config auslesen
# -das temporäre Archiv an die Original Archiv Datei anhängen
# -das temporäre Archiv löschen
if ( [[ "$flagForceGlobal" == "true" ]] && [[ -f "$archivTMP" ]] )
then
#     # +++++ START Config auslesen
#     while read txtCONFIG
#     do
#         #nix=1
#         if ( [[ "$txtCONFIG" == --download-archiv* ]] )
#         then
#             archivORIGINAL=${txtCONFIG//\-\-download\-archiv /}
#             #echo $archivORIGINAL
#             break
#         fi
#     done < ~/.config/$strBefehlName/config
#     # +++++ ENDE Config auslesen

    # +++++ START archivTMP anhängen an archivORIGINAL
    while read txtTMP
    do
        echo $txtTMP >> $archivORIGINAL
    done < $archivTMP
    # +++++ ENDE archivTMP anhängen an archivORIGINAL

    # -das archivTMP löschen:
    [ -f $archivTMP ] && rm $archivTMP
fi
[ -f $archivTMP ] && rm $archivTMP







# -Die Ausgabe wieder auf den Bildschirm legen:
##exec >`tty` 2>&1
#exec >`tty` 2>>$dateiLOGS




# DEBUG-INFO:
#echo -e $txtCHECKpsKILL






fncCHECKzugriffeLOGS



#fncAUSLESENbefehlINTERN
#echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
#echo -e "--- DEBUG-INFO: $txtCHECKpsKILL"
# -Ende: Zeit und Status anzeigen
zeitENDE=`date`
#txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Details:\t$dateiLOGS $flagQUIT PID.$checkBEFEHLpid RETURN.$checkBEFEHLreturn \
# - PID.$checkBEFEHLinternPID RETURN.$checkBEFEHLinternRETURN"

txtINFOende="$txtENDEzeit$zeitENDE"
echo -e $txtINFOende
echo -e $txtINFOende >> $dateiLOGS



#==================================================================================================
#===== START txtINFOendeANZaufrufe ================================================================
txtListePls=""
txtListePlsUeberschrift=""
txtListePlsUeberschriftAnzahl=""
typeset -i intAnzAufrufePls=0
typeset -i intAnzAufrufePlsKomplett=0
typeset -i intAnzAufrufePlsMaxVideos=0
typeset -i intANZaufrufeGESAMT=0
typeset -i intANZaufrufeGESAMTkontrolle=0
typeset -i intANZaufrufeINarchive=0
typeset -i intANZaufrufeDOWNLOADjetzt=0
typeset -i intANZaufrufeFEHLER=0
function fncLOGScheckAUFRUFE {
    # -Die Integer Variablen müssen außerhalb der Funktion definiert werden,
    #  damit sie wirklich global sind!!!
    while read txtSTATUS
    do
        # -Anzahl der Aufrufe auswerten:
        # --Gesamtaufrufe!
        # --Bereits heruntergeladen!
        # --Jetzt erfolgreich heruntergeladen!
        [[ "$txtSTATUS" == *\]\ Downloading*of* ]] && intANZaufrufeGESAMT=intANZaufrufeGESAMT+1
        
        #[[ "$txtSTATUS" == \[download\]*been\ recorded\ in\ archive* ]] && intANZaufrufeINarchive=intANZaufrufeINarchive+1 && intANZaufrufeGESAMTkontrolle=intANZaufrufeGESAMTkontrolle+1
        # -Neu wegen yt-dlp:
        [[ "$txtSTATUS" == \[*\]*:\ has\ already\ been\ recorded\ in\ the\ archive ]] && intANZaufrufeINarchive=intANZaufrufeINarchive+1 && intANZaufrufeGESAMTkontrolle=intANZaufrufeGESAMTkontrolle+1
        [[ "$txtSTATUS" == \[*\]*\ has\ already\ been\ downloaded ]] && intANZaufrufeINarchive=intANZaufrufeINarchive+1 && intANZaufrufeGESAMTkontrolle=intANZaufrufeGESAMTkontrolle+1
        
        # -TODO:
        # -Die Datenmenge der einzelnen Dateien und des kompletten Downloads erfassen,
        #  ausgeben und in der Logdatei speichern:
        #
        # --Beispiel für sicher erfolgreichen Download mit Dateipfad:
        #   [download] Destination: PlsName/Datei.mp4
        #   [download]   0.0% of ~   158.24MiB at...
        #   [download]  24.9% of ~   158.24MiB at...
        #   [download] 100% of       158.24MiB in... at...
        # --Zuerst kommt eine Zeile mit '[download] Destination:*' und kurz danach eine Zeile
        #   mit '*100\%*'.
        # --Dateipfad und Dateigröße in Array sichern um am Ende die Gesamtgröße in der Logdatei
        #   angeben.
        # --arrStatsDateiPfad und arrStatsDateiGroesse
        
        
        [[ "$txtSTATUS" == *100\%* ]] && intANZaufrufeDOWNLOADjetzt=intANZaufrufeDOWNLOADjetzt+1 && intANZaufrufeGESAMTkontrolle=intANZaufrufeGESAMTkontrolle+1
        
        # -Anzahl Playlisten auslesen und PLS Liste erstellen:
        txtTRENNERListePls=""
        # -Komplett bearbeitet:
        if ( [[ "$txtSTATUS" == *\]\ Finished\ downloading\ playlist:* ]] )
        then
            if ( [[ "$txtListePls" != "" ]] )
            then
                txtTRENNERListePls="\\n"
            fi
#             if ( [[ "$txtListePls" == "" ]] )
#             then
#                 txtListePls="|-\\t"
#             fi
            intAnzAufrufePls=intAnzAufrufePls+1
            txtPLAYLISTfertig=${txtSTATUS//*playlist: /}
            txtListePls="$txtListePls""$txtTRENNERListePls""|- --Komplett: $txtPLAYLISTfertig"
        fi
        txtTRENNERListePls=""
        # -Abbruch wegen intAnzahlVideosMax:
        if ( [[ "$txtSTATUS" == *\]*Die\ maximale\ Video-Anzahl*Pls:* ]] )
        then
            if ( [[ "$txtListePls" != "" ]] )
            then
                txtTRENNERListePls="\\n"
            fi
#             if ( [[ "$txtListePls" == "" ]] )
#             then
#                 txtListePls="|-\\t"
#             fi
            intAnzAufrufePls=intAnzAufrufePls+1
            intAnzAufrufePlsMaxVideos=intAnzAufrufePlsMaxVideos+1
            txtPLAYLISTfertig=${txtSTATUS//*Pls: /}
            txtListePls="$txtListePls""$txtTRENNERListePls""|- --Max Anzahl Videos: $txtPLAYLISTfertig"
        fi
        
    done < $dateiLOGS
    intAnzAufrufePlsKomplett=intAnzAufrufePls-intAnzAufrufePlsMaxVideos
    (( intAnzAufrufePls > 1 )) && txtListePlsUeberschriftAnzahl=" $intAnzAufrufePls/$intAnzAufrufePlsKomplett/$intAnzAufrufePlsMaxVideos (Alle/Komplett/MaxVideos)"\\n"|- -Max Anzahl Videos pro URL/Pls: $intAnzahlVideosMax"
    (( intAnzAufrufePls > 1 )) && txtListePlsUeberschrift="|- Bearbeitete Playlisten:$txtListePlsUeberschriftAnzahl" || txtListePlsUeberschrift="|- Bearbeitete Playliste:"
}
fncLOGScheckAUFRUFE

txtAnzAufrufePls=""
[[ "$txtListePls" != "" ]] && txtListePls="$txtListePlsUeberschrift"\\n"$txtListePls"\\n"|-"
(( intAnzAufrufePls > 0 )) && txtAnzAufrufePls="Pls: $intAnzAufrufePls/$intAnzAufrufePlsKomplett/$intAnzAufrufePlsMaxVideos - "

# -Anzahl Videos kontrollieren und ggf korrigieren:
typeset -i intAnzUrlsGesamt=${#eingabeURLarray[@]}
[ "$intANZaufrufeGESAMTkontrolle" -lt "$intAnzUrlsGesamt" ] && intANZaufrufeGESAMTkontrolle="$intAnzUrlsGesamt"
[ "$intANZaufrufeGESAMT" -lt "$intANZaufrufeGESAMTkontrolle" ] && intANZaufrufeGESAMT="$intANZaufrufeGESAMTkontrolle"
intANZaufrufeFEHLER=`echo -e "scale=0 ; $intANZaufrufeGESAMT-($intANZaufrufeINarchive+$intANZaufrufeDOWNLOADjetzt)" | bc -l`

# -Anzeige von Status Info: Anzahl Videos bzw URLs 
txtINFOendeANZaufrufe="|- Anzahl:\\t""$txtAnzAufrufePls""$txtStandardDownloadPlural gesamt: $intANZaufrufeGESAMT - Neue Downloads: $intANZaufrufeDOWNLOADjetzt - Bereits geladen: $intANZaufrufeINarchive - Fehler/Abbruch: $intANZaufrufeFEHLER"
echo -e $txtINFOendeANZaufrufe
echo -e $txtINFOendeANZaufrufe >> $dateiLOGS
#===== ENDE txtINFOendeANZaufrufe =================================================================
#==================================================================================================





#==================================================================================================
#===== START txtINFOstatusCHECK ===================================================================
case "$flagQUITkontrolle" in
    ( *0 )
        # -kein Fehler!
        txtINFOstatusCHECK="|- Check: \\tEs gab keine internen Fehler."
        #checkBEFEHLreturn="0"
        ;;
    ( *1 )
        # -Abbruch durch Benutzer!
        txtINFOstatusCHECK="|- Check: \\tKontrolle wurde durch den Benutzer abgebrochen."
        checkBEFEHLreturn="1"
        ;;
    ( *2 )
        # -Abbruch durch Fehler!
        txtINFOstatusCHECK="|- Check: \\tKontrolle wurde durch einen unbekannten Fehler abgebrochen."
        checkBEFEHLreturn="2"
        ;;
esac

[[ "$flagCHECKurlsKOMPLETT" != "true" ]] || [[ "$intANZaufrufeFEHLER" -gt 0 ]] && txtINFOstatusCHECK="|- Check: \\tNicht alle URLs konnten erfolgreich bearbeitet werden."

[[ "$flagQUITkontrolle" == "ModusKomplettTaste-U_1" ]] && txtINFOstatusCHECK="|- Check: \\tURL Kontrolle wurde durch den Benutzer abgebrochen."


txtINFOstatusDETAILS=" (urls-$flagCHECKurlsKOMPLETT-$intANZaufrufeFEHLER:f-$flagQUITpsTasteF.$flagQUITkontrolle:$flagQUIT:$checkBEFEHLpid.$checkBEFEHLreturn.$checkBEFEHLreturnORIGINAL)"

#txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Status:\\t$txtINFOstatus$txtINFOstatusDETAILS$txtINFOstatusCHECK"\\n"|-"
#txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Status:\\t$txtINFOstatus""$txtINFOstatusCHECK""$txtINFOstatusDETAILS"\\n"|-"
txtINFOende="$txtINFOstatusCHECK""$txtINFOstatusDETAILS"
echo -e $txtINFOende
echo -e $txtINFOende >> $dateiLOGS
#===== ENDE txtINFOstatusCHECK ====================================================================
#==================================================================================================





#==================================================================================================
#===== START txtINFOstatus ========================================================================
[[ -f $dateiCACHEflagCHECKurlsKOMPLETT ]] && flagCHECKurlsKOMPLETT=`cat $dateiCACHEflagCHECKurlsKOMPLETT`
txtInfoStatusDialog=""
if ( [[ "$flagQUIT" == *truePS* ]] )
then
    [[ "$flagCHECKurlsKOMPLETT" == "true" ]] && [[ "$intANZaufrufeFEHLER" -eq 0 ]] && txtINFOstatus="Das Skript wurde erfolgreich abgeschlossen." && checkBEFEHLreturn="0"
    [[ "$flagCHECKurlsKOMPLETT" != "true" ]] || [[ "$intANZaufrufeFEHLER" -gt 0 ]] && txtINFOstatus="Das Skript wurde abgeschlossen, allerdings traten dabei Fehler auf."\\n"|-"\\t\\t"Nähere Infos finden Sie in der Logdatei. '$dateiLOGS'" && checkBEFEHLreturn="1" && txtInfoStatusDialog="Das Skript wurde abgeschlossen, allerdings traten dabei Fehler auf."
fi

if ( [[ "$FlagModusBefehlKOMPLETTquit" == "Taste-U" ]] )
then
    txtINFOstatus="Die Bearbeitung der URLs wurde teilweise vom Benutzer abgebrochen. Befehl: 'u'"
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="1"
fi
if ( [[ "$flagQUIT" == *tasteF-status-0* ]] || [[ "$flagQUITpsTasteF" == "true" ]] )
then
    txtINFOstatus="Das Skript wurde vom Benutzer beendet. Befehl: 'f'"
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="1"
    #[[ "$FlagModusBefehlPlaylist" == "komplett" ]] && [[ "$flagCHECKurlsKOMPLETT" == "true" ]] && checkBEFEHLreturn="0"
fi
if ( [[ "$flagQUIT" == *trueQ* ]] )
then
    txtINFOstatus="Das Skript wurde vom Benutzer abgebrochen. Befehl: 'q'"
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="1"
fi
if ( [[ "$flagQUIT" == *trueQ-PS* ]] )
then
    txtINFOstatus="Das Skript wurde vom Benutzer oder einem anderen Prozess abgebrochen."
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="2"
fi
txtINFOende="|- Status:\\t$txtINFOstatus"\\n"|-"
[[ "$txtInfoStatusDialog" == "" ]] && txtInfoStatusDialog="$txtINFOstatus"
echo -e $txtINFOende
echo -e $txtINFOende >> $dateiLOGS
#===== ENDE txtINFOstatus =========================================================================
#==================================================================================================



# -txtListePls wird nicht ausgegeben, aber in die Logs eingefügt:
(( intAnzAufrufePls > 0 )) && echo -e "$txtListePls" >> $dateiLOGS





#if ([[ "$eingabeTASTE" == "e" ]]  )
if ( [[ "$actionKONTROLLE" == "stop" ]]  )
then
    checkBEFEHLreturn="0"
fi


















#fncDEBUGstop





# echo -e "|-----"
# echo -e "DEBUG: flagFEHLERlogs  : $flagFEHLERlogs"
# echo -e "DEBUG: flagFEHLERlogs2 : $flagFEHLERlogs2"
# echo -e "DEBUG: txtFEHLERlogs   : $txtFEHLERlogs"
# echo -e "DEBUG: txtFEHLERlogs2  : $txtFEHLERlogs2"
# echo -e "|-----"


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Endkontrolle und Status anzeigen ++++++++++++++++++++++++++++++++
# -Rückgabewert des Befehls kontrollieren
# -Logdatei auf Fehler kontrollieren: fncLOGScheckFEHLER
# --Diese setzt: flagFEHLERlogs, txtFEHLERlogs
# -Am Ende des Skripts muss die Infozeile angepasst und verhindert werden, dass
#  die aktuellen URLs gelöscht werden
#
# -Logdatei mit Zeilennummern versehen, damit Fehlermeldungen besser
#  zugeordnet werden können!
# --Zuerst alle Zeilennummern einfügen und dann den Fehlercheck starten.
#
function fncLOGSzeilennummern {
    #fncDEBUGstart "Zeilennummern"
    # -Maximale Anzahl an Zeilen ermitteln, damit klar ist wieviele Stellen für die
    #  Zeilennummern gebraucht werden.
    typeset -i intANZAHLzeichenZEILEN=0
    typeset -i intZEILENNUMMER=0
    intANZAHLzeilenLOGS=`wc -l $dateiLOGS`
    #echo -e "--- DEBUG-INFO: Anzahl Zeilen: $intANZAHLzeilenLOGS"
    intANZAHLzeilenLOGS=${intANZAHLzeilenLOGS// */}
    #echo -e "--- DEBUG-INFO: Anzahl Zeilen: $intANZAHLzeilenLOGS"
    intANZAHLzeichenZEILEN=`echo $intANZAHLzeilenLOGS | wc -m`
    intANZAHLzeichenZEILEN=intANZAHLzeichenZEILEN-1
    #echo -e "--- DEBUG-INFO: Anzahl Zeichen: $intANZAHLzeichenZEILEN"
    
    
#     while read txtLOGS
#     do
#         #txtLOGStrESCAPE=`echo -e "$txtLOGS" | tr -d '\r\n'`
#         #txtLOGS="$txtLOGStrESCAPE"
#         echo -e "$txtLOGS" >> $dateiLOGStmp
#     done < $dateiLOGS
#     while [ ! -f $dateiLOGStmp ]
#     do
#         sleep 0.1
#     done
#     mv $dateiLOGStmp $dateiLOGS
#     while [ ! -f $dateiLOGS ]
#     do
#         sleep 0.1
#     done
    
    
    while read txtLOGS
    do
        [[ "$txtLOGS" == "" ]] && continue
        intZEILENNUMMER=intZEILENNUMMER+1
        #echo -e "--- DEBUG ---"
        #echo -e "--- DEBUG --- txtLOGS original: $txtLOGS"
        #txtLOGStrZIFFERN=`echo -e "$txtLOGS" | tr -d '\000-\011\013\014\016-\037'`
        #echo -e "--- DEBUG --- txtLOGS Ziffern: $txtLOGStrZIFFERN"
        #txtLOGStrR=`echo -e "$txtLOGS" | tr -d '\r'`
        #echo -e "--- DEBUG --- txtLOGS nur r: $txtLOGStrR"
        #txtLOGStrN=`echo -e "$txtLOGS" | tr -d '\n'`
        #echo -e "--- DEBUG --- txtLOGS nur n: $txtLOGStrN"
        
        # -Download Prozentangabe wird mit $txtLOGStrESCAPE komplett ausgelesen und
        #  gleichzeitig bleiben Leerzeichen und Tabs erhalten!
        txtLOGStrESCAPE=`echo -e "$txtLOGS" | tr -d '\r'`
        txtLOGS="$txtLOGStrESCAPE"
        #echo -e "--- DEBUG --- txtLOGS r und n: $txtLOGStrESCAPE"
        
        #txtLOGS=${txtLOGS//\\r/}
        #echo -e "--- DEBUG --- intZEILENNUMMER: $intZEILENNUMMER"
        
        # -Fehlende Zeilennummer: Download Prozentangabe
        if [[ "$txtLOGS" == \[download\]*\%\ of* ]]
        then
            #typeset -i intANZAHLzeichenLOGS=0
            #typeset -i intANZAHLzeichenAUSSCHNEIDEN=0
            #intLOGSzeichen=${#txtLOGS}
            [[ "$txtLOGS" == *100\%* ]] && txtLOGS=${txtLOGS//*100\%/100\%} && txtLOGS="[download] "$txtLOGS
            [[ "$txtLOGS" != *100\%* ]] && txtLOGS=${txtLOGS:0:140}
        fi
        
        
        while [[ "$txtLOGS" != \|*$intZEILENNUMMER\|* ]]
        do
            case "$intANZAHLzeichenZEILEN" in
                (1)
                    # -Zeilennummern haben maximal 1 Zeichen:
                    txtLOGS="|"`printf %01d $intZEILENNUMMER`"| $txtLOGS" ;;
                (2)
                    # -Zeilennummern haben maximal 2 Zeichen:
                    txtLOGS="|"`printf %02d $intZEILENNUMMER`"| $txtLOGS" ;;
                (3)
                    # -Zeilennummern haben maximal 3 Zeichen:
                    txtLOGS="|"`printf %03d $intZEILENNUMMER`"| $txtLOGS" ;;
                (4)
                    # -Zeilennummern haben maximal 4 Zeichen:
                    txtLOGS="|"`printf %04d $intZEILENNUMMER`"| $txtLOGS" ;;
                (5)
                    # -Zeilennummern haben maximal 5 Zeichen:
                    txtLOGS="|"`printf %05d $intZEILENNUMMER`"| $txtLOGS" ;;
                (6)
                    # -Zeilennummern haben maximal 6 Zeichen:
                    txtLOGS="|"`printf %06d $intZEILENNUMMER`"| $txtLOGS" ;;
            esac
            #echo -e "--- DEBUG --- nach-CASE - txtLOGS: $txtLOGS"
            #echo -e "--- DEBUG --- nach-CASE - intZEILENNUMMER: $intZEILENNUMMER"
        done
        #echo -e "$txtLOGS" >> $dateiLOGStmp
        echo -e "$txtLOGS" >> $dateiLOGStmp
    done < $dateiLOGS
    cp $dateiLOGS $dateiLOGStmpOHNEzeilennummern
    if ( [[ -f "$dateiLOGS" ]] )
    then
        rm "$dateiLOGS"
    fi
    mv $dateiLOGStmp $dateiLOGS
    #fncDEBUGstop "Zeilennummern"
}
#fncLOGSzeilennummern



function fncLOGScheckFEHLER {
    flagFEHLERlogs="false"
    txtFEHLERlogs=""
    txtSTATUS=""
    typeset -i intExitCode=0
    if ( [[ "$1" == "" ]] )
    then
        actionCHECKfehlerLOGS="checkJA.auslesenNEIN"
    else
        actionCHECKfehlerLOGS="$1"
    fi
    
    # -Check ob Datei schon fertig zum Lesen ist:
    while [ ! -r $dateiLOGS ]
    do
        sleep 0.05
    done
    
    while read txtSTATUS
    do
        # -Logdatei auf Fehler kontrollieren und Flag setzen:
        if ( ( [[ "$txtSTATUS" == *ERROR* ]] || [[ "$txtSTATUS" == *Error* ]] || [[ "$txtSTATUS" == *error* ]] ) && [[ "$txtSTATUS" != *Terror* ]] && [[ "$txtSTATUS" != *terror* ]] && [[ "$txtSTATUS" != *\[debug\]* ]] && [[ "$txtSTATUS" != *raise\ ExtractorError* ]] )
        then
            flagFEHLERlogs="true"
            #echo -e "--- DEBUG flagFEHLERlogs: $flagFEHLERlogs"
            #flagERFOLGREICHabgeschlossen="false"
            if ( [[ "$actionCHECKfehlerLOGS" != "checkJA.auslesenJA" ]] )
            then
                #return 12
                intExitCode=intExitCode+12
                break
            fi
            
            if ( [[ "$txtFEHLERlogs" == "" ]] )
            then
                txtFEHLERlogs=$txtHR\\n"|- Fehlermeldungen:"
            fi
            txtFEHLERlogs="$txtFEHLERlogs"\\n"$txtSTATUS"
        fi
    done < $dateiLOGS
    intExitCode=intExitCode+11
    return $intExitCode
}
fncLOGScheckFEHLER "checkJA.auslesenNEIN"
#flagFEHLERlogs=`fncLOGScheckFEHLER "checkJA.auslesenNEIN"`
#echo -e "--- DEBUG flagFEHLERlogs: $flagFEHLERlogs - flagERFOLGREICHabgeschlossen: $flagERFOLGREICHabgeschlossen"


function fncLOGSkopieren {
    # -Eine Sicherung der Logdatei im UVZ $strUVZLogs anlegen!
    # -Mit Zeitstempel der Startzeit: $zeitSTARTdateiname
    [[ ! -d $strUVZLogs ]] && mkdir $strUVZLogs
    cp $dateiLOGS $strUVZLogs"/"$dateiLOGSsicherung
    #rm $dateiLOGStmpOHNEzeilennummern
    if ( [[ -f "$dateiLOGStmpOHNEzeilennummern" ]] )
    then
        rm "$dateiLOGStmpOHNEzeilennummern"
    fi
}



function fncEINGABEreadMENUende {
    #echo -e "--- DEBUG flagFEHLERlogs: $flagFEHLERlogs - flagERFOLGREICHabgeschlossen: $flagERFOLGREICHabgeschlossen"
    echo -e "|- NEUSTART\\t'y'\\tDas Skript mit den gleichen Optionen und URLs einfach neu starten."
    echo -e "|- ENDE\\t\\t'q'\\tDas Skript beenden."
    echo -e "|- ENDE-LOGS\\t'l'\\tDas Skript beenden und dann die aktuelle Logdatei anzeigen."
    echo -e "|-"
    echo -en "|- Ihre Eingabe (y/q/l): "

    function getCPos { 
        local v=() t=$(stty -g)
        stty -echo
        printf "\033[6n"
        IFS='[;' read -ra v -d R
        stty $t
        CPos=(${v[@]:1})
        CPosSPALTE=(${v[@]:2})
    }
    getCPos
    typeset -i cursorZEILE=0
    cursorZEILE=$CPos
    cursorZEILE=cursorZEILE-1
    cursorZEILEminus1=cursorZEILE-1
    cursorZEILEminus2=cursorZEILE-2
    zeileDELETE=`tput dl1`
    zeileINSERT=`tput il1`

    eingabeNEUSTART=""
    strBEFEHLnachQUIT=""
    while ( [[ "$eingabeNEUSTART" != "y" ]] && [[ "$eingabeNEUSTART" != "q" ]] && [[ "$eingabeNEUSTART" != "l" ]] )
    do
        read -n 1 -t 1 -s eingabeNEUSTART
        #read -n 1 -s eingabeNEUSTART
        
        case "$eingabeNEUSTART" in
            ("y")
                #echo -e $eingabeNEUSTART\\n"--- Neustart"
                flagNEUSTART="true"
                flagERFOLGREICHabgeschlossen="false"
                #cp $dateiLOGStmpOHNEzeilennummern $dateiLOGS
                break
                ;;
            ("q")
                echo -e $eingabeNEUSTART\\n"|- Das Skript wird jetzt beendet! Bitte haben Sie ein wenig Geduld, während die"\\n"|- Daten gesichert werden."
                flagERFOLGREICHabgeschlossen="true"
                break
                ;;
            ("l" )
                echo -e $eingabeNEUSTART\\n"|- Das Skript wird jetzt beendet! Bitte haben Sie ein wenig Geduld, während die"\\n"|- Daten gesichert werden. Die Logdatei wird danach angezeigt."
                #strBEFEHLnachQUIT="$datei -l"
                strBEFEHLnachQUIT="fncAUSGABElogdatei $dateiLOGS"
                flagERFOLGREICHabgeschlossen="true"
                break
                ;;
            ( * )
                echo -en $zeileDELETE
                tput cup $cursorZEILE 0
                echo -en "|- Ihre Eingabe (y/q/l): "
                ;;
        esac
    done
}

function fncShutdown {
    #echo -e "|- Das System wird in $intOFFminuten min ausgeschaltet. Zum Abbrechen drücken Sie bitte: \"q\""
    echo -e "|- Das System wird in $intOFFminuten min neu gestartet. Zum Abbrechen drücken Sie bitte: \"q\""
    intOFFsekunden=`echo -e "$intOFFminuten*60" | bc`
    #echo -e "--- sek: $intOFFsekunden ---"
    #sleep $intOFFsekunden
    #eingabeTASTE=`dd bs=1 count=1 2>/dev/null`
    intUTCsekunden=`date '+%s'`
    intOFFsekunden=`echo -e "$intUTCsekunden + $intOFFsekunden" | bc`
    while ( [[ "$eingabeTASTE" != "q" ]] && [[ "$intOFFsekunden" -gt "$intUTCsekunden" ]] )
    do
        read -n 1 -t 0.05 -s eingabeTASTE
        #tput cub 1
        intUTCsekunden=`date '+%s'`
    done
    
    if ( [[ "$eingabeTASTE" != "q" ]] )
    then
        echo -e "|- Ausschalten..."
        # -Ausschalten darf erst erfolgen, wenn fncLOGSzeilennummern und fncLOGSkopieren
        #  erfolgreich abgeschlossen wurden. Daher wird der $strBEFEHLnachQUIT dafür genutzt!
        #`/bin/systemctl poweroff`
        #strBEFEHLnachQUIT="/bin/systemctl status minidlna"
        #strBEFEHLnachQUIT="/bin/systemctl poweroff"
        strBEFEHLnachQUIT="/bin/systemctl reboot"
        flagERFOLGREICHabgeschlossen="true"
    else
        echo -e "|- Ausschalten wurde abgebrochen!"
        flagERFOLGREICHabgeschlossen="true"
    fi
}





if ( [[ "$checkBEFEHLreturn" != "0" ]] || [[ "$flagFEHLERlogs" == "true" ]] )
then
    # -Wegen Kontrolle erfolgreich NEUSTART muss flagERFOLGREICHabgeschlossen auf true gesetzt werden:
    #flagERFOLGREICHabgeschlossen="true"
    
    txtINFOendeABBRUCH=""
#     if ( [[ "$checkBEFEHLreturn" == "1" ]] )
#     then
#         txtINFOendeABBRUCH="|- FEHLER:\t$datei wurde vom Benutzer abgebrochen!"\\n
#         # -Wegen Kontrolle erfolgreich NEUSTART muss flagERFOLGREICHabgeschlossen auf true gesetzt werden:
#         #flagERFOLGREICHabgeschlossen="true"
#     fi
    #txtINFOende2="|- "\\n"|- FEHLER:\t$datei wurde abgebrochen!"\\n"|-"
    if ( [[ "$flagQUIT" == *tasteF-status-0* ]] )
    then
        txtINFOende1="|- INFO: \tDa das Skript vom Benutzer vorzeitig beendet wurde, werden die eingegebenen"\\n"|-\t\tURLs gespeichert. Beim nächsten Aufruf von $datei im gerade verwendeten"\\n"|-\t\tArbeitsverzeichnis werden diese automatisch übernommen."\\n"|-"
        txtINFOende1Logs="|- INFO: "\ "\tDa das Skript vom Benutzer vorzeitig beendet wurde, werden die eingegebenen"\\n"|-\t\tURLs gespeichert. Beim nächsten Aufruf von $datei im gerade verwendeten"\\n"|-\t\tArbeitsverzeichnis werden diese automatisch übernommen."\\n"|-"
    else
        txtINFOende1=""
    fi
    if ( [[ "$flagFEHLERlogs" == "true" ]] )
    then
        txtINFOende2="|- FEHLER:\tEinige Befehle wurden leider nicht erfolgreich abgeschlossen!"\\n"|- INFO: \tDie Fehlermeldungen finden Sie zusammen gefasst am Ende der Logdatei."\\n"|-\t\tDie Logdatei wird immer im Arbeitsverzeichnis des Skripts abgespeichert."\\n"|-\t\t'$datei -h' Zum Anzeigen der Hilfe"\\n"|-"
        txtINFOende2Logs="|- FEHLER:\tEinige Befehle wurden leider nicht erfolgreich abgeschlossen!"\\n"|- INFO: "\ "\tDie Fehlermeldungen finden Sie zusammen gefasst am Ende der Logdatei."\\n"|-\t\tDie Logdatei wird immer im Arbeitsverzeichnis des Skripts abgespeichert."\\n"|-\t\t'$datei -h' Zum Anzeigen der Hilfe"\\n"|-"
    else
        txtINFOende2=""
    fi
    # -FEHLER Sound:
    #beep -l 200 -f 200 -r 2 -D 100 --new -l 600 -f 160 -D 100
    beep -l 200 -f 240 -r 2 -D 60 --new -l 600 -f 200 -D 100 &
    
    #fncAusgabeDialogBeendet
    
    if ( [[ "$txtINFOende1" != "" ]] )
    then
        echo -e $txtINFOende1
        #txtINFOende2=$txtINFOende2$txtFEHLERlogs
        echo -e $txtINFOende1Logs >> $dateiLOGS
    fi
    if ( [[ "$txtINFOende2" != "" ]] )
    then
        echo -e $txtINFOende2
        #txtINFOende2=$txtINFOende2$txtFEHLERlogs
        echo -e $txtINFOende2Logs >> $dateiLOGS
    fi
    
    # -Die Cache Datei mit dem flagCHECKurlsKOMPLETT Status löschen:
    if ( [[ -f "$dateiCACHEflagCHECKurlsKOMPLETT" ]] )
    then
        rm "$dateiCACHEflagCHECKurlsKOMPLETT"
    fi
    # -Die Cache Datei mit dem flagQUIT Status löschen:
    if ( [[ -f "$dateiCACHEflagQUIT" ]] )
    then
        rm "$dateiCACHEflagQUIT"
    fi
    # -Die Cache Datei mit den Playlist Infos löschen:
    if ( [[ -f "$dateiCACHEplsINFOS" ]] )
    then
        rm "$dateiCACHEplsINFOS"
    fi
    # -Die Cache Datei mit der Playlist Info Item löschen:
    if ( [[ -f "$dateiCACHEplsINFOSitem" ]] )
    then
        rm "$dateiCACHEplsINFOSitem"
    fi
    # -Die temporäre Logs Status Datei löschen:
    if ( [[ -f "$dateiLOGStmpSTATUS" ]] )
    then
        rm "$dateiLOGStmpSTATUS"
    fi
    
#     if ( [[ "$flagFEHLERlogs" == "true" ]] )
#     then
#         fncEINGABEreadMENUende
#     fi
#     if ( [[ "$flagERFOLGREICHabgeschlossen" == "true" ]] )
#     then
#         # -Die temporäre Logdatei wird entfernt:
#         #rm $dateiLOGStmp
#         # -Sicherung der Logdatei mit Zeitstempel wird nur angelegt wenn das Skript
#         #  wirklich beendet wird:
#         fncLOGSkopieren
#     fi
    
else
    
    # -Wegen Kontrolle erfolgreich NEUSTART muss flagERFOLGREICHabgeschlossen auf true gesetzt werden:
    #flagERFOLGREICHabgeschlossen="true"
    
    #txtINFOende2="|- "\\n"|- $datei wurde erfolgreich beendet!"\\n"|-"
    # -Erfolgreich Sound:
    beep -l 200 -f 400 -r 2 -D 60 --new -l 600 -f 600 -D 100 &
    #echo -e $txtINFOende2
    #echo -e $txtINFOende2 >> $dateiLOGS
    # -Sicherung der Logdatei mit Zeitstempel anlegen:
    #fncLOGSkopieren
    
    #fncAusgabeDialogBeendet
    
    # -Die gespeicherten URLs löschen:
    #[[ -f "$dateiURLS" ]] && rm "$dateiURLS"
    

    # -Die Cache Datei mit dem flagCHECKurlsKOMPLETT Status löschen:
    if ( [[ -f "$dateiCACHEflagCHECKurlsKOMPLETT" ]] )
    then
        rm "$dateiCACHEflagCHECKurlsKOMPLETT"
    fi
    # -Die Cache Datei mit dem flagQUIT Status löschen:
    if ( [[ -f "$dateiCACHEflagQUIT" ]] )
    then
        rm "$dateiCACHEflagQUIT"
    fi
    # -Die Cache Datei mit den Playlist Infos löschen:
    if ( [[ -f "$dateiCACHEplsINFOS" ]] )
    then
        rm "$dateiCACHEplsINFOS"
    fi
    # -Die Cache Datei mit der Playlist Info Item löschen:
    if ( [[ -f "$dateiCACHEplsINFOSitem" ]] )
    then
        rm "$dateiCACHEplsINFOSitem"
    fi
    # -Die temporäre Logs Status Datei löschen:
    if ( [[ -f "$dateiLOGStmpSTATUS" ]] )
    then
        rm "$dateiLOGStmpSTATUS"
    fi
fi
# +++++ ENDE Endkontrolle und Status anzeigen +++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



#strPSalleTHREADSalleCHILDS=`ps -e -T | grep -i $$`
#echo -e "$strPSalleTHREADSalleCHILDS"


# echo -e "DEBUG: flagQUIT: $flagQUIT"
# echo -e "DEBUG: flagQUITpsTasteF: $flagQUITpsTasteF"
# echo -e "DEBUG: flagFEHLERlogs: $flagFEHLERlogs"


txtInfoDialogMenueEnde=""
#if ( [[ "$flagQUIT" == *truePS* ]] && [[ "$flagQUITpsTasteF" != "true" ]] && [[ "$flagFEHLERlogs" != "true" ]] )
if ( [[ "$checkBEFEHLreturn" == "0" ]] && [[ "$flagQUITpsTasteF" != "true" ]] && [[ "$flagFEHLERlogs" != "true" ]] && [[ "$FlagModusBefehlKOMPLETTquit" == "" ]] && [[ "$intANZaufrufeFEHLER" == "0" ]] )
then
    # -Den Benutzer mittels Dialog Fenster über das Beenden des Skripts informieren:
    fncAusgabeDialogBeendet
    
    # -Da keine Fehler festgestellt wurden, wird aufgeräumt und dann normal beendet.
    flagERFOLGREICHabgeschlossen="true"
    # -Die gespeicherten URLs löschen:
    [[ -f "$dateiURLS" ]] && rm "$dateiURLS"
else
    # -Den Benutzer mittels Dialog Fenster über das Beenden des Skripts informieren:
    txtInfoDialogMenueEnde="<br><br>Sie können jetzt mit den aktuellen Einstellungen direkt neu starten oder einfach das Skript beenden."
    fncAusgabeDialogBeendet
    # -Da Fehler aufgetreten sind, wird noch nicht aufgeräumt und stattdessen das
    #  ReadMenuEnde angezeigt: 
    # --Neustart ODER Logs anzeigen und beenden ODER direkt beenden.

    # -Nur wenn kein Shutdown gesetzt ist, wird das ReadMenuEnde angezeigt!
    if ( [[ "$intOFFminuten" == "" ]] )
    then
        fncEINGABEreadMENUende
    fi
fi



if ( [[ "$flagERFOLGREICHabgeschlossen" == "true" ]] )
then
    # -Nur wenn das Skript wirklich beendet wird:
    # --1. Zeilennummern in Logdatei einfügen: fncLOGSzeilennummern
    # --2. Fehlermeldungen am Ende der Logdatei zusammen fassen: fncLOGScheckFEHLER
    # --3. Sicherung der Logdatei mit Zeitstempel anlegen: fncLOGSkopieren
    
    # -Noch laufende Schreibzugriffe checken:
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncCHECKzugriffeLOGS\\t\\tSTART"
    fncCHECKzugriffeLOGS
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncCHECKzugriffeLOGS\\t\\tENDE"
    
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSzeilennummern\\t\\tSTART"
    fncLOGSzeilennummern
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSzeilennummern\\t\\tENDE"
    
    
    if ( [[ "$flagFEHLERlogs" == "true" ]] || [[ "$intANZaufrufeFEHLER" -gt "0" ]] )
    then
        #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGScheckFEHLER\\t\\tSTART"
        fncLOGScheckFEHLER "checkJA.auslesenJA"
        #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGScheckFEHLER\\t\\tENDE"    
        
        echo -e $txtFEHLERlogs >> $dateiLOGS
    fi
    
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSkopieren\\t\\tSTART"
    fncLOGSkopieren
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSkopieren\\t\\tENDE"
    
fi



# -Shutdown Option:
if ( [[ "$intOFFminuten" != "" ]] )
then
    fncShutdown
fi



# -DEBUG
#echo -e "--- DEBUG flagFEHLERlogs: $flagFEHLERlogs - flagERFOLGREICHabgeschlossen: $flagERFOLGREICHabgeschlossen"

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# ::::: ENDE While Kontrolle erfolgreich NEUSTART :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
done


`echo -e $strBEFEHLnachQUIT` || echo -e "|- Der letzte Befehl ($strBEFEHLnachQUIT) konnte nicht erfolgreich ausgeführt werden."

echo -e "|- $datei ($$) wurde beendet."

exit 0;











