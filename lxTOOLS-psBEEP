#!/bin/bash
# script von -lx-




# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------
# ----- ToDo:
#
# ----- Bugs:
#
# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------





function fncDEBUGstart {
    flagFNCdebug="true"
    #exec >`tty` 2>&1
    [ "$1" ] && txtDEBUGtitel="$1" || txtDEBUGtitel="$0"
    #echo -e "--------------------------------------------------------------------------------" && echo -e "---------- START Debug: $txtDEBUGtitel" && echo -e "--------------------------------------------------------------------------------"
    echo -e "--------------------------------------------------------------------------------"
    #echo -e "---------- START Debug: $txtDEBUGtitel"
    echo -e "--- [`fncHHMMSS 'norm.mS3'`] - START Debug: $txtDEBUGtitel"
    #export PS4='+ ${LINENO}:'`echo -en '\\t'`
    PS4='+ ${LINENO}:'`echo -en '\\t'`
    set -x
}

function fncDEBUGstop {
    #[ ! "$flagFNCdebug" ] && echo -e "--- FEHLER: fncDEBUGstop ohne vorher fncDEBUGstart aufzurufen!" && return
    [ ! "$flagFNCdebug" ] && return
    set +x
    [ "$1" ] && txtDEBUGtitel="$1" || txtDEBUGtitel="$0"
    #echo -e "--------------------------------------------------------------------------------" && echo -e "---------- ENDE Debug: $txtDEBUGtitel" && echo -e "--------------------------------------------------------------------------------"
    #echo -e "---------- ENDE Debug: $txtDEBUGtitel"
    echo -e "--- [`fncHHMMSS 'norm.mS3'`] - ENDE Debug: $txtDEBUGtitel"
    echo -e "--------------------------------------------------------------------------------"
    #exec >/dev/null 2>&1
}


dateiVERSION=""
function fncAUSLESENversion {
    [ -z $nutzer ] && nutzer=`ps --pid $$ -o user=` && [[ "$nutzer" == "root" ]] && nutzer=`id -un 1000`
    strVERZEICHNISbin="/home/$nutzer/bin-bak/"
    iaLSarray=(`ls -r $strVERZEICHNISbin$datei"_"* 2>/dev/null`)
    iaLSarrayANZAHL=${#iaLSarray[@]}
    dateiVERSIONkomplett=${iaLSarray[0]}
    # -Bis zum letzten Slash abschneiden:
    dateiVERSIONkomplett=${dateiVERSIONkomplett//*\//}
    # -Dateiname bis Unterstrich abschneiden:
    dateiVERSIONkomplett=${dateiVERSIONkomplett//`echo -e $datei`_/}
    # -Unterstrich bis zum Ende abschneiden:
    dateiVERSIONkomplett=${dateiVERSIONkomplett//_*/}
    
    dateiVERSION="($dateiVERSIONkomplett)"
    }


function fncANZAHLzeichen {
    # -Die Anzahl der Zeichen in $1 ermitteln und mittels echo ausgeben!
    [ ! "$1" ] && echo -e "0" && return
    echo -e "${#1}"
}

txtPLATZHALTER=""
function fncECHOplatzhalter {
    # -Die Anzahl der Zeichen in $1 ermitteln und damit eine Linie als
    #  PLATZHALTER erstellen!
    # -ZeichenRandUhrzeit: "|- [09:31:37] "
    # -Maximale Gesamtzeichenanzahl:
    #  intZZmax=intLayoutMaxSpalten-intAnzahlZeichenRandUhrzeit
    # -Am Ende werden $1 und $txtPLATZHALTER gemeinsam ausgegeben.
    #  --------------------------------------------------------------------------------
    txtPLATZHALTER=""
    txtLEERZEICHEN=""
    typeset -i intZZmax=0
    typeset -i intZZplatzhalter=0
    [ ! "$1" ] && intZZplatzhalter=$intZZmax
    
    # -WICHTIG: Der Platzhalter wird mit der maximalen Länge erstellt und in die Logdatei
    #  geschrieben. Bei der Ausgabe in den dynamischen Statuszeilen wird die Länge kontrolliert
    #  und ggf korrigiert. Siehe intSTATUSzeichenMAX.
    intZZmax=$intLayoutMaxSpalten
    
    #echo -e "${#1}"
    # -Damit zwischen $1 und $txtPLATZHALTER genau 1 Leerzeichen ist,
    #  wird das letzte Zeichen von $1 entsprechend ausgeschnitten und
    #  überprüft:
    [ "$1" ] && [ -n "${1: -1}" ] && txtLEERZEICHEN=" "
    [ "$1" ] && intZZplatzhalter=intZZmax-${#1}-${#txtLEERZEICHEN}
    # -Den Platzhalter mittels Schleife zusammenbauen:
    while ( [[ $intZZplatzhalter -gt 0 ]] )
    do
        txtPLATZHALTER=$txtPLATZHALTER"-"
        intZZplatzhalter=intZZplatzhalter-1
    done
    # -$1 und $PLATZHALTER direkt ausgeben:
    echo -e "$1""$txtLEERZEICHEN""$txtPLATZHALTER"
}








pfad="$1"
flag_update=$2
flag_aufruf_intern=$3
zeitSTARTutc=`date '+%s'`
zeitSTART=`date -d @$zeitSTARTutc`
zeitSTARTdateiname=`date -d @$zeitSTARTutc '+%F_%T'`
zeitSTARTdateiname=${zeitSTARTdateiname//\-/}
zeitSTARTdateiname=${zeitSTARTdateiname//:/}
zeitSTARTdateiname=${zeitSTARTdateiname//_/\-}
flagACTION="false"


fmtFETT=`tput bold`
fmtINVERS=`tput rev`
fmtUNTERSTRICHEN=`tput smul`

fmtCOLORfgBLAU=`tput setf 1`
fmtCOLORfgGRUEN=`tput setf 2`
fmtCOLORfgGELB=`tput setf 3`
fmtCOLORfgROT=`tput setf 4`
fmtCOLORbgBLAU=`tput setb 1`
fmtCOLORbgGRUEN=`tput setb 2`
fmtCOLORbgGELB=`tput setb 3`
fmtCOLORbgROT=`tput setb 4`

fmtRESET=`tput sgr0`


datei=${0//*\//}
[ ! $dateiVERSION ] && fncAUSLESENversion
#[ -z $dateiVERSION ] && echo -e "---heureka!---"
txtTITEL="Prozess überwachen und wenn beendet einen Sound abspielen!"
nutzer=`ps --pid $$ -o user=`

# -DEBUG-INFO:
# echo -e "--- zeitSTARTutc:\\t$zeitSTARTutc"
# echo -e "--- zeitSTART:\\t\\t$zeitSTART"
# echo -e "--- zeitSTARTdateiname:\\t$zeitSTARTdateiname"
# fncAUSLESENversion
# echo -e "--- DEBUG-INFO: Version: $dateiVERSION"



function fncHHMMSS {
    case "$1" in
        ( nurZAHLEN )
            echo -en `date '+%H%M%S'` ;;
        ( nurSS )
            echo -en `date '+%S'` ;;
        ( nurSS.S )
            echo -en `date '+%S.%N'` ;;
        ( nurSS.mS3 )
            HMSmS=`date '+%S.%N'`
            HMSxyz=${HMSmS//.*/}
            mSxyz=${HMSmS//*./}
            mSxyz=${mSxyz:0:3}
            echo -en $HMSxyz"."$mSxyz ;;
        ( norm.mS2 )
            HMSmS=`date '+%H:%M:%S.%N'`
            HMSxyz=${HMSmS//.*/}
            mSxyz=${HMSmS//*./}
            mSxyz=${mSxyz:0:2}
            echo -en $HMSxyz"."$mSxyz ;;
        ( norm.mS3 )
            HMSmS=`date '+%H:%M:%S.%N'`
            HMSxyz=${HMSmS//.*/}
            mSxyz=${HMSmS//*./}
            mSxyz=${mSxyz:0:3}
            echo -en $HMSxyz"."$mSxyz ;;
        (*)
            echo -en `date '+%H:%M:%S'` ;;
    esac
    #echo -en `date '+%H:%M:%S'`
}

function fncYEAR1231 {
    case "$1" in
        ( nurZAHLEN )
            echo -en `date '+%Y%m%d'`
            ;;
        ( YEAR )
            echo -en `date '+%Y'`
            ;;
        ( 12 )
            echo -en `date '+%m'`
            ;;
        ( 31 )
            echo -en `date '+%d'`
            ;;
        ( 1231 )
            echo -en `date '+%m%d'`
            ;;
        (*)
            echo -en `date '+%Y-%m-%d'`
            ;;
    esac
}


function getCPos {
    local v=() t=$(stty -g)
    stty -echo
    printf "\033[6n"
    IFS='[;' read -ra v -d R
    stty $t
    CPos=(${v[@]:1})
    CPosSPALTE=(${v[@]:2})
}

























# -------------------------------------------------------------------------------------------------------------
# ----- START Prozess Option --------------------------------------------------------------------------
arrPROZESSE=($datei youtube-dl ffmpeg wget cpulimit)


function fncKILLallePROZESSE {
    # -Alle Instanzen der genutzten Programme auslesen und beenden!
    # --WICHTIG: Nur im eigenen Terminal! Wenn $1==""
    # --WICHTIG: Nur im eigenen Terminal! Wenn $1=="EIGENESTTY"
    # --WICHTIG: Nur im eigenen Terminal! Wenn $1=="*"
    # --WICHTIG: In allen Terminals! Wenn $1=="ALLETTY"
    #
    for i in "${arrPROZESSE[@]}"
    do
        if ( [[ "$1" == "" ]] || [[ "$1" == "EIGENESTTY" ]] )
        then
            arrTERMINALS=`tty`
        elif ( [[ "$1" == "ALLETTY" ]] )
        then
            arrTERMINALS=(`ps -C $i -o tty=`)
        else
            arrTERMINALS=`tty`
        fi
        iTalle=""
        for iT in "${arrTERMINALS[@]}"
        do
            if ( [[ "$iTalle" != *$iT* ]] )
            then
                echo -e "- Prozess: $i"
                echo -e "- Terminal: "$iT

                ausgabe=`ps -ll --tty $iT | grep $i`
                if ( [[ "$ausgabe" != "" ]] )
                then
                    echo -e "$ausgabe"
                    echo -e "-"
                fi
                

                #strTERMINAL=`tty`
                #strTERMINAL="pts/5"
                strTERMINAL=$iT
                strLISTEtoKILL=""
                ausgabePIDs=""
                ausgabeCHILDPIDs=""
                #ausgabe=`lxPS -qs $i`
                #ausgabe=`ps -All --tty "/dev/pts/5" | grep $1`
                ausgabeLISTEdisplay=`ps --tty $strTERMINAL -o pid=`
                ausgabeLISTEname=`ps -C $i -o pid=`
                #ausgabeLISTEkombiniert=`ps --tty $strTERMINAL -l | grep $i`
                #ausgabeLISTEkombiniert=`ps --tty "pts/5" -l | grep $i`
                ausgabeLISTEkombiniert=`ps --tty $strTERMINAL -o pid= -o tty= -o comm= | grep $i`
                arrLISTEpid=($ausgabeLISTEkombiniert)
                #echo -e "- Kombiniert: "$ausgabeLISTEkombiniert
                
                typeset -i zL=0
                echo -e "- PIDs:"
                #while ( [[ "${arrLISTEpid[$zL]}" != "" ]] && [[ "${arrLISTEpid[$zL]}" != "$$" ]] )
                while ( [[ "${arrLISTEpid[$zL]}" != "" ]] )
                do
                    ausgabePIDsTMP="${arrLISTEpid[$zL]}"
                    echo -en "- PID: "$ausgabePIDsTMP
                    if ( [[ "$ausgabePIDsTMP" == "$$" ]] )
                    then
                        #continue
                        flagEIGENEpsid="true"
                    fi
                    if ( [[ "$ausgabePIDsTMP" != "" ]] && [[ "$ausgabePIDsTMP" != "$$" ]] )
                    then
                        if ( [[ "$strLISTEtoKILL" == "" ]] )
                        then
                            strLISTEtoKILL=$ausgabePIDsTMP
                        else
                            strLISTEtoKILL=$strLISTEtoKILL" "$ausgabePIDsTMP
                        fi
                    fi
                    ausgabeCHILDPIDsTMP=`ps --ppid ${arrLISTEpid[$zL]} -o pid=`
                    if ( [[ $ausgabeCHILDPIDsTMP != "" ]] )
                    then
                        echo -en " CPIDs: "$ausgabeCHILDPIDsTMP" --- "
                        strLISTEtoKILL=$strLISTEtoKILL" "$ausgabeCHILDPIDsTMP
                    fi
                    zL=zL+3
                done
                echo -e "\\n---"

                if ( [[ "$ausgabeLISTEkombiniert" != "" ]] )
                then
                    #echo -e "- PIDs: "$ausgabePIDs
                    #echo -e "- CPIDs:"$ausgabeCHILDPIDs
                    if ( [[ "$strLISTEtoKILL" != "" ]] )
                    then
                        #echo -e "kill -9 oder -14... "$strLISTEtoKILL
                        #kill -9 $ausgabePIDs $ausgabeCHILDPIDs
                        #echo -e "- Komplette Liste:"\\n$strLISTEtoKILL\\n"---"
                        
                        # -Doppelte PIDs in der Liste führen zu unnötigen Fehlermeldungen, daher
                        #  werden diese erkannt und entfernt!
                        echo -e "- Komplette Liste (bereinigt):"
                        arrLISTEtoKILL=($strLISTEtoKILL)
                        typeset -i zLK=0
                        strLISTEpidBENUTZT=""
                        flagLISTEtoKILLfertig="false"
                        while ( [[ "${arrLISTEtoKILL[$zLK]}" != "" ]] )
                        do
                            if ( [[ "$strLISTEpidBENUTZT" != *${arrLISTEtoKILL[$zLK]}* ]] && [[ `ps -p ${arrLISTEtoKILL[$zLK]} | grep ${arrLISTEtoKILL[$zLK]}` != "" ]] )
                            then
                                strLISTEpidBENUTZT=$strLISTEpidBENUTZT" "${arrLISTEtoKILL[$zLK]}
                                echo -en "${arrLISTEtoKILL[$zLK]} "
                                flagLISTEtoKILLfertig="true"
                            fi
                            zLK=zLK+1
                        done
                        echo -e \\b
                        if ( [[ "$flagLISTEtoKILLfertig" == "true" ]] )
                        then
                            echo -e "- Der Kill Befehl:"\\n"'kill -9 $strLISTEpidBENUTZT'"
                            kill -9 $strLISTEpidBENUTZT 2>/dev/null
                        else
                            echo -e "- INFO: Die Prozesse wurden bereits beendet!"
                        fi
                    else
                        echo -e "- INFO: Keine Prozesse zum Beenden gefunden!"
                    fi
                else
                    echo -e "- INFO: $i wurde nicht in der Prozessliste gefunden!"
                fi
                echo -e "-"

            fi
            iTalle=$iTalle" "$iT
        done
    done
}

#fncKILLallePROZESSE "EIGENESTTY"
#fncKILLallePROZESSE "ALLETTY"



if ( [[ "$1" == "-PS" ]] )
then
    echo -e "-"\\n"--- Alle Prozesse in allen Terminals anzeigen: ----------------------------------------------------"\\n"-"
    for i in "${arrPROZESSE[@]}"
    do
        echo -e "- Prozess: $i"
        ausgabe=`lxPS -qs $i`
        if ( [[ "$ausgabe" != "" ]] )
        then
            echo -e "$ausgabe"
        else
            echo -e "- INFO: $i wurde nicht in der Prozessliste gefunden!"
        fi
        echo -e "-"
    done
    exit 0;
fi

if ( [[ "$1" == "-PSK" ]] )
then
    echo -e "-"\\n"--- Alle Prozesse im eigenen Terminal anzeigen und beenden (kill): --------------------------------"\\n"-"
    fncKILLallePROZESSE "EIGENESTTY"
#     for i in "${arrPROZESSE[@]}"
#     do
#         echo -e "- Prozess: $i:"
#         ausgabe=`lxPS -qs $i`
#         if ( [[ "$ausgabe" != "" ]] )
#         then
#             echo -e "$ausgabe"
#             ausgabePIDs=`lxPS -qpid $i`
#             ausgabePIDs=${ausgabePIDs//$$/}
#             ausgabeCHILDPIDs=""
#             for ii in $ausgabePIDs
#             do
#                 nix=1
#                 #echo -e "- PIDs: "$ii
#                 #ps -ppid $ii -o pid=
#                 ausgabeCHILDPIDsTMP=`ps --ppid $ii -o pid=`
#                 ausgabeCHILDPIDs=$ausgabeCHILDPIDs" "$ausgabeCHILDPIDsTMP
#             done
#             #echo -e "- PIDs: "$ausgabePIDs
#             #echo -e "- CPIDs:"$ausgabeCHILDPIDs
#             if ( [[ "$ausgabePIDs" != "" ]] )
#             then
#                 echo -e "- kill -9 "$ausgabePIDs $ausgabeCHILDPIDs
#                 kill -9 $ausgabePIDs $ausgabeCHILDPIDs
#             else
#                 echo -e "- INFO: Keine Prozesse zum Beenden gefunden!"
#             fi
#         else
#             echo -e "- INFO: $i wurde nicht in der Prozessliste gefunden!"
#         fi
#         echo -e "-"
#     done
    exit 0;
fi

if ( [[ "$1" == "-PSKA" ]] )
then
    echo -e "-"\\n"--- Alle Prozesse in allen Terminals anzeigen und beenden (kill): ---------------------------------"\\n"-"
    fncKILLallePROZESSE "ALLETTY"
    exit 0;
fi
# ----- ENDE Prozess Option ---------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------







# -die Namen der Dateien zum Zwischenspeichern und Loggen festlegen:
dateiCONF="/home/$nutzer/bin/$datei.conf"
dateiURLS="00_$datei.URLS.txt"
dateiURLSfav="00_$datei.URLS.FAV.txt"
dateiLOGS="00_$datei.LOGS.txt"
dateiLOGStmp="00_$datei.LOGS.txt.tmp"










# 
# 
# # -Nur Starten wenn NICHT:
# # --Logs, Hilfe, ShortcutCD
# if ( [[ "$1" != -*l* ]] && [[ "$1" != -*h* ]] && [[ "$1" != -*scl* ]] && [[ "$1" != -*sccd* ]] && [[ "$1" != -*conf* ]] )
# then
#     # -Wegen Unterschieden beim Auslesen der aktuellen Cursorposition, wird clear
#     #  aufgerufen. Wenn die aktuelle Cursorposition in der untersten Zeile wäre, würde
#     #  ansonsten die getCPos Funktion nicht korrekt arbeiten!
#     #echo -e "...clear screen..."
#     clear -x
# fi
# 
# 






function fncAUSGABEstandard {
    # -Gibt '(Standard)' aus, wenn $1 dem STANDARD $2 entspricht!
    [[ "$1" == "" ]] && echo -e "(Argumente nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$2" == "" ]] && echo -e "(Argument nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$1" == "$2" ]] && echo -e " (Standard)"
}

function fncAUSGABEstandardONOFF {
    # -Gibt 'on' aus, wenn $1 dem STANDARD $2 entspricht, ansonsten 'off'
    [[ "$1" == "" ]] && echo -e "(Argumente nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$2" == "" ]] && echo -e "(Argument nicht angegeben: fncAUSGABEstandard)" && return
    [[ "$1" == "$2" ]] && echo -e "on" && return
    [[ "$1" != "$2" ]] && echo -e "off" && return
}





typeset -i intLayoutMaxSpalten=0
typeset -i intLayoutMaxSpaltenVorgabe=120
function fncLayoutMaxSpalten {
    # -Den Anzeigebereich des eigenen Layouts auf 80% der vorhandenen Bildschirmbreite
    #  begrenzen: ($zSPALTEN/10)*8
    
    typeset -i zZEILEN=$LINES
    typeset -i zSPALTEN=$COLUMNS

    intLayoutMaxSpaltenSCALE1=`echo -e "scale=1 ; ($zSPALTEN/10)*8" | bc -l`
    intLayoutMaxSpalten=${intLayoutMaxSpaltenSCALE1//\.*/}
    [ "$intLayoutMaxSpalten" -le 0 ] && intLayoutMaxSpalten=$intLayoutMaxSpaltenVorgabe
}
fncLayoutMaxSpalten




function fncAusgabeHRMaxSpalten {
    # -HRMaxSpalten erstellen und ausgeben!
    # -Argumente:
    # --$1: Die Zeichen mit denen die Linie anfangen soll.
    # --$2: Das Zeichen mit dem die Linie gefüllt wird.
    # -Werden keine Argumente übergeben, wird Standard genutzt:
    txtHRAnfang="|"
    txtHRFuellen="-"
    
    typeset -i zHRAnfang=0
    typeset -i zHRFuellen=0
    typeset -i zHRMaxSpalten=0
    
    [ $1 ] && txtHRAnfang="$1"
    zHRAnfang=${#txtHRAnfang}
    [ $2 ] && txtHRFuellen="$2"
    zHRFuellen=${#txtHRFuellen}
    
    txtHRMaxSpalten="$txtHRAnfang""$txtHRFuellen"
    zHRMaxSpalten=intLayoutMaxSpalten-zHRAnfang-zHRFuellen
    for ((zHR=0; zHR<$zHRMaxSpalten; zHR++))
    do
        #echo -en "$zzHR - "
        txtHRMaxSpalten="$txtHRMaxSpalten""$txtHRFuellen"
    done
    echo -e "\\r$txtHRMaxSpalten"
}



function fncLayoutHRFullScreen {
    # -Fullscreen HR erstellen und in $txtHRFullScreen speichern.
    # -Argumente:
    # --$1: txtHRFullScreenANFANG
    # --$2: txtHRFullScreenENDE
    
    typeset -i zZEILEN=$LINES
    typeset -i zSPALTEN=$COLUMNS
    typeset -i zHRanfang=0
    typeset -i zHRmitte=0
    typeset -i zHRende=0
    typeset -i zzHR=0
    
    txtHRFullScreenANFANG="|- $datei "
    #txtHRFullScreenANFANG="|"
    [ $1 ] && txtHRFullScreenANFANG="$1"
    zHRanfang=${#txtHRFullScreenANFANG}
    
    #txtHRFullScreenENDE=" $datei -|"
    txtHRFullScreenENDE="|"
    [ $2 ] && txtHRFullScreenENDE="$2"
    zHRende=${#txtHRFullScreenENDE}
    
    txtHRFullScreenMITTE=""
    zHRmitte=zSPALTEN-zHRanfang-zHRende
    for ((zzHR=0; zzHR<$zHRmitte; zzHR++))
    do
        #echo -en "$zzHR - "
        txtHRFullScreenMITTE="$txtHRFullScreenMITTE""-"
    done
    txtHRFullScreen="$txtHRFullScreenANFANG""$txtHRFullScreenMITTE""$txtHRFullScreenENDE"
    #echo -e "\\r$txtHRFullScreen"
}
fncLayoutHRFullScreen




#txtHR="|--------------------------------------------------------------------------------"
txtHR="`fncAusgabeHRMaxSpalten`"

txtKOPF=\
"$txtHR"\\n\
"|- $datei $dateiVERSION -| "

txtKOPFlogs=$txtKOPF"Logdatei"\\n\
"$txtHR"\\n\
"|- $zeitSTART"\\n\
"|-"

txtKOPF=$txtKOPF$txtTITEL\\n\
"$txtHR"\\n\
"|- $zeitSTART"\\n\
"|-"





txtBENUTZUNG=\
"Benutzung:"\\n\
"|- '$datei [OPTIONEN] [PID]'"\\n\
"|-"

txtHILFE=$txtBENUTZUNG\\n\
"|- Hinweise zur Benutzung:"\\n\
"|- -Eine PID muss angegeben werden und Optionen müssen immer mit '-' anfangen."\\n\
"|-"\\n\
"|- Optionen:"\\n\
"|- -h\\tDiesen Hilfetext anzeigen. Andere Optionen werden ignoriert."\\n\
"|-"

txtFEHLERargument=\\n\
"|- FEHLER:\\tKein zulässiges Argument übergeben. - Es könnte Panik entstehen!"\\n\
"|-\\t\\tWeitere Hilfe erhalten Sie mit '-h'!"\\n\
"|-"

txtENDEzeit=\
"|-"\\n\
"|-"\\n\
"|- Start:\\t$zeitSTART"\\n\
"|- Ende: \\t"


VORLAGEtxtFEHLER=\\n\
"|- FEHLER:\\tKeinPiePaPo..."\\n\
"|-\\t\\tNoch immer KeinPiePaPo..."\\n\
"|-\\t\\tWeitere Hilfe erhalten Sie mit '-h'!"\\n\
"|-"


# SHORTCUT
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START function $datei.conf auslesen ++++++++++++++++++++++++++++
function fncDATEIconfAUSLESEN {
    # -Wenn der richtige Schlüssel gefunden wurde, wird der entsprechende
    #  Wert ausgelesen und einer Variablen zugewiesen:
    eingabeURLkontrolle=$eingabeURL
    flagURLconf="false"
    flagSCglobalGEFUNDEN="false"
    while read txtDATEIconf
    do
        # -Kommentare und leere Zeilen ignorieren:
        if ( [[ "$txtDATEIconf" == \#* ]] || [[ "$txtDATEIconf" == "" ]] )
        then
            continue
        fi
        
        # -URL Shortcut auslesen:
        if ( [[ "$eingabeSCurl" != "" ]] && [[ "$txtDATEIconf" == url:$eingabeURL=* ]] )
        then
            #echo -e "--- Shortcut URL: $txtDATEIconf"
            eingabeURL=${txtDATEIconf//url:$eingabeURL=/}
            flagURLconf="true"
            break
        fi
        
        # -GLOBALEN Shortcut auslesen:
        if ( [[ "$eingabeSC" != "" ]] && [[ "$txtDATEIconf" == $eingabeSC* ]] )
        then
            #echo -e "--- Shortcut GLOBAL: $txtDATEIconf"
            arrSHORTCUT=($txtDATEIconf)
            arrSHORTCUTsc=${arrSHORTCUT[0]}
            arrSHORTCUTverzeichnis=${arrSHORTCUT[1]}
            arrSHORTCUTverzeichnisAUSWAHL=${arrSHORTCUT[2]}
            arrSHORTCUTquiet=${arrSHORTCUT[3]}
            if ( [[ "$arrSHORTCUTquiet" != "quietNEIN" ]] )
            then
                if ( [[ "$arrSHORTCUTquiet" == "quietQ" ]] )
                then
                    strg1=$strg1"q"
                fi
                if ( [[ "$arrSHORTCUTquiet" == "quietQQ" ]] )
                then
                    strg1=$strg1"qq"
                fi
                if ( [[ "$arrSHORTCUTquiet" == "quietQQQ" ]] )
                then
                    strg1=$strg1"qqq"
                fi
            fi
            if ( [[ "$arrSHORTCUTsc" != "$eingabeSC" ]] )
            then
                flagSCglobalGEFUNDEN="false"
                continue
            else
                flagSCglobalGEFUNDEN="true"
                if ( [[ "${#arrSHORTCUT[*]}" -gt 4 ]] )
                then
                    # -URLs einlesen:
                    for i in "${arrSHORTCUT[@]}"
                    do
                        if ( [[ "$i" == http*:\/\/* ]] )
                        then
                            if ( [[ "$arrSHORTCUTurl" == "" ]] )
                            then
                                arrSHORTCUTurl="$i"
                                continue
                            fi
                            arrSHORTCUTurl="$arrSHORTCUTurl $i"
                        fi
                    done
                    #eingabeURL=$arrSHORTCUTurl
                fi
                #echo -e "--- $arrSHORTCUTsc - $arrSHORTCUTverzeichnis - $arrSHORTCUTverzeichnisAUSWAHL - $arrSHORTCUTurl"
                break
            fi
            #echo -e "--- $arrSHORTCUTsc - $arrSHORTCUTverzeichnis - $arrSHORTCUTverzeichnisAUSWAHL - $arrSHORTCUTurl"
            #exit 0;
        fi
    done < $dateiCONF
    
    # -Shortcut konnte nicht gefunden werden:
    if ( [[ "$eingabeSC" != "" ]] && [[ "$flagSCglobalGEFUNDEN" == "false" ]] )
    then
        echo -e $txtKOPF
        echo -e "|- Der von Ihnen angegebene Shortcut '$eingabeSC' konnte in der Konfigurationsdatei"
        echo -e "|- nicht gefunden werden. Bitte kontrollieren Sie Ihre Eingabe!"
        echo -e "|- Weitere Hilfe erhalten Sie mit '-h'!"
        echo -e "|- "
        exit 2;
    fi
}
# +++++ ENDE function $datei.conf auslesen ++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------
function fncAUSGABEstdoutUNDlogdatei () {
    # -Erwartet einen String zum Ausgeben: $1
    # --Ausgabe am Bildschirm
    # --Ausgabe in die Logdatei
    if ( [[ "$1" != "" ]] )
    then
        echo -e "$1"
        echo -e "$1" >> $dateiLOGS
    fi
}

function fncECHOlx () {
    # -Erwartet einen String zum Ausgeben: $1
    # --Ausgabe am Bildschirm
    # --Ausgabe in die Logdatei
    if ( [[ "$1" != "" ]] )
    then
        echo -e "$1"
        echo -e "$1" >> $dateiLOGS
    fi
}
# ---------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------





echo -e "|-"
echo -e "|- Zeit: "`fncHHMMSS norm.mS2`

checkProzessInfo="$1"
checkProzessInfoPID=""
checkProzessInfoName=""
flagFehlerCheckProzess="true"

#while ( [[ `ps -p $checkProzessInfo 2>/dev/null | grep $checkProzessInfo` != "" ]] || [[ `ps -C $checkProzessInfo 2>/dev/null | grep $checkProzessInfo` != "" ]] )

[[ `ps -p $checkProzessInfo 2>/dev/null | grep $checkProzessInfo` != "" ]] && checkProzessInfoName="`ps -p $checkProzessInfo -o comm= 2>/dev/null`"
[[ `ps -C $checkProzessInfo 2>/dev/null | grep $checkProzessInfo` != "" ]] && checkProzessInfoPID="`ps -C $checkProzessInfo -o pid= 2>/dev/null`"

[[ -z "$checkProzessInfoPID" ]] && [[ -z "$checkProzessInfoName" ]] && echo -e "|- FEHLER:"\\t"Es konnte kein entsprechender Prozess gefunden werden, der zu Ihrer"\\n"|-"\\t\\t"Eingabe '$checkProzessInfo' gepasst hätte."\\n"|-" && exit 0;

[[ -z "$checkProzessInfoName" ]] && checkProzessInfoName="$checkProzessInfo"
[[ -z "$checkProzessInfoPID" ]] && checkProzessInfoPID="$checkProzessInfo"

[[ "${checkProzessInfoPID:0:1}" == " " ]] && checkProzessInfoPID="${checkProzessInfoPID:1}"


echo -en "|- INFO: Der Prozess $checkProzessInfoName (PID:$checkProzessInfoPID) wird überwacht!"
getCPos
typeset -i intCPosSPALTE="$CPosSPALTE"
intCPosSPALTE=intCPosSPALTE-1

while ( [[ `ps -p $checkProzessInfo 2>/dev/null | grep $checkProzessInfo` != "" ]] || [[ `ps -C $checkProzessInfo 2>/dev/null | grep $checkProzessInfo` != "" ]] )
do
    tput cup $CPos $intCPosSPALTE
    sleep 0.8
    echo -en "."
    sleep 0.8
    echo -en "."
    sleep 0.7
    echo -en "."
    sleep 0.6
    echo -en "."
    sleep 0.5
    echo -en "."
    sleep 0.4
    echo -en "."
    sleep 0.3
    echo -en "."
    sleep 0.2
    echo -en "."
    sleep 0.1
    echo -en "."
    sleep 0.1
    echo -en "."
    sleep 0.2
    tput cup $CPos $intCPosSPALTE
    echo -en "          "
    tput cup $CPos $intCPosSPALTE
    #sleep 0.1
    flagFehlerCheckProzess="false"
done

echo -en \\n

#[[ "$flagFehlerCheckProzess" == "true" ]] && echo -e "|- FEHLER:"\\t"Es konnte kein entsprechender Prozess gefunden werden, der zu Ihrer"\\n"|-"\\t\\t"Eingabe '$checkProzessInfo' gepasst hätte." && exit 0;

txtInfoProzessBeendet="Der Prozess $checkProzessInfoName (PID:$checkProzessInfoPID) wurde soeben beendet!"
echo -e "|-"
echo -e "|- Zeit: "`fncHHMMSS norm.mS2`
echo -e "|- INFO: $txtInfoProzessBeendet"
echo -e "|-"



kdialog --title "$datei" --msgbox " --- <b>$datei.Info:</b> --- <br><br>$txtInfoProzessBeendet<br><br>Zeit: `fncHHMMSS 'norm.mS2'` - PID: $$" >/dev/null 2>&1 &



# -Erfolgreich Sound:
#beep -l 200 -f 600 -r 2 -D 100 --new -l 600 -f 600 -D 100
ffplay -autoexit -nodisp -hide_banner -loglevel quiet -loop 1 /usr/share/sounds/Oxygen-Sys-Warning.ogg >/dev/null 2>&1
ffplay -autoexit -nodisp -hide_banner -loglevel quiet -loop 3 /usr/share/sounds/Oxygen-Sys-App-Positive.ogg >/dev/null 2>&1



exit 0;





























strg1="-"
strg2="-"
strg3="-"
flagSCglobal="false"
flagMORE="false"
flagVERZEICHNISauswahl="false"
flagForceArgument="false"
flagForceGlobal="false"

befehlAUSGABEmore=""
# -Die Argumente kontrollieren und neu aufteilen:
# --ALLE normalen Optionen (-q,-h,...) werden im $strg1 gespeichert
# --die Shutdown Optionen (-off...) werden im $strg2 gespeichert
#for i in $*
for i in "$@"
do
    eingabeSC=""
    eingabeSCurl=""
    if ( [[ "$flagSCglobal" == "true" ]] )
    then
        # -Prüfen ob globaler Shortcut in der $datei.conf steht:
        #eingabeURL=${i//\-/}
        #eingabeURL=${i//\-url=/}
        #echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL"
        eingabeSC=$i
        if ( [[ "$eingabeSC" != "" ]] )
        then
            fncDATEIconfAUSLESEN
        fi
        #continue
    fi
    if ( [[ "$i" == -sc ]] || [[ "$i" == -sccd ]] || [[ "$i" == -scl* ]] || [[ "$i" == -scq* ]] )
    then
        flagSCglobal="true"
        strg1=$strg1${i//\-/}
        #continue
    fi
    if ( [[ "$i" == -*M ]] )
    then
        flagMORE="true"
        #befehlAUSGABEmore="| more"
        #befehlAUSGABEmore="echo -e $befehlAUSGABEmore"
        #befehlAUSGABEmore="echo -e more"
        #befehlAUSGABEmore="| $befehlAUSGABEmore"
    fi
    if ( [[ "$i" == -cd* ]] )
    then
        flagVERZEICHNISauswahl="true"
    fi
done
for i in "$@"
do
    if ( [[ "$i" == -*conf* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"conf"
        break
    fi
    
    if ( [[ "$i" == -*f* ]] && [[ "$i" != -off* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"f"
        flagForceArgument="true"
        flagForceGlobal="true"
        #echo -e "|- \"$i\" * einzel Vergleich: -f gesetzt"
    fi
    if ( [[ "$i" == -*h* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"h"
    fi
    if ( [[ "$i" == -*hc* ]] && [[ "$i" != -url* ]] )
    then
        strg1=$strg1"c"
    fi
    if ( [[ "$i" == -*l* ]] && [[ "$i" != -url* ]] )
    then
        if ( [[ "$i" == -*l\?* ]] )
        then
            strg1=$strg1"l?"
        elif ( [[ "$i" == -*scl* ]] )
        then
            strg1=$strg1"scl"
        else
            strg1=$strg1"l"
        fi
    fi
    if ( [[ "$i" == -*q* ]] )
    then
        # -Die Quietoptionen aus dem Befehlsaufruf sind mächtiiger als die Quietoptionen
        #  aus den Shortcuts in der Konfigurationsdatei!        
        # --Da die Shortcut Optionen bereits gesetzt sind, werden Sie komplett entfernt.
        # --Auslesen der aktuellen Quietoptionen aus dem Befehlsaufruf.
        strg1=${strg1//q/}
        strg1TMP=$strg1
        strg1=$strg1"q"
    fi
    if ( [[ "$i" == -*qq* ]] )
    then
        strg1=$strg1"q"
    fi
    if ( [[ "$i" == -*qqq* ]] )
    then
        strg1=$strg1"q"
    fi
    if ( [[ "$i" == "-off" ]] )
    then
        strg2=$strg2"off"
        #echo -e "|- \"$i\" * einzel Vergleich: -off gesetzt"
    elif ( [[ "$i" == -off=* ]] )
    then
        #echo -e "|- \"$i\" * einzel Vergleich: -off=* gesetzt"
        intOFFminuten=${i//*=/}
        #echo -e "|- \"$intOFFminuten\" * einzel Vergleich: intOFFminuten"
        strg2=$strg2"off="$intOFFminuten
    elif ( [[ "$i" == -off* ]] )
    then
        #echo -e "|- \"$i\" * einzel Vergleich: FEHLER -off* gesetzt"
        strg2=""
    elif ( [[ "$i" != -* ]] )
    then
        #echo -e "|- \"$i\" * einzel Vergleich: FEHLER kein gültiges Argument"
        flagFEHLERargument="true"
    fi
    if ( [[ "$i" == -url=* ]] )
    then        
        # -Prüfen ob Shortcut in der $datei.conf steht, falls nicht wird die Eingabe einfach
        #  als URL übernommen!
        #eingabeURL=${i//\-/}
        eingabeURL=${i//\-url=/}
        #echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL"
        eingabeSCurl=$i
        if ( [[ "$eingabeURL" != *.* ]] )
        then
            fncDATEIconfAUSLESEN
        fi
        if ( [[ "$flagURLconf" != "true" ]] )
        then
            # -Eingabe ist normale URL:
            eingabeURL=${i//\-url=/}
            eingabeURL=${eingabeURL//\&/aaaUNDaaa}
            if ( [[ "$eingabeURL" != http*:\/\/* ]] )
            then
                eingabeURL="http://"$eingabeURL
                #echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL"
            fi
            #eingabeURL=${eingabeURL//aaaUNDaaa/\&}
        fi
    fi
    if ( [[ "$i" == http*:\/\/* ]] )
    then
        eingabeURL="$eingabeURL $i"
        #echo -e "|- DEBUG-INFO:\\n|- eingabeURL mit i: $eingabeURL"
    fi
done



# -Den Inhalt des im Shortcut gespeicherten Verzeichnisses $arrSHORTCUTverzeichnis anzeigen!
if ( [[ "$strg1" == -*scls* ]] )
then
    if ( [[ "$arrSHORTCUTverzeichnis" != "" ]] )
    then
        # -In das Verzeichnis wechseln, den Inhalt auflisten, zurück in das ursprüngliche Verzeichnis wechseln
        #  und beenden.
        strVERZEICHNISaktuell=`pwd`
        cd $arrSHORTCUTverzeichnis
        xls
        cd $strVERZEICHNISaktuell
        exit 0;

    else
        echo -e $txtKOPF
        echo -e "|- Der Shortcut '$eingabeSC' wurde in der Konfigurationsdatei gefunden, aber der"
        echo -e "|- Eintrag enthält kein Arbeitsverzeichnis. Bitte kontrollieren Sie Ihre Eingabe"
        echo -e "|- und die Daten in der Konfigurationsdatei!"
        echo -e "|- Weitere Hilfe erhalten Sie mit '-h'!"
        echo -e "|- "
        exit 2;
    fi
fi




# -Das aktuelle Arbeitsverzeichnis in der Konsole abändern zu dem Verzeichnis
#  das im Shortcut gespeichert ist: $arrSHORTCUTverzeichnis
if ( [[ "$strg1" == -*sccd* ]] )
then
    if ( [[ "$arrSHORTCUTverzeichnis" != "" ]] )
    then
        # -Ein cd innerhalb eines Skripts wirkt sich nicht auf die Umgebung des Skripts aus!!!
        # --xcd funktioniert!
        # --Allerdings fehlt der Befehlsverlauf, da eine neue Shell gestartet wird.
        xcd $arrSHORTCUTverzeichnis
        exit 0;

        # --"cd WunschVerzeichnis..." wird in lxcd Skript geschrieben, lxcd muss ausführbar sein,
        #   das Hauptskript wird geschlossen mit dem Hinweis, dass lxcd der richtige Befehl ist!
        #echo -e "xcd $arrSHORTCUTverzeichnis" > /home/lx21/bin/lxcd
        #chmod a+x /home/lx21/bin/lxcd
        #echo -e "--- Bitte starten sie 'lxcd'!"        
        #exit 0;
    else
        echo -e $txtKOPF
        echo -e "|- Der Shortcut '$eingabeSC' wurde in der Konfigurationsdatei gefunden, aber der"
        echo -e "|- Eintrag enthält kein Arbeitsverzeichnis. Bitte kontrollieren Sie Ihre Eingabe"
        echo -e "|- und die Daten in der Konfigurationsdatei!"
        echo -e "|- Weitere Hilfe erhalten Sie mit '-h'!"
        echo -e "|- "
        exit 2;
    fi
fi





# echo -e "|- DEBUG-INFO: Ausgabe der String Variablen:"
# echo -e "|- DEBUG-INFO: *: $*"
# echo -e "|- DEBUG-INFO: strg1: $strg1 - strg1TMP: $strg1TMP --- strg2: $strg2 --- arrSHORTCUTsc: $arrSHORTCUTsc"
# echo -e "|- DEBUG-INFO:\\n|- eingabeURL: $eingabeURL\\n|- eingabeURLneu: ${eingabeURL//aaaUNDaaa/\&}"
# exit 0;




# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# -Sonderfälle UPDATE, AUFRUF_INTERN, -q, -h, -l
if ( [[ "$flag_update" != "true" ]] && [[ "$flag_aufruf_intern" != "true" ]] && [[ "$strg1" != -*q* ]] && [[ "$strg1" != -*h* ]] && [[ "$strg1" != -*l* ]] && [[ "$strg1" != -*sccd* ]] && [[ "$strg1" != -*conf* ]] )
then
    # -Die Sicherheitsfrage:
    # --1. Argument: die Vorbelegung: WEITER oder ABBRECHEN
    # --2. Argument: die Datei die gestartet werden soll
    # --3. Argument: der Titel der Datei die gestartet werden soll
    flagSICHERHEITSFRAGE=`/home/lx21/bin/zz_inc_sicherheitsfrage.sh "WEITER" "$datei" "$txtTITEL"`
    flagSICHERHEITSFRAGE=$?
    # -Wenn der Rückgabewert nicht 0 ist, wurde entweder abgebrochen oder es gab einen Fehler!
    if ( [[ "$flagSICHERHEITSFRAGE" != "0" ]] )
    then
        # -Die Sicherheitsfrage beendet das Skript!
        #echo -e "--- Sicherheitsfrage: $flagSICHERHEITSFRAGE"
        exit 1;
    fi
fi
# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------





# -Einbindung einer Verlauf Datei:
# --im übergeordneten Ordner nach Verlauf suchen und wenn vorhanden einlesen
# --Verlauf als Liste (radio oder check) zur URL Auswahl anbieten, wenn keine Auswahl
#   erfolgt wird inputbox geöffnet, ansonsten geht es direkt zur Formatauswahl
# --nach der URL Eingabe diese im Verlauf speichern
# # +++++ START Config auslesen
# while read txtCONFIG
# do
#     #nix=1
#     if ( [[ "$txtCONFIG" == --download-archiv* ]] )
#     then
#         archivORIGINAL=${txtCONFIG//\-\-download\-archiv /}
#         #echo $archivORIGINAL
#         break
#     fi
# done < ~/.config/youtube-dl/config
# # +++++ ENDE Config auslesen
# 
# # +++++ START archivTMP anhängen an archivORIGINAL
# while read txtTMP
# do
#     echo $txtTMP >> $archivORIGINAL
# done < $archivTMP
# # +++++ ENDE archivTMP anhängen an archivORIGINAL













# -Die Konfigurationsdatei anzeigen:
# --$dateiCONF
if ( [[ "$strg1" == -*hc* ]] )
then
    echo -e $txtHR\\n"|- Ausgabe $dateiCONF"\\t"-START-"\\n$txtHR
    cat $dateiCONF
    echo -e $txtHR\\n"|- Ausgabe $dateiCONF"\\t"-ENDE-"\\n$txtHR
    exit 0;
fi


# -Die Konfigurationsdatei bearbeiten:
# --$dateiCONF
if ( [[ "$strg1" == -*conf* ]] )
then
    echo -e $txtHR\\n"|- Bearbeiten $dateiCONF"\\t"-START-"\\n$txtHR
    #cat $dateiCONF
    echo -e "|- Sicherung der Konfigurationsdatei erstellen..."\\n"|-"
    #stsCONFcp=`cp $dateiCONF /home/$nutzer/bin/testCP/$datei.conf.bak.$zeitSTARTdateiname`
    cp $dateiCONF $dateiCONF.bak.$zeitSTARTdateiname 1>/dev/null 2>&1
    stsCONFcp=$?
    sleep 0.5
    if ( [[ "$stsCONFcp" -gt "0" ]] )
    then
        echo -e "|- Sicherung konnte nicht erstellt werden! Bitte prüfen Sie die Zugriffsrechte innerhalb"
        echo -e "|- des Zielordners und Ihre eigenen Benutzerrechte. Das Skript wird jetzt beendet."\\n"|-"
        exit 1;
    else
        echo -e "|- Sicherung erfolgreich erstellt!"
        echo -e "|- Dateiname: $datei.conf.bak.$zeitSTARTdateiname"\\n"|-"
    fi
    
    echo -e "|- Konfigurationsdatei bearbeiten:"
    echo -e "|- Befehl: 'vi $dateiCONF'"
    vi $dateiCONF
    stsCONFvi=$?
    
#     echo -e "|- Status: $stsCONFvi\\t0=Keine Fehler! Bearbeitung erfolgreich abgeschlossen."
#     echo -e "|-\\t\\t1=Fehler! Keine Rückmeldung über die Speichervorgänge. Bitte die Änderungen überprüfen!"
#     echo -e "|-\\t\\t2=Fehler! Bearbeitung wurde entweder durch Benutzer oder anderen Prozess abgebrochen."
    
    case "$stsCONFvi" in
        (0)
            txtCONFvi="Keine Fehler! Bearbeitung erfolgreich abgeschlossen."
            ;;
        (*)
            txtCONFvi="Fehlerhafter oder unklarer Status! Bitte die Änderungen überprüfen!"
            ;;
    esac
    
#    echo -e "|- Status: $stsCONFvi\\t$txtCONFvi"
    
    echo -e "|- Bearbeitung der Datei erfolgreich abgeschlossen!"\\n"|-"
    echo -e $txtHR\\n"|- Bearbeiten $dateiCONF"\\t"-ENDE-"\\n$txtHR
    exit 0;
fi






# -Die Hilfe anzeigen:
if ( [[ "$strg1" == -*h* ]] )
then
    #echo -e $txtKOPF
    #echo -e $txtKOPF $txtHILFE | more
    #echo -e $txtKOPF $txtHILFE $befehlAUSGABEmore
    
    if ( [[ "$flagMORE" == "false" ]] )
    then
        # -Normaler Aufruf ohne More-Option
        echo -e $txtKOPF $txtHILFE
    else
        echo -e $txtKOPF $txtHILFE | more
    fi
    exit 0;
fi


# -Die Logdatei anzeigen:
# --verschiedene Optionen: l?, scl ... oder nur l
# --l? startet Auswahlfenster für Logdatei im aktuellen Verzeichnis
# --scl ... Logdatei wird anhand der entsprechenden Shortcut Vorgaben angezeigt
# --l Falls vorhanden wird Logdatei im aktuellen Verzeichnis angezeigt, ansonsten startet Auswahlfenster

function fncEINGABElogdatei {
    #vorgabePFAD=`pwd`
    #vorgabeFILTER="Textdatei (*.txt)"
    eingabeDATEI=$(kdialog --title="Logdatei wählen:" --getopenfilename "$vorgabePFAD" "$vorgabeFILTER" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            checkDIALOGfehler="" ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Auswahl der Logdatei abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    fi
}

function fncAUSGABElogdatei {
    txtfncAUSGABE=$1
    #echo -e "$txtHRFullScreen"\\n"|- START Ausgabe: $txtfncAUSGABE"
    echo -e "$txtHRFullScreen"\\n"|- START Ausgabe: $txtfncAUSGABE"\\n"$txtHRFullScreen"
    # -Bei einem internen Aufruf (z.Bsp. strBEFEHLnachQUIT) darf more nicht
    #  verwendet werden, denn more erwartet eine Eingabe des Benutzers. More wurde allerdings
    #  in einer Subshell gestartet, deshalb ist keine Interaktion vom Benutzer möglich!
    # -???Terminaltest mittels tty: mit *dev* = Ausgabe über Display! = mit Benutzer!???
    # -Bei einem internen Aufruf wird ein entsprechendes Flag übertragen, damit more möglichst verhindert wird...
    #if ( [[ `tty` == *dev* ]] )
    if ( [[ "$flagMORE" == "false" ]] )
    then
        # -Interner Aufruf
        # --oder
        # -Normaler Aufruf ohne More-Option
        cat $txtfncAUSGABE
    else
        #echo -e "DEBUG: txtfncAUSGABE:\\t\\t$txtfncAUSGABE"
        #echo -e "DEBUG: befehlAUSGABEmore:\\t"`$befehlAUSGABEmore`
        #cat $txtfncAUSGABE `$befehlAUSGABEmore`
        #(cat $txtfncAUSGABE) `$befehlAUSGABEmore`
        #--- cat $txtfncAUSGABE | `$befehlAUSGABEmore` ---
        more $txtfncAUSGABE
    fi
    
    
    # -SONDERFALL: Ausgabe Logdatei in Bearbeitung UND laufender Download
    # -SONDERFALL: Zeile davor enthält kein Newline Zeichen (wegen 'echo -en')
    getCPos
    [ "$CPosSPALTE" -gt 1 ] && echo -e ""
    
    #echo -e "|- ENDE Ausgabe: $txtfncAUSGABE"\\n"$txtHRFullScreen"
    echo -e "$txtHRFullScreen"\\n"|- ENDE Ausgabe: $txtfncAUSGABE"\\n"$txtHRFullScreen"
    exit 0;
}

vorgabePFAD=`pwd`
vorgabeFILTER="Textdatei (*.txt)"


if ( [[ "$strg1" == -*l\?* ]] )
then
    [[ "$flagSCglobal" == "true" ]] && vorgabePFAD=$arrSHORTCUTverzeichnis
    fncEINGABElogdatei
    # -Pfad zur Logdatei übergeben, Daten ausgeben und Skript beenden:
    fncAUSGABElogdatei "$eingabeDATEI"
fi


if ( [[ "$strg1" == -*l* ]] )
then    
    if ( [[ "$strg1" != -*scl* ]] && [[ -f "$dateiLOGS" ]] )
    then
        # -Pfad zur Logdatei übergeben, Daten ausgeben und Skript beenden:
        fncAUSGABElogdatei "$dateiLOGS"
    else
        # -Keine Logdatei gefunden, deshalb Auswahlfenster aufrufen:
        # --Falls Shortcut gesetzt wurde, werden die Verzeichniseinstellungen
        #   übernommen.
        # --Ohne Shortcut wird das aktuelle Verzeichnis als Vorgabe gesetzt.
        vorgabePFAD=`pwd`
        vorgabeFILTER="Textdatei (*.txt)"
        
        if ( [[ "$flagSCglobal" == "true" ]] )
        then
            vorgabePFAD=$arrSHORTCUTverzeichnis
            # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
            if ( [[ "$arrSHORTCUTverzeichnisAUSWAHL" == "verzeichnisJA" ]] )
            then
                fncEINGABElogdatei
            else
                eingabeDATEI=$arrSHORTCUTverzeichnis"/"$dateiLOGS
            fi
        else
            fncEINGABElogdatei
        fi
        
        # -Pfad zur Logdatei übergeben, Daten ausgeben und Skript beenden:
        fncAUSGABElogdatei "$eingabeDATEI"
    fi
fi


echo -e $txtKOPF


txtINFOeingabeAUFRUF="|- -Aufruf mittels:\\t\\t$datei $*"
# -Wird nur noch in die Logdatei geschrieben und nicht noch zusätzlich am Bildschirm angezeigt:
#echo -e $txtINFOeingabeAUFRUF






















#if ( [[ "$strg1" != -*qq* ]] )
# ----- DEAKTIVIERT: -----
if ( [[ "$strg1" == -*ZEIT* ]] )
then
    # -----------------------------------------------------------------------------
    # ----- START Eingabe zeitversetztes Starten ----------------------------------
    eingabeZEITVERSETZT=$(kdialog --title="Zeitversetzt starten?" --warningcontinuecancel "<h3><center>|--- $datei ---|</center></h3><br>\
    Soll der Download zeitversetzt um 02:00 Uhr gestartet werden?" --continue-label="Nein!" --cancel-label="Ja, zeitversetzt starten." --geometry=600x500)

    flagFRAGE=$(echo -e "$?")
    if [[ "$flagFRAGE" == "2" ]]
    then
        # -Abbrechen/Zeitversetzt wurde gewählt:
        flagZEITVERSETZT="true"
        eingabeZEITVERSETZT="JA"
    else
        # -Weiter/Nicht-Zeitversetzt wurde gewählt:
        flagZEITVERSETZT="false"
        eingabeZEITVERSETZT="NEIN"
    fi
    # ----- ENDE Eingabe zeitversetztes Starten -----------------------------------
    # -----------------------------------------------------------------------------
else
    flagZEITVERSETZT="false"
    eingabeZEITVERSETZT="NEIN"
fi

#txtINFOeingabeZEITVERSETZT="|- -Zeitversetzt starten:\\t$eingabeZEITVERSETZT"
#echo -e $txtINFOeingabeZEITVERSETZT





#fncDEBUGstart "Bandbreite"

if ( [[ "$strg1" != -*qq* ]] )
then
    # -----------------------------------------------------------------------------
    # ----- START Begrenzung Bandbreite einstellen --------------------------------
    # -Standard ist keine maximale Bandbreite, aber der Nutzer kann den Wert auch
    #  selbst einstellen bzw in der Liste auswählen.

    txtUEBERSCHRIFT="<h3><center>|--- $datei ---|</center></h3><br>\
    Hier haben Sie die Möglichkeit, die Downloadrate des Skripts zu begrenzen. Diese<br>\
    Einstellung gilt nur für den aktuellen Aufruf, d.h. beim nächsten Skriptstart wird<br>\
    wieder standardmäßig 'keine Begrenzung' eingestellt.<br><br>\
    Bei dieser Liste können übrigens mehrere Einträge ausgewählt werden. Dabei werden die<br>\
    kB/s Werte einfach miteinander addiert.<br>\
    Beispiel:<br>\
    Auswahl: 100kB/s + 300kB/s = 400kB/s maximale Downloadrate<br>"
    strAUSWAHL="NEIN Keine Begrenzung on 1000 1000kB/s off 800 800kB/s off 500 500kB/s off 300 300kB/s off 200 200kB/s off 100 100kB/s off"
    #eingabeBANDBREITE=$(kdialog --title "Maximale Bandbreite?" --checklist "$txtUEBERSCHRIFT" $strAUSWAHL)
    eingabeBANDBREITE=$(kdialog --title "Maximale Bandbreite?" --checklist "$txtUEBERSCHRIFT" NEIN "Keine Begrenzung" on 1000 1000kB/s off 800 800kB/s off 500 500kB/s off 300 300kB/s off 200 200kB/s off 100 100kB/s off)
    eingabeBANDBREITE=${eingabeBANDBREITE//\"/}
    #eingabeBANDBREITE=${eingabeBANDBREITE// /}
    # DEBUG:
    #echo -e "--- eingabeBANDBREITE $eingabeBANDBREITE"
    
    if ( [[ "$eingabeBANDBREITE" == NEIN* ]] )
    then
        nix=0
        # DEBUG:
        #echo -e "--- if-then eingabeBANDBREITE $eingabeBANDBREITE"
        eingabeBANDBREITE="NEIN"
    elif ( [[ "$eingabeBANDBREITE" == "" ]] )
    then
        eingabeBANDBREITE="NEIN"
        # DEBUG:
        #echo -e "--- elif-then eingabeBANDBREITE $eingabeBANDBREITE"
    else
        # DEBUG:
        #echo -e "--- else eingabeBANDBREITE $eingabeBANDBREITE"
        eingabeBANDBREITEarr=($eingabeBANDBREITE)
        typeset -i eingabeBANDBREITEfertig=0
        typeset -i eingabeBANDBREITEarrWERT=0
        typeset -i zz=0
        for i in ${eingabeBANDBREITEarr[@]}
        do
            eingabeBANDBREITEarrWERT=${eingabeBANDBREITEarr[$zz]//\"/}
            eingabeBANDBREITEfertig=eingabeBANDBREITEfertig+eingabeBANDBREITEarrWERT
            zz=zz+1
        done
        eingabeBANDBREITE=$eingabeBANDBREITEfertig"kB/s"
        eingabeBANDBREITEfertigBEFEHL=$eingabeBANDBREITEfertig"k"
    fi
    # ----- ENDE Begrenzung Bandbreite einstellen ---------------------------------
    # -----------------------------------------------------------------------------
else
    eingabeBANDBREITE="NEIN"
fi

#txtINFOeingabeBANDBREITE="|- -Maximale Bandbreite:\\t"$eingabeBANDBREITE
#echo -e $txtINFOeingabeBANDBREITE

#fncDEBUGstop "Bandbreite"

txtINFOeingabeOPTIONEN="|- -Optionen:\\t\\t\\tZeitversetzt: $eingabeZEITVERSETZT - Bandbreite (max): $eingabeBANDBREITE"
echo -e "$txtINFOeingabeOPTIONEN"





arbeitsVERZEICHNIS=""
typeset -i intDONEfncVERZEICHNISauswahl=0
function fncVERZEICHNISauswahl {
    # -$arbeitsVERZEICHNIS muss von dieser Funktion gesetzt werden!
    # -$1: Verzeichnis in dem die Auswahl startet!
    #
    # -Wenn $1 NICHT gesetzt ist: Verzeichnisauswahl startet im aktuellen Verzeichnis (pwd)
    # -Wenn $1 gesetzt ist: Verzeichnisauswahl startet im Verzeichnis $1
    
    [ $1 ] || verzeichnisAUSWAHLstart="`pwd`"
    [ $1 ] && verzeichnisAUSWAHLstart="$1"
    [ ! -d "$verzeichnisAUSWAHLstart" ] && verzeichnisAUSWAHLstart="`pwd`"
    
    eingabeVERZEICHNIS=$(kdialog --title="Arbeitsverzeichnis wählen:" --getexistingdirectory "$verzeichnisAUSWAHLstart" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            #arrSHORTCUTverzeichnis=$eingabeVERZEICHNIS
            checkDIALOGfehler="" ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Verzeichnisauswahl abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    fi
    intDONEfncVERZEICHNISauswahl=intDONEfncVERZEICHNISauswahl+1
    #echo -e "$eingabeVERZEICHNIS"
    arbeitsVERZEICHNIS="$eingabeVERZEICHNIS"
}



if ( [[ "$flagSCglobal" == "true" ]] )
then
    arbeitsVERZEICHNIS="$arrSHORTCUTverzeichnis"
    # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
    if ( [[ "$arrSHORTCUTverzeichnisAUSWAHL" == "verzeichnisJA" ]] || [[ "$flagVERZEICHNISauswahl" == "true" ]] )
    then
        #arrSHORTCUTverzeichnis="`fncVERZEICHNISauswahl \"$arrSHORTCUTverzeichnis\"`"
        fncVERZEICHNISauswahl "$arrSHORTCUTverzeichnis"
    fi
    
    # -Arbeitsverzeichnis wechseln:
    cd $arbeitsVERZEICHNIS
fi





if ( [[ "$flagVERZEICHNISauswahl" == "true" ]] && [[ "$intDONEfncVERZEICHNISauswahl" -lt 1 ]] )
then
    # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
    #arbeitsVERZEICHNIS="`fncVERZEICHNISauswahl`"
    fncVERZEICHNISauswahl
    
    # -Arbeitsverzeichnis wechseln:
    cd $arbeitsVERZEICHNIS
fi






# if ( [[ "$flagSCglobal" == "true" ]] )
# then
#     # -Falls das Arbeitsverzeichnis/Downloadziel mittels Auswahlfenster abgefragt werden soll: 
#     if ( [[ "$arrSHORTCUTverzeichnisAUSWAHL" == "verzeichnisJA" ]] )
#     then
#         eingabeVERZEICHNIS=$(kdialog --title="Arbeitsverzeichnis wählen:" --getexistingdirectory $arrSHORTCUTverzeichnis 2>/dev/null)
#         checkDIALOG=$(echo -e "$?")
#         checkDIALOGfehler=""
#         # -Case für Fensterüberwachung:
#         case "$checkDIALOG" in
#             (0)
#                 # -Case für Eingabeüberwachung:
#                 arrSHORTCUTverzeichnis=$eingabeVERZEICHNIS
#                 checkDIALOGfehler="" ;;
#             (1)
#                 # -abbruchBENUTZER
#                 checkDIALOGfehler="|- Sie haben die Auswahl des Arbeitsverzeichnis abgebrochen. Das Skript wird daher beendet." ;;
#             (*)
#                 # -abbruchFEHLER
#                 checkDIALOGfehler="|- FEHLER:"\\n\
#     "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
#     "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
#     "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
#     "|-"\\n\
#     "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
#     "|- und die Ausgabe in der Konsole beachten." ;;
#         esac
#         # -Fehlerausgabe und Skript beenden:
#         if ( [[ "$checkDIALOGfehler" != "" ]] )
#         then
#             # -Fehlermeldung ausgeben und Skript beenden:
#             echo -e $checkDIALOGfehler
#             echo -e "|-"
#             exit $checkDIALOG;
#         fi
#     fi
#     
#     # -Arbeitsverzeichnis wechseln:
#     cd $arrSHORTCUTverzeichnis
# fi

txtINFOeingabeARBEITSVERZEICHNISpwd=`pwd`
txtINFOeingabeARBEITSVERZEICHNIS="|- -Arbeitsverzeichnis:\\t\\t$txtINFOeingabeARBEITSVERZEICHNISpwd"
echo -e $txtINFOeingabeARBEITSVERZEICHNIS















function fncDateienAuslesenAusgabe {
    # -Erwartet eine oder mehrere Dateien mittels $1, diese werden nacheinander
    #  ausgelesen, am Ende wird der Inhalt aller Dateien komplett ausgegeben!
    [[ "$1" == "" ]] && echo -e "(Argument nicht angegeben)" && return
    
    arrDateien=($1)
    strTmpDateienAusgabe=""
    
    for i in "${arrDateien[@]}"
    do
        strTmpDateienInhalt=""
        # -Inhalt auslesen und temporär speichern:
        [[ -n `cat $i` ]] && strTmpDateienInhalt=`cat $i`
        [[ -z `cat $i` ]] && continue
        
        [[ -z $strTmpDateienAusgabe ]] && strTmpDateienAusgabe="$strTmpDateienInhalt" && continue
        [[ -n $strTmpDateienAusgabe ]] && strTmpDateienAusgabe="$strTmpDateienAusgabe $strTmpDateienInhalt"
    done
    
    [[ -z $strTmpDateienAusgabe ]] && echo -e "Die gewählten Dateien haben keinen Inhalt!" && return
    echo -en "$strTmpDateienAusgabe"
    
}




function fncEINGABEdateiFAVORITEN {
    # -Falls es mehrere Dateien gibt, wird ein Auswahlfenster für Dateien geöffnet!
    
    vorgabePFAD=`pwd`
    vorgabeFILTER="Favoritendatei (*.FAV.*txt)"
    #eingabeDATEIfavoriten=$(kdialog --title="Favoriten wählen:" --getopenfilename "$vorgabePFAD" "$vorgabeFILTER" 2>/dev/null)
    
    # -Es können mehrere Favoritendateien ausgewählt werden, diese werden ausgelesen, zusammengefasst und dann
    #  in $dateiURLSfav gespeichert!
    eingabeDATEIfavoriten=$(kdialog --title="Favoriten wählen:" --getopenfilename --multiple "$vorgabePFAD" "$vorgabeFILTER" 2>/dev/null)
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            checkDIALOGfehler="" ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Auswahl der Favoritendatei abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    fi
    
    # -einzelne Favoritendatei:
    #cp $eingabeDATEIfavoriten $dateiURLSfav
    
    # -mehrere Favoritendateien:
    echo -e "`fncDateienAuslesenAusgabe \"$eingabeDATEIfavoriten\"`" > $dateiURLSfav
    
}



#fncDEBUGstart "Favoritenauswahl"

# -Check auf gespeicherte URLS und FAVORITEN:
flagFAVORITEN="false"
flagFavoritenAuswahl="automatisch"
#if ( [[ ! -f "$dateiURLS" ]] && [[ -f "$dateiURLSfav" ]] )
iaLSarray=(`ls *$datei".URLS.FAV"*"txt" 2>/dev/null`)
iaLSarrayANZAHL=${#iaLSarray[@]}
if ( [[ ! -f "$dateiURLS" ]] && [[ $iaLSarrayANZAHL -gt 0 ]] )
then
    if ( [[ $iaLSarrayANZAHL -gt 1 ]] )
    then
        fncEINGABEdateiFAVORITEN
        flagFavoritenAuswahl="durch-benutzer"
    fi

    # -Die gewählte Favoritendatei wird zur $dateiURLS kopiert:
    cp -b $dateiURLSfav $dateiURLS
    flagFAVORITEN="true"
fi

#fncDEBUGstop "Favoritenauswahl"








eingabeURLgespeichert=""
eingabeURLgespeichertKOMPLETT=""
txtFEHLERalteURLSgefunden=""

if ( [[ -f "$dateiURLS" ]] )
then
    while read eingabeURLgespeichert
    do
        nix=0
#         echo -e "|--- $eingabeURLgespeichert"
#         echo -e "|- Eine Sicherung ('$dateiURLS') der zuletzt verwendeten URLs wurde gefunden!"
#         echo -e "|- Anscheinend konnten die letzten Downloads nicht ordnungsgemäß beendet werden."
#         echo -e "|- Falls Sie sich nicht sicher sind ob alle Downloads fehlerfrei abgeschlossen wurden,"
#         echo -e "|- lassen Sie einfach das Skript mit den alten URLs noch einmal laufen. Dabei werden"
#         echo -e "|- keine Dateien doppelt heruntergeladen!"
#         echo -e "|-"
        txtFEHLERalteURLSgefunden="<hr><b>INFO:</b><br>\
        Eine Sicherung der zuletzt verwendeten URLs wurde gefunden! Anscheinend<br>\
        konnten die letzten Downloads nicht ordnungsgemäß beendet werden. Falls<br>\
        Sie sich nicht sicher sind ob alle Downloads fehlerfrei abgeschlossen<br>\
        wurden, können Sie das Skript mit den gesicherten URLs jetzt noch einmal<br>\
        laufen lassen.<br>\
        Dabei werden unterbrochene Downloads verlustfrei fortgesetzt und nur die<br>\
        noch fehlenden Dateien neu heruntergeladen!<hr>"
        if ( [[ "$flagFAVORITEN" == "true" ]] )
        then
            txtFEHLERalteURLSgefunden="<hr><b>INFO:</b><br>\
            Die URLs aus den Favoritendateien wurden erfolgreich importiert. Sie können nun<br>\
            einzelne URLs aus der Auflistung entfernen, neue URLs hinzufügen oder einfach<br>\
            direkt den Download-Prozess starten.<hr>"
            #Die URLs aus den Favoriten wurden erfolgreich ausgelesen und automatisch hier<br>\
            #zum Herunterladen eingefügt.<hr>"
        fi
        
        if ( [[ "$eingabeURLgespeichertKOMPLETT" != "" ]] )
        then
            #break;
            eingabeURLgespeichertKOMPLETT=$eingabeURLgespeichertKOMPLETT" "$eingabeURLgespeichert
        else
            eingabeURLgespeichertKOMPLETT=$eingabeURLgespeichert
        fi
    done < $dateiURLS
fi






# -Falls vorhanden erfolgt hier das einbinden der globalen Shortcut URLs. Allerdings haben die
#  normale URLs Datei und die Favoriten Datei eine höhere Priorität!!!
if ( [[ "$arrSHORTCUTurl" != "" ]] && [[ "$eingabeURLgespeichertKOMPLETT" == "" ]] )
then
    eingabeURLgespeichertKOMPLETT="$arrSHORTCUTurl"
fi




# -DEBUG-INFO:
#echo -e "--- eingabeURL: $eingabeURL --- eingabeURLgespeichertKOMPLETT: $eingabeURLgespeichertKOMPLETT --- arrSHORTCUTurl: $arrSHORTCUTurl"



if ( [[ "$eingabeURL" == "" ]] )
then
    # eingabeURL=$(kdialog --title="URL eingeben!" --inputbox "<hr><b style='align:middle;font-size:bigger'>$datei</b><hr><br>Bitte geben Sie die URLs der Dateien an, die das Skript herunterladen soll. Bei manchen Anbietern kann auch eine komplette Playliste angegeben werden.<br><br>Der WGET Befehl erwartet eine URL zu einem Verzeichnis mit Index Datei oder zu einer gültigen HTML Datei<br><br>Mehrere URLs müssen immer durch Leerzeichen getrennt werden!<br>$txtFEHLERalteURLSgefunden" "$eingabeURLgespeichert" --geometry=400x400)
    eingabeURL=$(kdialog --title="URL eingeben!" --inputbox "<h3><center>|--- $datei ---|</center></h3><br>\
    Bitte geben Sie die URLs der Dateien an, die das Skript herunterladen<br>\
    soll. Bei manchen Anbietern können Sie komplette Playlisten verwenden.<br><br>\
    Bei Webseiten erwartet das Skript entweder eine URL zu einem Verzeichnis<br>\
    (mit einer Index Datei darin) oder eine URL zu einer HTML Datei.<br><br>\
    Mehrere URLs müssen immer durch Leerzeichen getrennt werden!<br>\
    $txtFEHLERalteURLSgefunden" "$eingabeURLgespeichertKOMPLETT" --geometry=600x500)
    checkDIALOG=$(echo -e "$?")
else
    checkDIALOG="0"
fi
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            case "$eingabeURL" in
                ( http://???* )
                    checkDIALOGfehler="" ;;
                ( https://???* )
                    checkDIALOGfehler="" ;;
                ( url:?? )
                    checkDIALOGfehler="" ;;
                (*)
                    checkDIALOGfehler="|- FEHLER:\\n|- Sie haben keine gültige URL eingegeben! Das Skript wird daher beendet." ;;
            esac ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die URL-Eingabe abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        if ( [[ "$eingabeURL" != "" ]] )
        then
            echo -e "|- Ihre Eingabe:\\t\\t$eingabeURL"
        fi
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    else
        txtINFOeingabeURL="|- -URL Eingabe:\\t\\t$eingabeURL"
        echo -e $txtINFOeingabeURL
    fi

# -die URL Eingabe wird in einer datei gesichert! $dateiURLS
# --wenn das Skript mit einem Fehler abgebrochen wird, müssen die URLs also nicht noch einmal eingegeben werden
# --wenn das Skript korrekt beendet wird kann die datei gelöscht werden, allerdings solte die Logdatei noch kontrolliert
#   werden... (grep "error")
echo -e "$eingabeURL" > $dateiURLS




# ---------------------------------------------------------------------------------------------
# ----- START Force Option abfragen -----------------------------------------------------------
# -das $flagForceGlobal ersetzt -f
if ( [[ "$strg1" != -*qq* ]] )
then
    # -Falls -f schon als Argument beim Befehlsaufruf gesetzt wurde, wird diese Abfrage übersprungen.
    if ( [[ "$flagForceArgument" != "true" ]] )
    then
        kdialog --title="Force Download?" --warningcontinuecancel="<h3><center>|--- $datei ---|</center></h3><br>\
        Um einen erneuten Download zu erzwingen, kann die Force Option<br>\
        gesetzt werden. (\"-f\" beim Aufruf in der Konsole)<br><br>\
        Die IDs der bereits heruntergeladenen Videodateien werden gespeichert<br>\
        um keine Datei doppelt herunterzuladen. Wenn die Datei jedoch erneut<br>\
        oder in einem neuen Format gespeichert werden soll, MUSS die<br>\
        Force Option gesetzt werden.<br><br><br>\
        Möchten Sie die Force Download Option einschalten?" \
        --continue-label="Weiter, OHNE Force Download." --cancel-label="Weiter, MIT Force Download."

        flagFRAGE=$(echo -e "$?")
        if [[ "$flagFRAGE" == "2" ]]
        then
            # -Abbrechen wurde gewählt:
            flagForceGlobal="true"
        else
            # -Weiter wurde gewählt:
            nix=1
        fi
    else
        # -f wurde beim Befehlsaufruf gesetzt
        flagForceGlobal="true"
    fi
fi
# ----- ENDE Force Option abfragen ------------------------------------------------------------
# ---------------------------------------------------------------------------------------------







# ---------------------------------------------------------------------------------------------
# ----- START Reihenfolge und Downloadformat festlegen ----------------------------------------
if ( [[ "$strg1" != -*qqq* ]] )
then
    # -Dieser Teil wird nicht unterdrückt:
    #  Playlistreihenfolge festlegen und Downloadformat auswählen!
    #
    # -Playlistreihenfolge festlegen:
    actionBEFEHLreihenfolge=""
    if ( [[ "$eingabeURL" == *list* ]] || [[ "$eingabeURL" == *channel* ]] )
    then
        # -Bei Playlisten mit verschiedenen Videos/Musiktiteln kann von NEU-zu-ALT (--playlist-reverse)
        #  sinnvoll sein, aber bei Playlisten mit kompletten Musik Alben ist die korrekte Reihenfolge
        #  der Titel dann nicht mehr gegeben!!!
        
        kdialog --title="Reihenfolge?" --yesnocancel="<h3><center>|--- $datei ---|</center></h3><br>\
        Beim Herunterladen von Playlisten kann es sinnvoll sein, die vorgegebene<br>\
        Reihenfolge (von alt zu neu) umzudrehen.<br>\
        Standardmäßig wird beim ersten Video in der Liste begonnen.<br>\
        Alternativ kann aber auch mit dem letzten Video begonnen werden.<br><br>\
        <b>TIPP:</b> Standard bestätigen: [RETURN]<br><br><br>\
        -Vom Ersten Video zum Letzten. (Standard)<br>\
        -1., 2., ... 15., 16.<br><br>\
        -Vom Letzten Video zum Ersten.<br>\
        -16., 15., ... 2., 1.<br><br>" \
        --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!"
#         --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!" >/dev/null 2>&1
        
#         --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!" || echo -e "|- Bei der Auswahl der Reihenfolge ist ein Fehler aufgetreten."
#         --yes-label="Vom Ersten zum Letzten!" --no-label="Vom Letzten zum Ersten!" --cancel-label="Beenden!" || strFEHLERcode="kdialog:reihenfolge:NA" && echo -e "|- Bei der Auswahl der Reihenfolge ist ein Fehler aufgetreten."
#         D.h. die neu hinzugefügten Videos werden am Ende heruntergeladen.<br><br>\
#         D.h. die neu hinzugefügten Videos werden am Anfang heruntergeladen.<br><br><br>\


        
#         kdialog --title="Reihenfolge?" --warningyesnocancel="<h3><center>|--- $datei ---|</center></h3><br>\
#         Da Playlisten zum Herunterladen angegeben wurden, kann jetzt festgelegt<br>\
#         werden, mit welchen Videos innerhalb der Liste der Download starten soll.<br><br><br>\
#         -Von ALT zu NEU. (Standard)<br>\
#         -1., 2., 3., ... 14., 15., 16.<br>\
#         D.h. neu hinzugefügte Videos am Ende. (Sinnvoll bei Musik Alben!)<br><br>\
#         -Von NEU zu ALT.<br>\
#         -16., 15., 14., ... 3., 2., 1.<br>\
#         D.h. neu hinzugefügte Videos am Anfang.<br><br><br>\
#         <i>TIPP:</i> Standard bestätigen: [RETURN]<br>" \
#         --yes-label="Von ALT zu NEU!" --no-label="Von NEU zu ALT!" --cancel-label="Beenden!"

        flagFRAGE=$(echo -e "$?")
        
        # -Case für Eingabeüberwachung:
        case "$flagFRAGE" in
            ("2")
                # -CANCEL wurde gewählt!
                # -Skript beenden:
                checkDIALOGfehler="|- Sie haben die Auswahl abgebrochen. Das Skript wird daher beendet."
                echo -e $checkDIALOGfehler
                echo -e "|-"
                exit 1;
                ;;
            ("1")
                # -NO wurde gewählt!
                # -Reihenfolge umdrehen:
                actionBEFEHLreihenfolge=" --playlist-reverse"
                ;;
            ("0")
                # -YES wurde gewählt!
                # -Reihenfolge bleibt unverändert:
                actionBEFEHLreihenfolge=""
                ;;
            (*)
                # -Wegen aboutToFinish-Handling...
                # -Skript beenden:
                checkDIALOGfehler="|- Sie haben die Auswahl abgebrochen. Das Skript wird daher beendet."
                echo -e $checkDIALOGfehler
                echo -e "|-"
                exit 2;
                ;;
        esac
        
        
#         if ( [[ "$flagFRAGE" == "2" ]] )
#         then
#             # -CANCEL wurde gewählt!
#             # -Skript beenden:
#             checkDIALOGfehler="|- Sie haben die Eingabe abgebrochen. Das Skript wird daher beendet."
#             echo -e $checkDIALOGfehler
#             echo -e "|-"
#             exit 1;
#         elif ( [[ "$flagFRAGE" == "1" ]] )
#         then
#             # -NO wurde gewählt!
#             # -Reihenfolge umdrehen:
#             actionBEFEHLreihenfolge=" --playlist-reverse"
#         elif ( [[ "$flagFRAGE" == "0" ]] )
#         then
#             # -YES wurde gewählt!
#             # -Reihenfolge bleibt unverändert:
#             actionBEFEHLreihenfolge=""
#             nix=1
#         else
#             # -Wegen aboutToFinish-Handling...
#             # -Reihenfolge bleibt unverändert:
#             actionBEFEHLreihenfolge=""
#             nix=1
#         fi

    fi


    # -Downloadformat auswählen:
    auswahlACTION=$(kdialog --title="Format auswählen!" --radiolist="<h3><center>|--- $datei ---|</center></h3><br>\
    Bitte wählen Sie in welchen Formaten die Daten gespeichert werden sollen.<hr><br>\
    Bei Audiodateien wird automatisch das Video Thumbnail als Cover in der<br>\
    mp3 Datei gespeichert! Nur wenn das Thumbnail zusätzlich als eigenständige<br>\
    Grafikdatei abgespeichert werden soll, wählen Sie eine der Optionen mit \"Thumbnail\".<br>\
    Wenn Sie HTML-Seiten mit allen Ebenen herunterladen, kann die Datenmenge sehr<br>\
    umfangreich werden.<br><br>\
    Standard: \"Nur Video\"<hr><br>\
    Dateiformate auswählen:<br>" \
    "Nur Video" "Nur Video (mp4)" on \
    "Nur Audio" "Nur Audio (mp3)" off \
    "Audio und Thumbnail" "Audio und Thumbnail (mp3, jpg)" off \
    "Video und Audio" "Video und Audio (mp4, mp3)" off \
    "Video, Audio und Thumbnail" "Video, Audio und Thumbnail (mp4, mp3, jpg)" off \
    "HTML-Seiten Ebenen:1" "HTML-Seiten (rekursiv, Ebenen: 1)" off \
    "HTML-Seiten Ebenen:alle" "HTML-Seiten (rekursiv, Ebenen: alle)" off)
    #actionGRAFIK "Nur Grafik (wget)" off  --geometry="600x500")
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            case "$auswahlACTION" in
                ("Nur Video")
                    actionBEFEHL="$actionDATEIoptionen $actionFORMAT"
                    txtStandardDownloadSingular="Video"
                    txtStandardDownloadPlural="Videos"
                    ;;
                ("Nur Audio")
                    actionBEFEHL="$actionDATEIoptionen -x --audio-format mp3 --audio-quality 0 --embed-thumbnail"
                    txtStandardDownloadSingular="Audiodatei"
                    txtStandardDownloadPlural="Audiodateien"
                    ;;
                ("Audio und Thumbnail")
                    actionBEFEHL="$actionDATEIoptionen -x --audio-format mp3 --audio-quality 0 --embed-thumbnail --write-thumbnail"
                    txtStandardDownloadSingular="Audiodatei"
                    txtStandardDownloadPlural="Audiodateien"
                    ;;
                ("Video und Audio")
                    actionBEFEHL="$actionDATEIoptionen $actionFORMAT -x -k --audio-format mp3 --audio-quality 0 --embed-thumbnail"
                    txtStandardDownloadSingular="Video/Audiodatei"
                    txtStandardDownloadPlural="Videos/Audiodateien"
                    ;;
                ("Video, Audio und Thumbnail")
                    actionBEFEHL="$actionDATEIoptionen $actionFORMAT -x -k --audio-format mp3 --audio-quality 0 --embed-thumbnail --write-thumbnail"
                    txtStandardDownloadSingular="Video/Audiodatei"
                    txtStandardDownloadPlural="Videos/Audiodateien"
                    ;;
                ("HTML-Seiten Ebenen:1")
                    actionBEFEHL="wget -np -r -l 1 -k -E -p"
                    txtStandardDownloadSingular="HTML-Seite"
                    txtStandardDownloadPlural="HTML-Seiten"
                    ;;
                ("HTML-Seiten Ebenen:alle")
                    actionBEFEHL="wget -np -r -l inf -k -E -p"
                    txtStandardDownloadSingular="HTML-Seite"
                    txtStandardDownloadPlural="HTML-Seiten"
                    ;;
                (*)
                    checkDIALOGfehler="|- FEHLER:\\n|- Die Formatauswahl hat keine Daten übermittelt! Bitte erneut auswählen."
                    ;;
            esac ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Eingabe abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|-"
        exit $checkDIALOG;
    else
        nix=0
    fi
else
    # -qqq wurde gesetzt, daher müssen die Standard Werte geladen werden!
    actionBEFEHL="$actionDATEIoptionen $actionFORMAT"
    auswahlACTION="Nur Video"
fi

txtINFOauswahlACTION="|- -Speichern:\\t\\t\\t$auswahlACTION"
#echo -e $txtINFOauswahlACTION
# ----- ENDE Reihenfolge und Downloadformat festlegen -----------------------------------------
# ---------------------------------------------------------------------------------------------














# ---------------------------------------------------------------------------------------------
# ----- START Modus actionBEFEHL für Playlist festlegen ---------------------------------------
FlagModusBefehlPlaylist="komplett"
if ( [[ "$strg1" != -*qqqq* ]] && [[ "$eingabeURL" == *list* ]] || [[ "$eingabeURL" == *channel* ]] )
then
    # -Modus actionBEFEHL für Playlist festlegen:
    # --komplett: die komplette Playliste wird zum Download übergeben
    # --einzeln: die Videos der Playliste werden einzeln zum Download übergeben
    
    ModusBefehlPlaylist=$(kdialog --title="Modus wählen!" --radiolist="<h3><center>|--- $datei ---|</center></h3><br>\
    Beim Download von Playlisten oder Channels können Sie zwischen 2 verschiedenen<br>\
    Modi auswählen:<br><br>\
    <b>-komplette Playliste:</b><br>\
    (+) schnelle Verarbeitung<br>\
    (-) kein Zugriff auf einzelne Videos<br><br>\
    <b>-einzelne Videos:</b><br>\
    (+) Zugriff auf einzelne Videos<br>\
    (-) langsame Verarbeitung<br><br>\
    Bitte den Playlist Download Modus wählen:<br>\
    (Standard: \"$FlagModusBefehlPlaylist\")" \
    "komplett" "komplette Playliste" `fncAUSGABEstandardONOFF komplett $FlagModusBefehlPlaylist` \
    "einzeln" "einzelne Videos" `fncAUSGABEstandardONOFF einzeln $FlagModusBefehlPlaylist`)
    #actionGRAFIK "Nur Grafik (wget)" off  --geometry="600x500")
    checkDIALOG=$(echo -e "$?")
    checkDIALOGfehler=""
    # -Case für Fensterüberwachung:
    case "$checkDIALOG" in
        (0)
            # -Case für Eingabeüberwachung:
            case "$ModusBefehlPlaylist" in
                ("komplett")
                    FlagModusBefehlPlaylist=$ModusBefehlPlaylist
                    ;;
                ("einzeln")
                    FlagModusBefehlPlaylist=$ModusBefehlPlaylist
                    ;;
                (*)
                    FlagModusBefehlPlaylist=$ModusBefehlPlaylist
                    ;;
            esac ;;
        (1)
            # -abbruchBENUTZER
            checkDIALOGfehler="|- Sie haben die Eingabe abgebrochen. Das Skript wird daher beendet." ;;
        (*)
            # -abbruchFEHLER
            checkDIALOGfehler="|- FEHLER:"\\n\
    "|- Ihre Eingabe konnte nicht gespeichert werden, da der Fensterprozess beendet"\\n\
    "|- wurde. Entweder gab es einen internen Fehler oder ein anderer Benutzer/Prozess"\\n\
    "|- hat das Programm geschlossen. Bitte starten Sie $datei neu!"\\n\
    "|-"\\n\
    "|- Um nähere Informationen zu erhalten, sollten Sie ihre Logdateien kontrollieren"\\n\
    "|- und die Ausgabe in der Konsole beachten." ;;
    esac
    # -Fehlerausgabe und Skript beenden:
    if ( [[ "$checkDIALOGfehler" != "" ]] )
    then
        # -Fehlermeldung ausgeben und Skript beenden:
        echo -e $checkDIALOGfehler
        echo -e "|- Status: $checkDIALOG"
        echo -e "|-"
        exit $checkDIALOG;
    else
        nix=0
    fi
else
    # -qqqq wurde gesetzt, daher müssen die Standard Werte geladen werden!
    nix=0
fi

#txtINFOauswahlModusBefehl="|- -Modus:\\t\\t\\t$FlagModusBefehlPlaylist"
#echo -e $txtINFOauswahlModusBefehl

txtINFOauswahlModusBefehl=" (Playlist Modus: $FlagModusBefehlPlaylist)"
txtINFOauswahlACTION="$txtINFOauswahlACTION""$txtINFOauswahlModusBefehl"
echo -e $txtINFOauswahlACTION
# ----- ENDE Modus actionBEFEHL für Playlist festlegen -----------------------------------------------------
# ---------------------------------------------------------------------------------------------





















# --------------------------------------------------------------------
# ----- START actionBEFEHL Korrekturen -------------------------------
# -Nur bei youtube-dl Aufrufen:
if ( [[ "$actionBEFEHL" == youtube-dl* ]] )
then
    # -Reihenfolge innerhalb von Playlisten einbauen:
    actionBEFEHL="$actionBEFEHL$actionBEFEHLreihenfolge"

    # -Den eingebauten Downloader anstatt ffmpeg nutzen, da ffmpeg kein Resume unterstützt und
    #  der Beendet-Status nicht korrekt an das Skript weitergeleitet wird!
    actionBEFEHL=$actionBEFEHL" --hls-prefer-native"
    
    # -Zusatz wegen HTTP-Fehler 412, precondition failed, urllib2
    #actionBEFEHL=$actionBEFEHL" --add-header Accept:'*/*'"
    #actionBEFEHL=$actionBEFEHL" --no-geo-bypass"
fi
# ----- ENDE actionBEFEHL Korrekturen --------------------------------
# --------------------------------------------------------------------







# -Die Bandbreite begrenzen:
if ( [[ "$eingabeBANDBREITE" != "" ]] && [[ "$eingabeBANDBREITE" != "NEIN" ]] )
then
    actionBEFEHL=$actionBEFEHL" --limit-rate $eingabeBANDBREITEfertigBEFEHL"
fi


# -Dateiinfos in die Logdatei schreiben:
echo -e $txtKOPFlogs > $dateiLOGS
echo -e $txtINFOeingabeAUFRUF >> $dateiLOGS
#echo -e $txtINFOeingabeZEITVERSETZT >> $dateiLOGS
#echo -e $txtINFOeingabeBANDBREITE >> $dateiLOGS
echo -e $txtINFOeingabeOPTIONEN >> $dateiLOGS
echo -e $txtINFOeingabeARBEITSVERZEICHNIS >> $dateiLOGS
echo -e $txtINFOeingabeURL >> $dateiLOGS
echo -e $txtINFOauswahlACTION >> $dateiLOGS










# -die Force Download Option einbinden:
#  wenn die Datei bereits heruntergeladen wurde, existiert ein Eintrag im youtube-dl Archiv. um den erneuten Download
#  zu erzwingen wird ein temporäres Archiv benutzt, damit neue Download Einträge auch im Original-Archiv gespeichert
#  werden, wird der Inhalt des archivTMP an das Original-Archiv kopiert. Das archivTMP wird danach wieder gelöscht.
archivTMP="ytdl-archive.tmp"
if ( [[ "$flagForceGlobal" == "true" ]] )
then
    actionBEFEHL=$actionBEFEHL" --download-archive $archivTMP"
fi






# --------------------------------------------------------------------------------------------------
# -Befehl in Logdatei schreiben:
txtINFObefehl="|- -Befehl:\\t\\t\\t"

# -Umleitung der Ausgabe in die Logdatei:
umleitungLOGDATEI=">> $dateiLOGS 2>> $dateiLOGS"

####################################################################################################
# -Befehl wird nicht mehr am Bildschirm ausgegeben, sondern nur noch in die Logdatei geschrieben,
#  daher wird auch nichts mehr auf intSTATUSzeichenMAX begrenzt.
####################################################################################################
# # -Länge der Ausgabe begrenzen:
# intSTATUSzeichenMAX=220
# typeset -i intSTATUSzeichenKONTROLLE=0
# # -da Position mit null beginnt muss der Kontrollwert intSTATUSzeichenKONTROLLE nicht
# #  um eins erhöht werden
# # -wenn nach der maximalen Anzahl Zeichen der String noch weitergeht wird er gekürzt:
# intSTATUSzeichenKONTROLLE=$intSTATUSzeichenMAX
# intSTATUSzeichen=`echo $actionBEFEHL | awk '{print length($actionBEFEHL)}'`
# 
# txtINFObefehl="|- -Befehl:\\t\\t\\t"
# if ( [[ "$intSTATUSzeichen" -gt $intSTATUSzeichenMAX ]] && [[ "$txtSTATUS" != *%\ of* ]] )
# then
#     #actionBEFEHL=${actionBEFEHL:0:$intSTATUSzeichenMAX}"..."
#     txtINFObefehl=$txtINFObefehl${actionBEFEHL:0:$intSTATUSzeichenMAX}
# else
#     txtINFObefehl=$txtINFObefehl$actionBEFEHL
# fi
# #txtINFObefehl1="|- -Befehl:\\t\\t\\t$actionBEFEHL"
# txtINFObefehl1=$txtINFObefehl
# txtINFObefehl2="|-\\t\\t\\t\\t[URL] $umleitungLOGDATEI"\\n"|-"
# 
# # -Wird nur noch in die Logdatei geschrieben und nicht noch zusätzlich am Bildschirm angezeigt:
# #echo -e $txtINFObefehl1
# #echo -e $txtINFObefehl2
# echo -e "|-"
# 
# echo -e $txtINFObefehl1 >> $dateiLOGS
# echo -e $txtINFObefehl2 >> $dateiLOGS
####################################################################################################
####################################################################################################

txtINFObefehl=$txtINFObefehl$actionBEFEHL" [...URLs...] $umleitungLOGDATEI"
echo -e "|-"
echo -e $txtINFObefehl >> $dateiLOGS


# -Ausgabe der Force Download Option:
if ( [[ "$flagForceGlobal" == "true" ]] )
then
    txtINFOforceDOWNLOAD="|- -Force Download ist eingeschaltet!"
else
    txtINFOforceDOWNLOAD=""
fi
# -Ausgabe der Shutdown Option:
if ( [[ "$strg2" == "-off" ]] )
then
    txtINFOshutdown="|- -Nach erfolgreichem Beenden wird das System abgeschaltet! Wartezeit: 1 min"\\n"|-"
    intOFFminuten=1
elif ( [[ "$strg2" == -off=* ]] )
then
    txtINFOshutdown="|- -Nach erfolgreichem Beenden wird das System abgeschaltet! Wartezeit: $intOFFminuten min"\\n"|-"
elif ( [[ "$strg2" == "-" ]] || [[ "$strg2" == "" ]] )
then
    txtINFOshutdown=""
    intOFFminuten=""
fi
# -Zusatzinfos (Force und Shutdown Option) in Logdatei schreiben:
if ( [[ "$txtINFOforceDOWNLOAD" != "" ]] )
then
    echo -e $txtINFOforceDOWNLOAD
    echo -e $txtINFOforceDOWNLOAD >> $dateiLOGS
fi
if ( [[ "$txtINFOshutdown" != "" ]] )
then
    echo -e $txtINFOshutdown
    echo -e $txtINFOshutdown >> $dateiLOGS
fi










function fncKILLpid {
#     if ( [[ "$1" == "" ]] )
#     then
#         return 10
#     fi

    # -EINSCHALTEN: Tastatureingaben ausgeben/darstellen:
    #stty echo
    
    strKILLsignal=""
    if ( [[ "$2" != "" ]] )
    then
        strKILLsignal="$2 "
    fi
    
    if ( [[ "$1" != "" ]] )
    then
        intKILLpid="$1"
#         if ( [[ `ps -p $intKILLpid | grep $intKILLpid` == $intKILLpid* ]] )
#         then
#             #kill $intKILLpid >/dev/null 2>&1
#             # -Die Ausgabe wegen Fehlermeldungen nach Kill abschalten:
#             #exec >/dev/null 2>&1
#             # -Der Kill Befehl:
#             #kill $intKILLpid >/dev/null 2>&1
#             kill $intKILLpid >/dev/null 2>&1
#             # -Die Ausgabe wieder auf den Bildschirm legen:
#             #exec >`tty` 2>&1
#         fi
        typeset -i zKILL=0
        flagDONEkill="false"
        #while ( [[ `ps -p $intKILLpid | grep $intKILLpid` == $intKILLpid* ]] )
        #while ( [[ `ps -p $intKILLpid -o pid=` == "$intKILLpid" ]] )
        while ( [[ `ps -p $intKILLpid -o pid=` != "" ]] )
        do
            txtPROZESSname="`ps -p $intKILLpid -o comm=`"
            if ( [[ "$flagDONEkill" != "true" ]] )
            then
                #fncECHOlx "|- "`fncHHMMSS`" INFO $intID: "\ "+- Befehl: Kill SIGTERM $intKILLpid Prozess $txtPROZESSname"
                exec >/dev/null 2>&1
                # -Die Ausgabe in /dev/null umleiten wegen Fehlermeldungen nach Kill Befehl:
                kill $strKILLsignal$intKILLpid >/dev/null 2>&1 &
                exec >`tty` 2>&1
            fi
            #kdialog --title "Status.KILL.`fncHHMMSS 'norm.mS2'`" --passivepopup "--- KILL PID: $intKILLpid<br><br>--- Taste: $eingabeTASTE" 10 --geometry=260x100 &
            zKILL=zKILL+1
            sleep 0.05
            # -Maximale Wartezeit: 10 Sekunden
            #  10 Sekunden / sleep 0.05 = 200 Durchläufe der while Schleife
            [ $zKILL -ge 199 ] && flagDONEkill="true"
            #[ $zKILL -ge 40 ] && fncECHOlx "|- "`fncHHMMSS`" INFO $intID: "\ "+- Befehl: Kill SIGKILL Prozess $txtPROZESSname"
            [ $zKILL -ge 200 ] && kill -9 $intKILLpid >/dev/null 2>&1 &
            [ $zKILL -ge 200 ] && break
            
        done
    fi
    #xset +dpms >/dev/null 2>&1
}




















# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# ::::: Kontrolle erfolgreich NEUSTART ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# -Falls Fehler aufgetreten sind, wird mittels read abgefragt ob das Skript noch einmal mit den
#  gleichen Einstellungen und URLs gestartet werden soll!
# -WHILE Schleife zur Kontrolle und ggf Neustarten
# -Funktion fncKOPFZEILENsicherung speichert die Kopfzeilen in einer Variablen, damit bei Neustart
#  der Bildschirm gelöscht werden kann und die Kopfzeilen nochmals angezeigt werden können

function fncKOPFZEILENsicherung () {
    txtKOPFZEILENsicherung=""
    while read txtKOPFZEILENsicherungTMP
    do
        if ( [[ "$txtKOPFZEILENsicherung" == "" ]] )
        then
            txtKOPFZEILENsicherung="$txtKOPFZEILENsicherungTMP"
        else
            txtKOPFZEILENsicherung="$txtKOPFZEILENsicherung"\\n"$txtKOPFZEILENsicherungTMP"
        fi
    done < $dateiLOGS
}
fncKOPFZEILENsicherung

flagERFOLGREICHabgeschlossen="false"
flagNEUSTART="false"

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# ::::: START While Kontrolle erfolgreich NEUSTART ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
while ( [[ "$flagERFOLGREICHabgeschlossen" == "false" ]] )
do
    if ( [[ "$flagNEUSTART" == "true" ]] )
    then
        clear -x
        echo -e "$txtKOPFZEILENsicherung"
        # -Zusätzliche Infos für die Logdatei:
        zeitSTARTutc=`date '+%s'`
        zeitSTART=`date -d @$zeitSTARTutc`
        echo -e "|-"\\n"|- Neustart"\\n"|- $zeitSTART"\\n"|-" >> $dateiLOGS
        echo -e $txtKOPFZEILENsicherung >> $dateiLOGS
    fi




    
    
# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------
# ----- START Befehl zusammen bauen und aufrufen: -------------------------------------------------
#
# -Eingegebene URLS in Array umwandeln, damit jede URL einen eigenen youtube-dl Befehl
#  erhält, erforderlich für Unterverzeichnis pro Playlist!!!
#  read -a eingabeURLarray < $eingabeURL
checkBEFEHLinternRETURN=""
checkBEFEHLinternPID=""

intPLAYLISTitemsMAX=0
intPLAYLISTitems=0

flagQUITpsTasteF="false"
flagNEXTurl="false"
flagNEXTdatei="false"
flagCHECKurlsKOMPLETT="false"
FlagModusBefehlKOMPLETTquit=""


# -URL Array bilden:
read -a eingabeURLarray <<zzzTRENNERzzz
$eingabeURL
zzzTRENNERzzz


function fncBEFEHLaufrufen {
    typeset -i z=0
    typeset -i zURL=1
#     read -a eingabeURLarray <<zzzTRENNERzzz
#     $eingabeURL
# zzzTRENNERzzz
    actionPOSTbefehl=" --exec 'echo {} $txtPLAYLISTaktuell{}'"
    actionBEFEHLoutputVIDEO=" -o %(title)s-%(id)s.%(ext)s"
    # -Output Optionen für Playliste:
    # --playlist: Name oder ID der Playliste
    # --playlist_id: ID der Playliste
    # --playlist_title: Titel der Playliste
    actionBEFEHLoutputPLAYLIST=" -o %(playlist)s/%(playlist_index)s_%(title)s.%(ext)s"
    actionBEFEHLoutputPLAYLISTyoutube=" -o %(playlist_title)s/%(playlist_index)s_%(title)s.%(ext)s"
    
    actionBEFEHLoutput=$actionBEFEHLoutputVIDEO
    
    
    # -------------------------------------------------------------------------------
    # ----- PLS-Modus-Einzeln START -------------------------------------------------
    # -----
    while ( [[ "${eingabeURLarray[$z]}" != "" ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
    do
        # -Download von Playlisten splitten anhand von playlist_items=1 usw.
        # -Gesamtanzahl der Items auslesen und damit WHILE-Schleife bauen.
        #
        # youtube-dl --flat-playlist --dump-single-json https://www.youtube.com/watch?v=Q-oOwHlEtmU | grep -o '{"url"' | wc -l
        # youtube-dl --flat-playlist --dump-single-json https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -o '{"url"' | wc -l
        # youtube-dl --flat-playlist --dump-single-json https://www.youtube.com/watch?v=pFkzeRthzVU&list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -o '{"url"' | wc -l
        # youtube-dl --flat-playlist https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -o 'Downloading video' | wc -l
        
        
        [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
        
        #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS` >> $dateiLOGS
        #echo -e "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        [ $zURL -eq ${#eingabeURLarray[@]} ] && flagCHECKurlsKOMPLETT="true" && echo -e "true" > $dateiCACHEflagCHECKurlsKOMPLETT
        #echo -e "--- $zURL - flagCHECKurlsKOMPLETT: $flagCHECKurlsKOMPLETT"
        
        zURL=zURL+1
        
        typeset -i intPLAYLISTitemsMAX=1
        # -Alte doppelte Abfrage, vor Einbau !=*.youtube.*
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && strPLAYLISTflatJSON=`youtube-dl --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -o '{"url"' | wc -l 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && strPLAYLISTflatJSON=`youtube-dl --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -o '{"url"' | wc -l 2>/dev/null`
        
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && strPLAYLISTflatJSON=`youtube-dl --flat-playlist ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -o 'Downloading video' | wc -l 2>/dev/null`
        
        
        [ $intPLAYLISTitemsMAX -lt 1 ] && intPLAYLISTitemsMAX=1
        
        typeset -i intPLAYLISTitems=0
        typeset -i intPLAYLISTitemsENDE=1
        typeset -i intPLAYLISTitemsREVERSE=0
        intPLAYLISTitemsREVERSE=$intPLAYLISTitemsMAX
        echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
        while [ $intPLAYLISTitems -lt $intPLAYLISTitemsMAX ]
        do
            #[ ! -f $dateiCACHEplsINFOS ] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            
            [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
            [[ "$flagNEXTurl" == "true" ]] && break
            
            #[ $intPLAYLISTitems -eq 0 ] && intPLAYLISTitems=intPLAYLISTitems+1 && echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            intPLAYLISTitems=intPLAYLISTitems+1
            intPLAYLISTitemsENDE=intPLAYLISTitemsENDE+1
            #echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            
            #echo -e "["`fncHHMMSS`"]"
            #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
            
            #echo -e "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            fncECHOplatzhalter "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            
            echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
            actionBEFEHLitems=""
            if ( [[ "${eingabeURLarray[$z]}" == *list* ]] || [ $intPLAYLISTitemsMAX -gt 1 ] )
            then
                actionBEFEHLoutput=$actionBEFEHLoutputPLAYLIST
                #actionBEFEHLitems=" --playlist-items $intPLAYLISTitems"
                #actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems --max-downloads 1"
                [[ -z "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems"
                [[ -n "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitemsREVERSE --playlist-end $intPLAYLISTitemsREVERSE"
                intPLAYLISTitemsREVERSE=intPLAYLISTitemsREVERSE-1
            fi
            #echo -e "|--- $actionBEFEHL$actionPOSTbefehl ${eingabeURLarray[$z]}"
            #echo -e "|--- $actionBEFEHL$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            checkBEFEHL="echo -e $actionBEFEHL ${eingabeURLarray[$z]}"
            if ( [[ "$actionBEFEHL" == youtube-dl* ]] )
            then
                checkBEFEHL="echo -e $actionBEFEHL$actionBEFEHLitems$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            fi
            `$checkBEFEHL` >> $dateiLOGS 2>> $dateiLOGS &
            checkBEFEHLinternRETURN=$?
            checkBEFEHLinternPID=$!
            
            # -Limit erhöhen und Zeitbedarf checken: 
            cpulimit -p $checkBEFEHLinternPID -q -z -c 2 -l 10 &
            
            
            #echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
            #echo -e `wait $checkBEFEHLinternPID` > "$datei.AUSGABEwait.tmp" 2>&1
            #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
            #echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
            
            echo -e "$checkBEFEHLinternPID" > $dateiCACHEflagQUIT
            kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
            while ( [[ "$kontrollePID" != "" ]] )
            do
                sleep 0.1
                kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
                
                [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && flagQUITpsTasteF="true"
                
                # -taste-U-pls-modus-komplett
                [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
                
                # -taste-D-pls-modus-einzeln
                [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTdatei" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTdatei="true" && break
                
                #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
                #echo -e "arbeitet.$checkBEFEHLinternRETURN" > "$datei.$$.cacheBEFEHLinternRETURN.tmp"
                #echo -e "$checkBEFEHLinternPID" > "$datei.$$.cacheBEFEHLinternPID.tmp"
                #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.01.tmp"
                
#                 intUTCsekunden=`date '+%s'`
#                 if ( [[ "$intUTCsekunden" == *0 ]] || [[ "$intUTCsekunden" == *2 ]] || [[ "$intUTCsekunden" == *4 ]] || [[ "$intUTCsekunden" == *6 ]] || [[ "$intUTCsekunden" == *8 ]] )
#                 then
#                     intPLAYLISTitemLOGS=`cat $dateiCACHEplsINFOSitem`
#                     [ $intPLAYLISTitems -lt $intPLAYLISTitemLOGS ] && intPLAYLISTitems=$intPLAYLISTitemLOGS && fncKILLpid $checkBEFEHLinternPID
#                     kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
#                     #intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 12" | bc`
#                     #fncSTATUSanzeigen
#                     #flagSTATUSvorbereiten="true"
#                 fi
            done
            # -cpulimit mit --monitor-forks erzeugt dutzende weitere Aufrufe, daher:
            #kill -9 `ps -C cpulimit -o pid=` >/dev/null 2>&1
            
            function fncKILLpidLISTE {
            [ ! $1 ] && echo -e "--- Fehler: \$1 (Prozessname) nicht übergeben!" && exit 20;
            vorgabeTTY=`tty`
            vorgabeTTY=${vorgabeTTY//\/dev\//}
            
            #iaLSarray=(`ps -C cpulimit --tty $iaTERMINAL -o pid=`)
            iaLSarray=(`ps -C cpulimit -o pid=`)
            typeset -i zz=0
            typeset -i zzTTY=0
            for ia in ${iaLSarray[@]}
            do
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+ $zz - PS: $ia + "
                
                iaTTY=`ps -p $ia -o tty=`
                #[[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && echo -en "+ TTY: $iaTTY --- "
                [[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && fncKILLpid $ia >/dev/null 2>&1
                
                
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+++ Index $zz: $ia "
                #[ $zz -lt ${#iaLSarray[@]} ] && echo -e "--- $zz -lt ${#iaLSarray[@]}"
                #[ 17 -eq ${#iaLSarray[@]} ] && echo -e "--- -eq ${#iaLSarray[@]}"
                zz=zz+1
            done
            }
            fncKILLpidLISTE "cpulimit" >/dev/null 2>&1
            
            #[ -f $dateiCACHEplsINFOS ] &&
            #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.02.tmp"
        done
        [ -f $dateiCACHEplsINFOS ] && rm $dateiCACHEplsINFOS
        [ -f $dateiCACHEplsINFOSitem ] && rm $dateiCACHEplsINFOSitem
        flagNEXTurl="false"
        flagNEXTdatei="false"
        z=z+1
    done
    # -----
    # ----- PLS-Modus-Einzeln ENDE --------------------------------------------------
    # -------------------------------------------------------------------------------
    
    
    # -------------------------------------------------------------------------------
    # ----- PLS-Modus-Komplett START ------------------------------------------------
    # -----
    while ( [[ "${eingabeURLarray[$z]}" != "" ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
    do
        # -Download von Playlisten splitten anhand von playlist_items=1 usw.
        # -Gesamtanzahl der Items auslesen und damit WHILE-Schleife bauen.
        #
        # youtube-dl --flat-playlist --dump-single-json https://www.youtube.com/watch?v=Q-oOwHlEtmU | grep -o '{"url"' | wc -l
        # youtube-dl --flat-playlist --dump-single-json https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -o '{"url"' | wc -l
        # youtube-dl --flat-playlist --dump-single-json https://www.youtube.com/watch?v=pFkzeRthzVU&list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -o '{"url"' | wc -l
        # youtube-dl --flat-playlist https://www.youtube.com/playlist?list=PL8QTi8wsDMrUBGCDnc3BiKBtHLtSb9hPn | grep -o 'Downloading video' | wc -l
        
        
        [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
        
        #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS` >> $dateiLOGS
        #echo -e "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        fncECHOplatzhalter "[$datei] "`fncHHMMSS`" URL $zURL von ${#eingabeURLarray[@]}" >> $dateiLOGS
        [ $zURL -eq ${#eingabeURLarray[@]} ] && flagCHECKurlsKOMPLETT="true" && echo -e "true" > $dateiCACHEflagCHECKurlsKOMPLETT
        #echo -e "--- $zURL - flagCHECKurlsKOMPLETT: $flagCHECKurlsKOMPLETT"
        
        zURL=zURL+1
        
        typeset -i intPLAYLISTitemsMAX=1
        # -Alte doppelte Abfrage, vor Einbau !=*.youtube.*
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && strPLAYLISTflatJSON=`youtube-dl --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        #[[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -o '{"url"' | wc -l 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && strPLAYLISTflatJSON=`youtube-dl --flat-playlist --dump-single-json ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" != *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -o '{"url"' | wc -l 2>/dev/null`
        
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && strPLAYLISTflatJSON=`youtube-dl --flat-playlist ${eingabeURLarray[$z]} 2>/dev/null`
        [[ "${eingabeURLarray[$z]}" == *list* ]] || [[ "${eingabeURLarray[$z]}" == *channel* ]] && [[ "${eingabeURLarray[$z]}" == *.youtube.* ]] && intPLAYLISTitemsMAX=`echo -e $strPLAYLISTflatJSON | grep -o 'Downloading video' | wc -l 2>/dev/null`
        
        
        [ $intPLAYLISTitemsMAX -lt 1 ] && intPLAYLISTitemsMAX=1
        
        typeset -i intPLAYLISTitems=0
        typeset -i intPLAYLISTitemsENDE=1
        typeset -i intPLAYLISTitemsREVERSE=0
        intPLAYLISTitemsREVERSE=$intPLAYLISTitemsMAX
        echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
#         while [ $intPLAYLISTitems -lt $intPLAYLISTitemsMAX ]
#         do
            #[ ! -f $dateiCACHEplsINFOS ] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            [[ "$flagQUITpsTasteF" == "true" ]] && echo -e "flagQUITpsTasteF" > $dateiCACHEflagQUIT && return
            
            [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
            [[ "$flagNEXTurl" == "true" ]] && break
            
            #[ $intPLAYLISTitems -eq 0 ] && intPLAYLISTitems=intPLAYLISTitems+1 && echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            intPLAYLISTitems=intPLAYLISTitems+1
            intPLAYLISTitemsENDE=intPLAYLISTitemsENDE+1
            #echo -e $intPLAYLISTitems > $dateiCACHEplsINFOSitem
            
            #echo -e "["`fncHHMMSS`"]"
            #echo -e "[$datei] "`fncHHMMSS` >> $dateiLOGS
            
            #echo -e "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            fncECHOplatzhalter "[$datei] "`fncHHMMSS`" Video $intPLAYLISTitems von $intPLAYLISTitemsMAX" >> $dateiLOGS
            
            echo -e "$intPLAYLISTitems von $intPLAYLISTitemsMAX" > $dateiCACHEplsINFOS
            actionBEFEHLitems=""
            if ( [[ "${eingabeURLarray[$z]}" == *list* ]] || [ $intPLAYLISTitemsMAX -gt 1 ] )
            then
                actionBEFEHLoutput=$actionBEFEHLoutputPLAYLIST
                #actionBEFEHLitems=" --playlist-items $intPLAYLISTitems"
                #actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems --max-downloads 1"
#                 [[ -z "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitems --playlist-end $intPLAYLISTitems"
#                 [[ -n "$actionBEFEHLreihenfolge" ]] && actionBEFEHLitems=" --playlist-start $intPLAYLISTitemsREVERSE --playlist-end $intPLAYLISTitemsREVERSE"
#                 intPLAYLISTitemsREVERSE=intPLAYLISTitemsREVERSE-1
            fi
            
            #echo -e "|--- $actionBEFEHL$actionPOSTbefehl ${eingabeURLarray[$z]}"
            #echo -e "|--- $actionBEFEHL$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            checkBEFEHL="echo -e $actionBEFEHL ${eingabeURLarray[$z]}"
            if ( [[ "$actionBEFEHL" == youtube-dl* ]] )
            then
                checkBEFEHL="echo -e $actionBEFEHL$actionBEFEHLitems$actionBEFEHLoutput ${eingabeURLarray[$z]}"
            fi
            `$checkBEFEHL` >> $dateiLOGS 2>> $dateiLOGS &
            checkBEFEHLinternRETURN=$?
            checkBEFEHLinternPID=$!
            
            # -Limit erhöhen und Zeitbedarf checken: 
            cpulimit -p $checkBEFEHLinternPID -q -z -c 2 -l 10 &
            
            
            # -DEBUG START
            #intSSpopup=10
            #kdialog --passivepopup "--- INFO: $datei ---<br><br>PID 'checkBEFEHL': $checkBEFEHLinternPID<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
            # -DEBUG ENDE
            
            echo -e "$checkBEFEHLinternPID" > $dateiCACHEflagQUIT
            kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
            while ( [[ "$kontrollePID" != "" ]] )
            do
                sleep 0.1
                kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
                
                [ -f $dateiCACHEplsINFOS ] && [[ `cat $dateiCACHEplsINFOS` == *flagQUITpsTasteF ]] && txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && txtCACHEplsINFOS=${txtCACHEplsINFOS//flagQUITpsTasteF/} && echo -e "$txtCACHEplsINFOS" > $dateiCACHEplsINFOS && flagQUITpsTasteF="true"
                
                [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` == "flagNEXTurl" ]] && echo -e "" > $dateiCACHEflagQUIT && flagNEXTurl="true"
                
                #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
                #echo -e "arbeitet.$checkBEFEHLinternRETURN" > "$datei.$$.cacheBEFEHLinternRETURN.tmp"
                #echo -e "$checkBEFEHLinternPID" > "$datei.$$.cacheBEFEHLinternPID.tmp"
                #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.01.tmp"
                
#                 intUTCsekunden=`date '+%s'`
#                 if ( [[ "$intUTCsekunden" == *0 ]] || [[ "$intUTCsekunden" == *2 ]] || [[ "$intUTCsekunden" == *4 ]] || [[ "$intUTCsekunden" == *6 ]] || [[ "$intUTCsekunden" == *8 ]] )
#                 then
#                     intPLAYLISTitemLOGS=`cat $dateiCACHEplsINFOSitem`
#                     [ $intPLAYLISTitems -lt $intPLAYLISTitemLOGS ] && intPLAYLISTitems=$intPLAYLISTitemLOGS && fncKILLpid $checkBEFEHLinternPID
#                     kontrollePID=`ps --pid $checkBEFEHLinternPID -o pid=`
#                     #intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 12" | bc`
#                     #fncSTATUSanzeigen
#                     #flagSTATUSvorbereiten="true"
#                 fi
            done
            # -cpulimit mit --monitor-forks erzeugt dutzende weitere Aufrufe, daher:
            #kill -9 `ps -C cpulimit -o pid=` >/dev/null 2>&1
            
            function fncKILLpidLISTE {
            [ ! $1 ] && echo -e "--- Fehler: \$1 (Prozessname) nicht übergeben!" && exit 20;
            vorgabeTTY="pts/6"
            vorgabeTTY=`tty`
            vorgabeTTY=${vorgabeTTY//\/dev\//}
            
            #iaLSarray=(`ps -C cpulimit --tty $iaTERMINAL -o pid=`)
            iaLSarray=(`ps -C cpulimit -o pid=`)
            typeset -i zz=0
            typeset -i zzTTY=0
            for ia in ${iaLSarray[@]}
            do
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+ $zz - PS: $ia + "
                
                iaTTY=`ps -p $ia -o tty=`
                #[[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && echo -en "+ TTY: $iaTTY --- "
                [[ "$iaTTY" == "$vorgabeTTY" ]] && zzTTY=zzTTY+1 && fncKILLpid $ia >/dev/null 2>&1
                #[[ "$iaTTY" != "$vorgabeTTY" ]] && echo -e "--- Fehler: 'Vorgabe Terminal' NICHT-GLEICH 'Terminal aus Prozessliste'" && beep -l 400 -f 300 -r 3 -D 20
                
                #[ $zz -eq 0 ] && echo -e "+++ Anzahl: ${#iaLSarray[@]}"
                #echo -en "+++ Index $zz: $ia "
                #[ $zz -lt ${#iaLSarray[@]} ] && echo -e "--- $zz -lt ${#iaLSarray[@]}"
                #[ 17 -eq ${#iaLSarray[@]} ] && echo -e "--- -eq ${#iaLSarray[@]}"
                zz=zz+1
            done
            }
            #fncKILLpidLISTE "cpulimit" >/dev/null 2>&1
            #fncKILLpidLISTE "cpulimit" >>$dateiLOGS 2>>&1
            fncKILLpidLISTE "cpulimit"
            
            
            #[ -f $dateiCACHEplsINFOS ] &&
            #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.02.tmp"
            
#         done
        
        [ -f $dateiCACHEplsINFOS ] && rm $dateiCACHEplsINFOS
        [ -f $dateiCACHEplsINFOSitem ] && rm $dateiCACHEplsINFOSitem
        flagNEXTurl="false"
        z=z+1
    done
    # -----
    # ----- PLS-Modus-Komplett ENDE -------------------------------------------------
    # -------------------------------------------------------------------------------
    
    
    #echo -e "$checkBEFEHLinternRETURN" > "$datei.$$.cache.internRETURN.03.tmp"
}

fncBEFEHLaufrufen &
checkBEFEHLreturn=$?
checkBEFEHLpid=$!
checkBEFEHLreturnORIGINAL=$checkBEFEHLreturn
#echo -e "--- DEBUG-INFO: BEFEHLpid: $checkBEFEHLpid - BEFEHLreturn: $checkBEFEHLreturn"


# -----------------------------------------------------------------------------
# ----- START interne PID sichern und prüfen ----------------------------------
function fncAUSLESENbefehlINTERN {
    strAUSLESENdatei="$datei.$$.cache.internRETURN.01.tmp"
    # -Falls Cache Datei noch nicht erstellt wurde, wird darauf gewartet:
    while ( [[ ! -f "$strAUSLESENdatei" ]] )
    do
        sleep 0.1
        #beep -l 100 -f 120 -d 100
    done
    
    # -Den RETURN des internen Befehls auslesen:
    while read checkBEFEHLinternRETURNcache
    do
        checkBEFEHLinternRETURN=$checkBEFEHLinternRETURNcache
    done < $strAUSLESENdatei
    rm $strAUSLESENdatei

    checkBEFEHLreturn=`wait $checkBEFEHLpid`
    #checkBEFEHLinternRETURN=`wait $checkBEFEHLinternPID`
}


#fncAUSLESENbefehlINTERN
#echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
# ----- ENDE interne PID sichern und prüfen -----------------------------------
# -----------------------------------------------------------------------------


# checkBEFEHL="echo -e $actionBEFEHL $eingabeURL"
# #echo -e "*** DEBUG: checkBEFEHL"\\n"*** "$checkBEFEHL" "$umleitungLOGDATEI
# #echo -e "*** DEBUG: checkBEFEHL"
# #echo -e "*** "$checkBEFEHL" "$umleitungLOGDATEI
# `$checkBEFEHL` >> $dateiLOGS 2>> $dateiLOGS &
# checkBEFEHLreturn=$?
# checkBEFEHLpid=$!
# #checkBEFEHLreturn=$?
# #checkBEFEHLpid=$!
#
# ----- ENDE Befehl zusammen bauen und aufrufen: --------------------------------------------------
# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------





function fncCHECKzugriffeLOGS {
    # -Um laufende Schreibzugriffe auf die Logdatei nicht zu stören, wird
    #  bei Bedarf eine kurze Pause eingebaut:
    while ( [[ `lsof $dateiLOGS | grep youtube-dl` != "" ]] )
    do
        beep -l 100 -f 200 -r 3 -D 100
        sleep 0.1
    done
}




function fncMOVEkreisel {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.02
    done
}

function fncMOVEkreiselSLOW {
    for i in "${asciiKREISEL[@]}"
    do
        tput cup $cursorZEILEkreisel 38
        echo -ne "\b$i"
        sleep 0.1
    done
}




function fncMOVEasciiKREISEL {
    asciiKREISEL[0]="-"
    asciiKREISEL[1]="\\"
    asciiKREISEL[2]="|"
    asciiKREISEL[3]="/"
    tput cup $cursorZEILEkreisel 38
    echo -ne "\b${asciiKREISEL[0]}"
    #echo -n "-"
    #beep -l 60 -f 700 -D 100
    actionKONTROLLE="start"
    intUTCsekunden=`date '+%s'`
    intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 2" | bc`
    flagSTATUSvorbereiten="true"
    while ( [[ "$actionKONTROLLE" == "start" ]] )
    do
        intUTCsekunden=`date '+%s'`
        #if ( [[ "$intUTCsekunden" -ge "$intUTCreloadSTATUS" ]] && [[ "$intUTCsekunden" == *0 ]] )
        
        # -Wegen Verzögerungen bei der Anzeige des Status wird die Funktion gesplittet!
        # --ALT: Reload komplett (fncSTATUSanzeigen: Logdatei kopieren, fncSTATUSauslesenLOGS, anzeigen der Statuszeilen)
        # --NEU: ca 5 Sek vor Reloadzeitpunkt fncSTATUSkopierenLOGS - direkt danach fncSTATUSauslesenLOGS - zum korrekten
        #   Reloadzeitpunkt erfolgt Aufruf der fncSTATUSanzeigen
        #
        
        if ( [[ "$intUTCsekunden" -ge "$intUTCreloadSTATUS" ]] )
        then
            nix=1
            if ( [[ "$flagSTATUSvorbereiten" == "true" ]] )
            then
                fncSTATUSkopierenLOGS
                flagSTATUSvorbereiten="false"
            fi
            if ( [[ "$intUTCsekunden" == *00 ]] || [[ "$intUTCsekunden" == *20 ]] || [[ "$intUTCsekunden" == *40 ]] || [[ "$intUTCsekunden" == *60 ]] || [[ "$intUTCsekunden" == *80 ]] )
            then
                intUTCreloadSTATUS=`echo -e "$intUTCsekunden + 12" | bc`
                fncSTATUSanzeigen
                flagSTATUSvorbereiten="true"
            fi
        fi
        fncMOVEkreisel
        if ( [[ `ps -p $checkBEFEHLpid | grep $checkBEFEHLpid` == "" ]] )
        then
            # -Den checkBEFEHLreturn Status kontrollieren und ggf korrigieren!
            # --Skript wurde normal beendet: 0
            if ( [[ "$checkBEFEHLreturn" == "" ]] )
            then
                checkBEFEHLreturn="0"
            fi
            # -Das Quit-Flag-PS in TMP Datei schreiben:
            echo -e "flagQUITps" > "$dateiCACHEflagQUIT"
            eingabeTASTE="e"
            actionKONTROLLE="stop"
            #beep -l 60 -f 700 -D 200 --new -l 60 -f 700 -D 200 --new -l 60 -f 700 -D 200
            #flagERFOLGREICHabgeschlossen="true"
            break
        fi
        if ( [[ "$actionKONTROLLE" == "stop" ]] )
        then
            break
        fi
    done
}

function CHECKeingabeTASTE {
    # -Variablen innerhalb der Funktion übernehmen:
    #strFNC1=$1
    
    if ( [[ "$eingabeTASTE" != "e" ]] )
    then
        eingabeTASTE=""
        flagQUIT=""
        #stty raw echo
        #while ( [[ "$eingabeTASTE" != "q" ]] )
        #while ( [[ `dd bs=1 count=1 2>/dev/null` != "q" ]] && [[ `read "$dateiCACHEflagQUIT"` != "flagQUITps" ]] )
        
        #while ( [[ "$eingabeTASTE" != "q" ]] && [ -f $dateiCACHEflagQUIT ] && [[ `cat $dateiCACHEflagQUIT` != flagQUITps* ]] )
        while ( [[ "$eingabeTASTE" != "q" ]] && [[ `cat $dateiCACHEflagQUIT 2>/dev/null` != flagQUITps* ]] )
        do
            #eingabeTASTE=`dd bs=1 count=1 2>/dev/null`
            #tput cup $cursorZEILEkreisel 39
            read -n 1 -t 0.05 -s eingabeTASTE
            #tput cub 1
            #echo -n " "
            #tput cub 1
            #beep -l 350 -f 392 -D 100 --new -l 250 -f 311.1 -D 100
#             if ( [[ "$eingabeTASTE" == "p" ]] )
#             then
#                 kdialog --passivepopup "-- PAUSE --<br><br>Das Skript wurde von Ihnen angehalten und kann<br>mittels \"p\" fortgesetzt werden." 20
#             fi
            
            
            # -FlagModusBefehlPlaylist: einzeln
            # -d: Datei abbrechen, nächste Datei bearbeiten
            if ( [[ "$eingabeTASTE" == "d" ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
            then
                [ -f $dateiCACHEflagQUIT ] && txtCACHEinternPID=`cat $dateiCACHEflagQUIT`
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'd'<br>Die aktuelle Datei ($txtCACHEinternPID) wird abgebrochen und dann die nächste Datei bearbeitet.<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'd' - Datei abbrechen, dann nächste Datei bearbeiten" >> $dateiLOGS &
                echo -e "flagNEXTdatei" > $dateiCACHEflagQUIT
                fncKILLpid "$txtCACHEinternPID"
            fi
            
            # -FlagModusBefehlPlaylist: einzeln
            # -u: Datei fertigstellen, nächste URL bearbeiten
            if ( [[ "$eingabeTASTE" == "u" ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
            then
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'u'<br>Die aktuelle Datei wird fertig gestellt und danach die nächste URL bearbeitet.<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                echo -e "flagNEXTurl" > $dateiCACHEflagQUIT
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'u' - Datei fertigstellen, dann nächste URL bearbeiten" >> $dateiLOGS &
            fi
            
            
            # -FlagModusBefehlPlaylist: komplett
            # -u: Datei abbrechen, nächste URL bearbeiten
            if ( [[ "$eingabeTASTE" == "u" ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
            then
                [ -f $dateiCACHEflagQUIT ] && txtCACHEinternPID=`cat $dateiCACHEflagQUIT`
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'u'<br>Die aktuelle Datei ($txtCACHEinternPID) wird abgebrochen und dann die nächste URL bearbeitet.<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'u' - Datei abbrechen, dann nächste URL bearbeiten" >> $dateiLOGS &
                echo -e "flagNEXTurl" > $dateiCACHEflagQUIT
                fncKILLpid "$txtCACHEinternPID"
                FlagModusBefehlKOMPLETTquit="Taste-U"
            fi
            
            
            if ( [[ "$eingabeTASTE" == "f" ]] )
            then
                intSSpopup=20
                kdialog --passivepopup "--- INFO: $datei ---<br><br>Befehl: 'f'<br>Die aktuelle Datei/URL wird fertig gestellt und danach das Skript beendet!<br><br>Das Fenster wird nach $intSSpopup Sek. automatisch ausgeblendet." $intSSpopup &
                #[ -f "$dateiCACHEplsINFOS" ] && rm $dateiCACHEplsINFOS
                txtCACHEplsINFOS=`cat $dateiCACHEplsINFOS` && echo -e $txtCACHEplsINFOS"flagQUITpsTasteF" > $dateiCACHEplsINFOS && flagQUITpsTasteF="true"
                fncCHECKzugriffeLOGS && echo -e "\n[$datei] "`fncHHMMSS`" Befehl: 'f' - Datei/URL fertigstellen, dann Skript beenden" >> $dateiLOGS &
            fi
        done
        #stty -raw echo
        [ -f $dateiCACHEflagQUIT ] && txtCACHEstatus=`cat $dateiCACHEflagQUIT`
        #if ( [[ "$eingabeTASTE" == "q" ]] && [[ `cat $dateiCACHEflagQUIT` != "flagQUITps" ]] )
        if ( [[ "$eingabeTASTE" == "q" ]] && [[ "$txtCACHEstatus" != flagQUITps* ]] )
        then
            # -Q && NICHT flagQUITps* = Beendet durch: nur die Taste q, trueQ
            [[ "$flagQUIT" != *trueQ:* ]] && flagQUIT=$flagQUIT"trueQ:"
        fi
        #if ( [[ "$eingabeTASTE" != "q" ]] && [[ `cat $dateiCACHEflagQUIT` == "flagQUITps" ]] )
        if ( [[ "$eingabeTASTE" != "q" ]] && [[ "$txtCACHEstatus" == flagQUITps* ]] )
        then
            # -NICHT Q && flagQUITps* = Beendet durch: nur durch Prozesskontrolle ps
            [[ "$flagQUIT" != *truePS:* ]] && flagQUIT=$flagQUIT"truePS:"
        fi
        #if ( [[ "$eingabeTASTE" == "q" ]] && [[ `cat $dateiCACHEflagQUIT` == "flagQUITps" ]] )
        if ( [[ "$eingabeTASTE" == "q" ]] && [[ "$txtCACHEstatus" == flagQUITps* ]] )
        then
            # -Q && flagQUITps* = Beendet durch: Taste q und Prozesskontrolle ps
            [[ "$flagQUIT" != *trueQ-PS:* ]] && flagQUIT=$flagQUIT"trueQ-PS:"
        fi
        
        # -Beenden mittels Taste f: Weitergeleitet durch $dateiCACHEflagQUIT
        [[ "$txtCACHEstatus" == "flagQUITpsTasteF" ]] && [[ "$flagQUIT" != *tasteF-status0:* ]] && flagQUIT=$flagQUIT"tasteF-status0:"
        # -Beenden mittels Taste f: Weitergeleitet durch $flagQUITpsTasteF
        [[ "$flagQUITpsTasteF" == "true" ]] && [[ "$flagQUIT" != *tasteF-status0:* ]] && flagQUIT=$flagQUIT"tasteF-status0:"
    fi
    # -zur Aktualisierung des Status
    #fncSTATUSanzeigen
}

function CHECKeingabeTASTEeinmal {
    if ( [[ "$eingabeTASTE" != "e" ]] )
    then
        eingabeTASTE=""
        stty raw echo
        eingabeTASTE=`dd bs=1 count=1 2>/dev/null`
        # if ( [[ "$eingabeTASTE" != "q" ]] )
        # then
        #     tput cub 1
        #     echo -n "   "
        #     tput cub 3
        # fi
        stty -raw echo
    fi
}












# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Status aus Logdatei anzeigen ++++++++++++++++++++++++++++++++++++
echo -e "|----------------------------------------\n|- Status der Programmausführung:"
txtZEIT="["`date '+%T'`"]"
txtSTATUSausgabe="Warte auf Daten..."
txtPLAYLIST=""
echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabe${fmtRESET}"
echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabe${fmtRESET}"
echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabe${fmtRESET}"
if ( [[ "$txtPLAYLIST" != "" ]] )
then
    #echo -e "|- Playlist Infos: $txtPLAYLIST\n|-"
    echo -e "|- Bearbeitet wird: $txtPLAYLIST\n|----------------------------------------"
else
    echo -e "|- Aktuelle Datei wird ermittelt:\n|----------------------------------------"
fi
#echo -e "|----------------------------------------"

function fncCURSORposition {
    # -Zum Prüfen ob das Gesamtskript noch läuft: flagQUITps existiert nicht in  $dateiCACHEflagQUIT
    # -positionieren: tput cup Zeile Spalte
    typeset -i cursorZEILE=0
    typeset -i cursorZEILEstatus=0
    function getCPos { 
        local v=() t=$(stty -g)
        stty -echo
        printf "\033[6n"
        IFS='[;' read -ra v -d R
        stty $t
        CPos=(${v[@]:1})
    }
    getCPos
    cursorZEILE=$CPos
    zeileDELETE=`tput dl1`
    zeileINSERT=`tput il1`
    #cursorZEILEstatus=$cursorZEILE-2
    cursorZEILEstatus=$cursorZEILE-4
    while ( [[ "$actionKONTROLLE" != "stop" ]] )
    do
        sleep 10
        while read txtSTATUS
        do
            txtSTATUSausgabe=$txtSTATUS
        done < $dateiLOGS
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo -e "|- ${fmtFETT}\"$txtSTATUSausgabe\"${fmtRESET}"
    done
}


# -positionieren: tput cup Zeile Spalte
typeset -i cursorZEILE=0
typeset -i intANZAHLstatusZEILEN=0
typeset -i cursorZEILEstatus=0
typeset -i cursorZEILEkreisel=0

getCPos
cursorZEILE=$CPos
zeileDELETE=`tput dl1`
zeileINSERT=`tput il1`
intANZAHLstatusZEILEN=3
#cursorZEILEstatus=cursorZEILE-6
cursorZEILEstatus=cursorZEILE-6
cursorZEILEkreisel=cursorZEILE+3



# -Die txtSTATUS und txtPLAYLIST Variablen definieren, damit diese global sind!
txtSTATUS=""
txtSTATUSausgabe=""
txtSTATUSausgabeX0x=""
txtSTATUSausgabeX1x=""
txtSTATUSausgabeX2x=""
txtSTATUSausgabeX3x=""
txtSTATUSausgabeX4x=""
txtSTATUSausgabeX5x=""
txtPLAYLIST=""
txtURLanzeige="URL: -/-"
txtVIDPLSbearbeitungAKTUELL=""
txtPLAYLISTaktuell=""
txtPLAYLISTende=""
txtPLAYLISTvideo=""
txtTRENNERplaylist=""

#typeset -i txtURLanzeigeAKTUELL=0
#typeset -i txtURLanzeigeGESAMT=0
txtURLanzeigeAKTUELL=0
txtURLanzeigeGESAMT=0


function fncSTATUSkopierenLOGS {
    cp $dateiLOGS $dateiLOGStmp &
    actionCPlogsPID=$!
    while ( [[ `ps -p $actionCPlogsPID | grep $actionCPlogsPID` != "" ]] )
    do
        fncMOVEkreiselSLOW
    done
    echo -e "" >> $dateiLOGStmp
    echo -e "---EOF---" >> $dateiLOGStmp
    txtZEIT="["`date '+%T'`"]"
    txtPLAYLIST=""
    txtPLAYLISTvideo=""
    txtPLAYLISTaktuell=""
    txtPLAYLISTende=""
    typeset -i x=0
    
    fncSTATUSauslesenLOGS &
    fncMOVEkreiselSLOW
    
    #flagFEHLERlogs=$flagFEHLERlogs2
    #txtFEHLERlogs=$txtFEHLERlogs2
#     fncSTATUSauslesenLOGSpid=$!
#     while ( [[ `ps -p $fncSTATUSauslesenLOGSpid | grep $fncSTATUSauslesenLOGSpid` != "" ]] )
#     do
#         fncMOVEkreisel
#     done
}

function fncSTATUSauslesenLOGS {
    txtVIDPLSbearbeitungAKTUELL=""
    flagPLAYLIST="false"
    # -Die temporäre Logdatei wird zeilenweise eingelesen und verarbeitet:
    while read txtSTATUS
    do
        # -Wenn keine Playlist wird am Ende $txtVIDPLSbearbeitungAKTUELL hinzugefügt:
        [[ "$txtSTATUS" == *\ playlist* ]] && flagPLAYLIST="true"
        
        # -Text für Video bzw Playlist Infos auslesen:
        # -Bsp: [lxDOWNLOAD] 11:44:55 URL 1 von 6
        #[[ "$txtSTATUS" == \[$datei\]*URL*von* ]] && txtURLanzeigeKOMPLETT=${txtSTATUS//*URL /} && txtURLanzeigeAKTUELL=${txtURLanzeigeKOMPLETT// von*/} && txtURLanzeigeGESAMT=${txtURLanzeigeKOMPLETT//*von /} && txtURLanzeige="URL: $txtURLanzeigeAKTUELL/$txtURLanzeigeGESAMT"
        [[ "$txtSTATUS" == \[$datei\]*URL*von* ]] && txtURLanzeigeKOMPLETT=${txtSTATUS//*URL /} && txtURLanzeigeAKTUELL=${txtURLanzeigeKOMPLETT// von*/} && txtURLanzeigeGESAMT=${txtURLanzeigeKOMPLETT//*von /} && txtURLanzeigeGESAMT=${txtURLanzeigeGESAMT// \-*/} && txtURLanzeige="URL: $txtURLanzeigeAKTUELL/$txtURLanzeigeGESAMT"
        
        # -Bsp: [download] Destination: Folge_10_-_Liebe_und_Monster_S02_E10-89087280.mp4
        # -Bsp: [download] Destination: playlist_7844175181/22_Stanton-Warriors_UWS-Brighton.mp4
        # -Bsp: [download] Stanton Warriors UWS Brighton has already been recorded in archive
        [[ "$txtSTATUS" == \[download\]*Destination:* ]] && txtVIDPLSbearbeitungAKTUELL=${txtSTATUS//*Destination: /}
        #[[ "$txtSTATUS" == \[download\]*has\ already\ been\ recorded\ in\ archive ]] && txtVIDPLSbearbeitungAKTUELL=${txtSTATUS//*download\] /} && txtVIDPLSbearbeitungAKTUELL=${txtVIDPLSbearbeitungAKTUELL// has already been recorded in archive/}
        [[ "$txtSTATUS" == \[download\]*has\ already\ been\ recorded\ in\ archive ]] && txtVIDPLSbearbeitungAKTUELLanfang=${txtSTATUS//*download\] /} && txtVIDPLSbearbeitungAKTUELL=${txtVIDPLSbearbeitungAKTUELLanfang// has already been recorded in archive/ (Bereits heruntergeladen.)}
        
        
        # -FlagModusBefehlPlaylist: einzeln
        if ( [[ "$txtSTATUS" == *\]\ Downloading\ video*of* ]] && [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
        then
            txtPLAYLISTvideoLOGS=${txtSTATUS//*video /}
            txtPLAYLISTvideoLOGS=${txtPLAYLISTvideoLOGS//of/von}
            txtPLAYLISTvideoLOGSitem=${txtPLAYLISTvideoLOGS// von*/}
            txtPLAYLISTvideoLOGS=" (Video $txtPLAYLISTvideoLOGS)"
            
            [ -f $dateiCACHEplsINFOS ] && txtPLAYLISTzaehlerGESAMT=`cat $dateiCACHEplsINFOS`
            [ -n "$txtPLAYLISTzaehlerGESAMT" ] && txtPLAYLISTzaehlerGESAMTsicherung="$txtPLAYLISTzaehlerGESAMT" && txtPLAYLISTbeenden=""
            [ -z "$txtPLAYLISTzaehlerGESAMT" ] && [ -n "$txtPLAYLISTzaehlerGESAMTsicherung" ] && txtPLAYLISTzaehlerGESAMT="$txtPLAYLISTzaehlerGESAMTsicherung" && txtPLAYLISTbeenden=" Beenden (f) eingeleitet!"
            txtPLAYLISTvideo=" (Video $txtPLAYLISTzaehlerGESAMT)$txtPLAYLISTbeenden"
            #txtPLAYLIST=" $txtPLAYLISTaktuell$txtPLAYLISTvideo$txtTRENNERplaylist$txtPLAYLIST"
            #txtVIDEOstatus=" $txtPLAYLISTzaehlerGESAMT"
        fi
        
        # -FlagModusBefehlPlaylist: komplett
        if ( [[ "$txtSTATUS" == *\]\ Downloading\ video*of* ]] && [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
        then
            txtPLAYLISTvideoLOGS=${txtSTATUS//*video /}
            txtPLAYLISTvideoLOGS=${txtPLAYLISTvideoLOGS//of/von}
            txtPLAYLISTvideoLOGSitem=${txtPLAYLISTvideoLOGS// von*/}
            txtPLAYLISTvideoLOGS=" (Video $txtPLAYLISTvideoLOGS)"
            
            txtPLAYLISTvideo="$txtPLAYLISTvideoLOGS""$txtPLAYLISTbeenden"
            #txtPLAYLIST=" $txtPLAYLISTaktuell$txtPLAYLISTvideo$txtTRENNERplaylist$txtPLAYLIST"
            #txtVIDEOstatus=" $txtPLAYLISTzaehlerGESAMT"
        fi
        
        
        if ( [[ "$txtSTATUS" == *\]\ Downloading\ playlist:* ]] )
        then
            txtPLAYLISTaktuellKONTROLLE=${txtSTATUS//*playlist: /}
            if ( [[ "$txtPLAYLISTende" != "" ]] )
            then
                txtTRENNERaufzaehlung=", "
            else
                txtTRENNERaufzaehlung=""
            fi
            if ( [[ "$txtPLAYLISTaktuell" != "" ]] && [[ "$txtPLAYLISTaktuell" != "$txtPLAYLISTaktuellKONTROLLE" ]] )
            then
                txtPLAYLISTende="$txtPLAYLISTaktuell$txtTRENNERaufzaehlung$txtPLAYLISTende"
            fi
            if ( [[ "$txtPLAYLISTende" != "" ]] )
            then
                txtTRENNERplaylist="- Fertig: "
            else
                txtTRENNERplaylist=""
            fi
            txtPLAYLISTaktuell=${txtSTATUS//*playlist: /}
            #txtPLAYLISTende="$txtTRENNERplaylist$txtPLAYLISTaktuell"
        #else
            #txtPLAYLISTaktuell="$txtVIDEOstatus"
        fi
        
        
        # -Statuszeile kürzen, damit kein Umbruch erfolgt und Status in eine Zeile passt!
        #  maximale Anzahl Zeichen: intLayoutMaxSpalten-intAnzahlZeichenRandUhrzeit
        typeset -i intAnzahlZeichenRandUhrzeit=`fncANZAHLzeichen "|- [09:31:37] "`
        intSTATUSzeichenMAX=intLayoutMaxSpalten-intAnzahlZeichenRandUhrzeit
        
        typeset -i intSTATUSzeichenKONTROLLE=0
        # -da Position mit null beginnt muss der Kontrollwert intSTATUSzeichenKONTROLLE nicht
        #  um eins erhöht werden
        # -wenn nach der maximalen Anzahl Zeichen der String noch weitergeht wird er gekürzt:
        intSTATUSzeichenKONTROLLE=$intSTATUSzeichenMAX
        intSTATUSzeichen=`echo $txtSTATUS | awk '{print length($txtSTATUS)}'`
        #strSTATUSzeichenKONTROLLE=${txtSTATUS:$intSTATUSzeichenKONTROLLE:1}
        #if ( [[ "$strSTATUSzeichenKONTROLLE" != "" ]] )
        if ( [[ "$intSTATUSzeichen" -gt $intSTATUSzeichenMAX ]] && [[ "$txtSTATUS" != *%\ of* ]] )
        then
            #txtSTATUS=${txtSTATUS:0:$intSTATUSzeichenMAX}"..."
            txtSTATUS=${txtSTATUS:0:$intSTATUSzeichenMAX}
        fi
        txtSTATUSausgabeX5x=$txtSTATUSausgabeX4x
        txtSTATUSausgabeX4x=$txtSTATUSausgabeX3x
        txtSTATUSausgabeX3x=$txtSTATUSausgabeX2x
        txtSTATUSausgabeX2x=$txtSTATUSausgabeX1x
        txtSTATUSausgabeX1x=$txtSTATUSausgabeX0x
        txtSTATUSausgabeX0x=$txtSTATUS
        # -Alte Variable wird teilweise noch abgefragt:
        txtSTATUSausgabe=$txtSTATUSausgabeX0x
    done < $dateiLOGStmp
    
    [[ "$flagPLAYLIST" != "true" ]] && [ -n "$txtVIDPLSbearbeitungAKTUELL" ] && txtURLanzeige="$txtURLanzeige - $txtVIDPLSbearbeitungAKTUELL"
    #echo -e "--- DEBUG flagPLAYLIST: $flagPLAYLIST - txtVIDPLSbearbeitungAKTUELL: $txtVIDPLSbearbeitungAKTUELL"
    [[ "$txtPLAYLISTaktuell" != "" ]] && [[ "$txtPLAYLISTaktuell" != -* ]] && txtPLAYLISTaktuell="- $txtPLAYLISTaktuell"
    
#     echo $txtSTATUS > $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabe >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX0x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX1x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX2x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX3x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX4x >> $dateiLOGStmpSTATUS
#     echo $txtSTATUSausgabeX5x >> $dateiLOGStmpSTATUS
#     echo $txtPLAYLIST >> $dateiLOGStmpSTATUS
#     echo -e "$txtURLanzeige $txtPLAYLISTaktuell" >> $dateiLOGStmpSTATUS
#     echo $txtPLAYLISTende >> $dateiLOGStmpSTATUS
#     echo $txtPLAYLISTvideo >> $dateiLOGStmpSTATUS
#     echo -e "$txtTRENNERplaylist" >> $dateiLOGStmpSTATUS
    
    echo -e $txtSTATUS > $dateiLOGStmpSTATUS
    echo -e "$txtSTATUSausgabe"\\n"$txtSTATUSausgabeX0x"\\n"$txtSTATUSausgabeX1x"\\n"$txtSTATUSausgabeX2x"\\n"$txtSTATUSausgabeX3x"\\n"$txtSTATUSausgabeX4x"\\n"$txtSTATUSausgabeX5x"\\n"$txtPLAYLIST"\\n"$txtURLanzeige $txtPLAYLISTaktuell"\\n"$txtPLAYLISTende"\\n"$txtPLAYLISTvideo"\\n"$txtTRENNERplaylist" >> $dateiLOGStmpSTATUS
    
    #echo -e $txtPLAYLISTvideoLOGSitem > $dateiCACHEplsINFOSitem
}

function fncSTATUSanzeigen {
    while ( [[ ! -f "$dateiLOGStmpSTATUS" ]] )
    do
        sleep 0.2
    done
    
    typeset -i x=0
    while read txtTMPstatus
    do
        arrTMPstatus[$x]=$txtTMPstatus
        x=x+1
    done < $dateiLOGStmpSTATUS
    x=0
    txtSTATUS="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabe="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX0x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX1x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX2x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX3x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX4x="${arrTMPstatus[$x]}"
    x=x+1
    txtSTATUSausgabeX5x="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLIST="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLISTaktuell="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLISTende="${arrTMPstatus[$x]}"
    x=x+1
    txtPLAYLISTvideo="${arrTMPstatus[$x]}"
    x=x+1
    txtTRENNERplaylist="${arrTMPstatus[$x]}"
    x=x+1
    rm $dateiLOGStmpSTATUS >/dev/null 2>&1

    # -Zum Prüfen ob das Gesamtskript noch läuft: flagQUITps existiert nicht in  $dateiCACHEflagQUIT
        #cursorZEILEstatus=cursorZEILE-6
        cursorZEILEstatus=cursorZEILE-6
#       
#       Ehemalige Position: cp Logs und auslesen!!!
#       
        txtPLAYLIST="$txtPLAYLISTaktuell $txtPLAYLISTvideo $txtTRENNERplaylist $txtPLAYLISTende"
        txtSTATUSausgabeX0=$txtSTATUSausgabeX0x
        txtSTATUSausgabeX1=$txtSTATUSausgabeX1x
        txtSTATUSausgabeX2=$txtSTATUSausgabeX2x
        #echo -e "|- --- 0: $txtSTATUSausgabeX0 - 1: $txtSTATUSausgabeX1 - 2: $txtSTATUSausgabeX2 - 3: $txtSTATUSausgabeX3"
        if ( [[ "$txtSTATUSausgabe" == "---EOF---" ]] || [[ "$txtSTATUSausgabe" == "" ]] )
        then
            txtSTATUSausgabeX0=$txtSTATUSausgabeX1x
            txtSTATUSausgabeX1=$txtSTATUSausgabeX2x
            txtSTATUSausgabeX2=$txtSTATUSausgabeX3x
            txtSTATUSausgabe=$txtSTATUSausgabeX0
            if ( [[ "$txtSTATUSausgabe" == "---EOF---" ]] || [[ "$txtSTATUSausgabe" == "" ]] )
            then
                txtSTATUSausgabeX0=$txtSTATUSausgabeX2x
                txtSTATUSausgabeX1=$txtSTATUSausgabeX3x
                txtSTATUSausgabeX2=$txtSTATUSausgabeX4x
                txtSTATUSausgabe=$txtSTATUSausgabeX0
                if ( [[ "$txtSTATUSausgabe" == "---EOF---" ]] || [[ "$txtSTATUSausgabe" == "" ]] )
                then
                    txtSTATUSausgabeX0=$txtSTATUSausgabeX3x
                    txtSTATUSausgabeX1=$txtSTATUSausgabeX4x
                    txtSTATUSausgabeX2=$txtSTATUSausgabeX5x
                    txtSTATUSausgabe=$txtSTATUSausgabeX0
                fi
            fi
        fi
        #txtSTATUSausgabe=${txtSTATUSausgabe//*[download]/}
        #txtSTATUSausgabe=${txtSTATUSausgabe//*[/[}
        txtSTATUSausgabeX2=${txtSTATUSausgabeX2//*[/[}
        txtSTATUSausgabeX1=${txtSTATUSausgabeX1//*[/[}
        txtSTATUSausgabeX0=${txtSTATUSausgabeX0//*[/[}
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        txtZEIT="["`date '+%T'`"]"
        echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabeX2${fmtRESET}"
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        txtZEIT="["`date '+%T'`"]"
        echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabeX1${fmtRESET}"
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        txtZEIT="["`date '+%T'`"]"
        echo -e "|- ${fmtFETT}$txtZEIT $txtSTATUSausgabeX0${fmtRESET}"
#         cursorZEILEstatus=cursorZEILEstatus+1
#         tput cup $cursorZEILEstatus 0
#         echo $zeileDELETE
#         tput cup $cursorZEILEstatus 0
#         echo $zeileINSERT
#         tput cup $cursorZEILEstatus 0
#         echo -e "|-"
        #rm $dateiLOGStmp
        if ( [[ "$txtPLAYLIST" != "" ]] )
        then
            cursorZEILEstatus=cursorZEILEstatus+1
            tput cup $cursorZEILEstatus 0
            echo $zeileDELETE
            tput cup $cursorZEILEstatus 0
            echo $zeileINSERT
            tput cup $cursorZEILEstatus 0
            #echo -e "|- Video Infos: $txtPLAYLIST"
            echo -e "|- $txtPLAYLIST"
        fi
        cursorZEILEstatus=cursorZEILEstatus+1
        tput cup $cursorZEILEstatus 0
        echo $zeileDELETE
        tput cup $cursorZEILEstatus 0
        echo $zeileINSERT
        tput cup $cursorZEILEstatus 0
        echo -e "|----------------------------------------"
        
    #done
}
#fncSTATUSanzeigen &
# +++++ ENDE Status aus Logdatei anzeigen +++++++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++








# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Hintergrund Funktionen aufrufen: ++++++++++++++++++++++++++++++++
#
# -fncBEFEHLaufrufen: Download der URLs wird einzeln gestartet
# -fncMOVEasciiKREISEL: Um anzuzeigen dass das Skript noch arbeitet
#
# fncBEFEHLaufrufen &
# checkBEFEHLreturn=$?
# checkBEFEHLpid=$!

echo -e "|-"
#echo -e "|- Skript sofort beenden: 'q' --- Skript nach der aktuellen Datei beenden: 'f'"
#echo -e "|- Skript sofort beenden: 'q' --- Aktuelle Datei fertigstellen, dann Skript beenden: 'f'"

# echo -e "|- 'q':\\tAktuelle Datei abbrechen, dann das Skript beenden."
# if ( [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
# then
#     echo -e "|- 'f':\\tAktuelle Datei fertigstellen, dann das Skript beenden."
#     echo -e "|- 'u':\\tAktuelle Datei fertigstellen, dann die nächste URL/Playliste bearbeiten."
# elif ( [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
# then
#     echo -e "|- 'f':\\tAktuelle URL fertigstellen, dann das Skript beenden."
#     echo -e "|- 'u':\\tAktuelle URL abbrechen, dann die nächste URL/Playliste bearbeiten."
# fi



if ( [[ "$FlagModusBefehlPlaylist" == "einzeln" ]] )
then
    #echo -e "|- 'q':\\tSkript beenden, aktuelle Datei wird abgebrochen.\\t\\t'f':\\tSkript beenden, aktuelle Datei wird fertiggestellt."
    #echo -e "|- 'q':\\tAktuelle Datei abbrechen und Skript beenden.\\t\\t'f':\\tAktuelle Datei fertigstellen und Skript beenden."
    #echo -e "|- 'f':\\tSkript beenden, aktuelle Datei wird fertiggestellt."
    #echo -e "|- 'd':\\tAktuelle Datei abbrechen und nächste Datei bearbeiten. (URL/Playliste unverändert)"
    #echo -e "|- 'u':\\tAktuelle Datei fertigstellen, dann die nächste URL/Playliste bearbeiten."
    
    echo -e "|- 'q':\\tDownload abbrechen und das Skript beenden.\\t\\t | 'f': Datei fertig downloaden und dann das Skript beenden."
    echo -e "|- 'u':\\tDatei fertigstellen und die nächste URL/Playliste\\t | 'd': Download abbrechen und nächste Datei bearbeiten."
    echo -e "|-\\tbearbeiten.\\t\\t\\t\\t\\t\\t |"
    
elif ( [[ "$FlagModusBefehlPlaylist" == "komplett" ]] )
then
    echo -e "|- 'q':\\tDownload abbrechen und das Skript beenden.\\t\\t | 'f': URL/Playliste fertig downloaden und dann das Skript beenden."
    echo -e "|- 'u':\\tDownload abbrechen und die nächste URL/Playliste\\t |"
    echo -e "|-\\tbearbeiten.\\t\\t\\t\\t\\t\\t |"
fi





echo -n "|- $datei wird ausgeführt... "

fncMOVEasciiKREISEL &
fncMOVEasciiKREISELpid=$!
#
# +++++ ENDE Hintergrund Funktionen aufrufen: +++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++










# -Die Ausgabe abschalten. Wegen kill Status/Fehler Meldungen.
##exec >/dev/null 2>&1


while ( [[ `ps -p $checkBEFEHLpid | grep $checkBEFEHLpid` != "" ]] && [[ "$actionKONTROLLE" != "stop" ]] )
do
    nix=1
    CHECKeingabeTASTE
    CHECKeingabeTASTEpid=$!
    if ( [[ "$eingabeTASTE" == "q" ]] )
    then
        #flagERFOLGREICHabgeschlossen="true"
        #kill -9 $CHECKeingabeTASTEpid
        fncKILLpid $CHECKeingabeTASTEpid
        break
    fi
    #kill -9 $CHECKeingabeTASTEpid
    fncKILLpid $CHECKeingabeTASTEpid
done


#fncDEBUGstart


# -Der Exitstatus wird anhand von $eingabeTASTE und $actionKONTROLLE erneut
#  ausgewertet und im $flagQUITkontrolle gespeichert:
flagQUITkontrolle=""
tput cub 1
if ( [[ "$eingabeTASTE" == "q" ]] || [[ "$eingabeTASTE" == "f" ]] )
then
    # -Den checkBEFEHLreturn Status kontrollieren und ggf korrigieren!
    # --Skript wurde normal beendet: 0
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="1"
    flagQUITkontrolle=$eingabeTASTE"_1"
elif ( [[ "$FlagModusBefehlKOMPLETTquit" == "Taste-U" ]] )
then
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="1"
    flagQUITkontrolle="ModusKomplettTaste-U_1"
elif ( [[ "$actionKONTROLLE" == "stop" ]] )
then
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="0"
    flagQUITkontrolle="ps-KREISEL_$checkBEFEHLreturn"
else
    # -Nicht Q && $actionKONTROLLE == start
    # -Die WhilePSdoCHECKeingabeTASTE hat den Fehler (kein Prozess) erkannt
    [[ "$checkBEFEHLreturn" == "" ]] && checkBEFEHLreturn="2"
    flagQUITkontrolle="ps-WHILE_$checkBEFEHLreturn"
fi

#checkKILLreturnKREISEL=`kill -9 $fncMOVEasciiKREISELpid >/dev/null 2>/dev/null`
#`kill -9 $fncMOVEasciiKREISELpid >/dev/null 2>&1`
if ( [[ "$actionKONTROLLE" != "stop" ]] )
then
    #kill -9 $fncMOVEasciiKREISELpid
    fncKILLpid $fncMOVEasciiKREISELpid
fi

#tput cub 1



# -SONDERFALL: Zeile davor enthält kein Newline Zeichen (wegen 'echo -en')
getCPos
[ "$CPosSPALTE" -gt 1 ] && echo -e ""
#echo -e "--- $CPosSPALTE"

fncKILLallePROZESSE "EIGENESTTY" >/dev/null 2>&1
#$0 "-PSK" "EIGENESTTY" >/dev/null 2>&1










# -die temporäre Logdatei wird wieder entfernt:
rm $dateiLOGStmp



# -------------------------------------------------------------------
# -ABLAGE: Alte Befehle:
# `$checkBEFEHL` >> $dateiLOGS
#`$checkBEFEHL` >> $dateiLOGS 2> `tty`
#checkBEFEHLreturn=$?
#echo -e "|- checkBEFEHL: $?"
# -------------------------------------------------------------------

# -die Original Archiv Datei aus der Config auslesen
# -das temporäre Archiv an die Original Archiv Datei anhängen
# -das temporäre Archiv löschen
if ( [[ "$flagForceGlobal" == "true" ]] && [[ -f "$archivTMP" ]] )
then
#     # +++++ START Config auslesen
#     while read txtCONFIG
#     do
#         #nix=1
#         if ( [[ "$txtCONFIG" == --download-archiv* ]] )
#         then
#             archivORIGINAL=${txtCONFIG//\-\-download\-archiv /}
#             #echo $archivORIGINAL
#             break
#         fi
#     done < ~/.config/youtube-dl/config
#     # +++++ ENDE Config auslesen

    # +++++ START archivTMP anhängen an archivORIGINAL
    while read txtTMP
    do
        echo $txtTMP >> $archivORIGINAL
    done < $archivTMP
    # +++++ ENDE archivTMP anhängen an archivORIGINAL

    # -das archivTMP löschen:
    rm $archivTMP
fi
if ( [[ -f "$archivTMP" ]] )
then
    rm $archivTMP
fi







# -Die Ausgabe wieder auf den Bildschirm legen:
##exec >`tty` 2>&1
#exec >`tty` 2>>$dateiLOGS




# DEBUG-INFO:
#echo -e $txtCHECKpsKILL






fncCHECKzugriffeLOGS



#fncAUSLESENbefehlINTERN
#echo -e "--- DEBUG-INFO: BEFEHLinternPID: $checkBEFEHLinternPID - BEFEHLinternRETURN: $checkBEFEHLinternRETURN"
#echo -e "--- DEBUG-INFO: $txtCHECKpsKILL"
# -Ende: Zeit und Status anzeigen
zeitENDE=`date`
#txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Details:\t$dateiLOGS $flagQUIT PID.$checkBEFEHLpid RETURN.$checkBEFEHLreturn \
# - PID.$checkBEFEHLinternPID RETURN.$checkBEFEHLinternRETURN"


# if ( [[ "$checkBEFEHLreturn" == "0" ]] )
# then
#     txtINFOstatus="Das Skript wurde normal beendet. $txtINFOstatusDETAILS"
#     flagERFOLGREICHabgeschlossen="true"
# else
#     txtINFOstatus="Das Skript wurde vom Benutzer abgebrochen. $txtINFOstatusDETAILS"
#     flagERFOLGREICHabgeschlossen="true"
# fi

[ -f $dateiCACHEflagCHECKurlsKOMPLETT ] && flagCHECKurlsKOMPLETT=`cat $dateiCACHEflagCHECKurlsKOMPLETT`

if ( [[ "$flagQUIT" == *truePS:* ]] )
then
    [[ "$flagCHECKurlsKOMPLETT" == "true" ]] && txtINFOstatus="Das Skript wurde erfolgreich abgeschlossen." && checkBEFEHLreturn="0"
    [[ "$flagCHECKurlsKOMPLETT" != "true" ]] && txtINFOstatus="Das Skript wurde erfolgreich abgeschlossen." && checkBEFEHLreturn="1"
fi

if ( [[ "$FlagModusBefehlKOMPLETTquit" == "Taste-U" ]] )
then
    txtINFOstatus="Bearbeitung der URLs wurde teilweise abgebrochen. Befehl: 'u'"
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="1"
fi
if ( [[ "$flagQUIT" == *tasteF-status0:* ]] || [[ "$flagQUITpsTasteF" == "true" ]] )
then
    txtINFOstatus="Das Skript wurde vom Benutzer beendet. Befehl: 'f'"
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="1"
    #[[ "$FlagModusBefehlPlaylist" == "komplett" ]] && [[ "$flagCHECKurlsKOMPLETT" == "true" ]] && checkBEFEHLreturn="0"
fi
if ( [[ "$flagQUIT" == *trueQ:* ]] )
then
    txtINFOstatus="Das Skript wurde vom Benutzer abgebrochen. Befehl: 'q'"
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="1"
fi
if ( [[ "$flagQUIT" == *trueQ-PS:* ]] )
then
    txtINFOstatus="Das Skript wurde vom Benutzer oder einem anderen Prozess abgebrochen."
    #flagERFOLGREICHabgeschlossen="true"
    checkBEFEHLreturn="2"
fi

case "$flagQUITkontrolle" in
    ( *0 )
        # -kein Fehler!
        txtINFOstatusKONTROLLE=\\n"|- Check: \\tEs gab keine internen Fehler."
        #checkBEFEHLreturn="0"
        ;;
    ( *1 )
        # -Abbruch durch Benutzer!
        txtINFOstatusKONTROLLE=\\n"|- Check: \\tKontrolle wurde durch den Benutzer abgebrochen."
        checkBEFEHLreturn="1"
        ;;
    ( *2 )
        # -Abbruch durch Fehler!
        txtINFOstatusKONTROLLE=\\n"|- Check: \\tKontrolle wurde durch einen unbekannten Fehler abgebrochen."
        checkBEFEHLreturn="2"
        ;;
esac

[[ "$flagCHECKurlsKOMPLETT" != "true" ]] && txtINFOstatusKONTROLLE=\\n"|- Check: \\tNicht alle URLs konnten (erfolgreich) bearbeitet werden."

[[ "$flagQUITkontrolle" == "ModusKomplettTaste-U_1" ]] && txtINFOstatusKONTROLLE=\\n"|- Check: \\tURL Kontrolle wurde durch den Benutzer abgebrochen."


txtINFOstatusDETAILS=" (urls-$flagCHECKurlsKOMPLETT.f-$flagQUITpsTasteF.$flagQUITkontrolle.$flagQUIT$checkBEFEHLpid.$checkBEFEHLreturn.$checkBEFEHLreturnORIGINAL)"

#txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Status:\\t$txtINFOstatus$txtINFOstatusDETAILS$txtINFOstatusKONTROLLE"\\n"|-"
#txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Status:\\t$txtINFOstatus""$txtINFOstatusKONTROLLE""$txtINFOstatusDETAILS"\\n"|-"
txtINFOende=$txtENDEzeit$zeitENDE\\n"|- Status:\\t$txtINFOstatus""$txtINFOstatusKONTROLLE""$txtINFOstatusDETAILS"
echo -e $txtINFOende
echo -e $txtINFOende >> $dateiLOGS

#if ([[ "$eingabeTASTE" == "e" ]]  )
if ( [[ "$actionKONTROLLE" == "stop" ]]  )
then
    checkBEFEHLreturn="0"
fi











typeset -i intANZaufrufeGESAMT=0
typeset -i intANZaufrufeGESAMTkontrolle=0
typeset -i intANZaufrufeINarchive=0
typeset -i intANZaufrufeDOWNLOADjetzt=0
typeset -i intANZaufrufeFEHLER=0
function fncLOGScheckAUFRUFE {
    # -Die Integer Variablen müssen außerhalb der Funktion definiert werden,
    #  damit sie wirklich global sind!!!
    while read txtSTATUS
    do
        # -Anzahl der Aufrufe auswerten:
        # --Gesamtaufrufe!
        # --Bereits heruntergeladen!
        # --Jetzt erfolgreich heruntergeladen!
        [[ "$txtSTATUS" == *Downloading\ video*of* ]] && intANZaufrufeGESAMT=intANZaufrufeGESAMT+1
        
        [[ "$txtSTATUS" == \[download\]*been\ recorded\ in\ archive* ]] && intANZaufrufeINarchive=intANZaufrufeINarchive+1 && intANZaufrufeGESAMTkontrolle=intANZaufrufeGESAMTkontrolle+1
        
        [[ "$txtSTATUS" == *100\%\ of* ]] && intANZaufrufeDOWNLOADjetzt=intANZaufrufeDOWNLOADjetzt+1 && intANZaufrufeGESAMTkontrolle=intANZaufrufeGESAMTkontrolle+1
    done < $dateiLOGS
}
fncLOGScheckAUFRUFE


# -Anzahl Videos kontrollieren und ggf korrigieren:
typeset -i intAnzUrlsGesamt=${#eingabeURLarray[@]}
[ "$intANZaufrufeGESAMTkontrolle" -lt "$intAnzUrlsGesamt" ] && intANZaufrufeGESAMTkontrolle="$intAnzUrlsGesamt"
[ "$intANZaufrufeGESAMT" -lt "$intANZaufrufeGESAMTkontrolle" ] && intANZaufrufeGESAMT="$intANZaufrufeGESAMTkontrolle"
intANZaufrufeFEHLER=`echo -e "scale=0 ; $intANZaufrufeGESAMT-($intANZaufrufeINarchive+$intANZaufrufeDOWNLOADjetzt)" | bc -l`


# -Anzeige von Status Info: Anzahl Videos bzw URLs 
txtINFOendeANZaufrufe="|- Anzahl:\\t$txtStandardDownloadPlural gesamt: $intANZaufrufeGESAMT - Neue Downloads: $intANZaufrufeDOWNLOADjetzt - Bereits geladen: $intANZaufrufeINarchive - Fehler/Abbruch: $intANZaufrufeFEHLER"\\n"|-"
echo -e $txtINFOendeANZaufrufe
echo -e $txtINFOendeANZaufrufe >> $dateiLOGS

# txtINFOendeANZaufrufe="|- Anzahl: $intANZaufrufeGESAMT - $intANZaufrufeDOWNLOADjetzt - $intANZaufrufeINarchive - $intANZaufrufeFEHLER (Videos gesamt - Neue Downloads - Bereits heruntergeladen - Fehler/Abbruch)"\\n"|-"
# echo -e $txtINFOendeANZaufrufe
# echo -e $txtINFOendeANZaufrufe >> $dateiLOGS




#fncDEBUGstop





# echo -e "|-----"
# echo -e "DEBUG: flagFEHLERlogs  : $flagFEHLERlogs"
# echo -e "DEBUG: flagFEHLERlogs2 : $flagFEHLERlogs2"
# echo -e "DEBUG: txtFEHLERlogs   : $txtFEHLERlogs"
# echo -e "DEBUG: txtFEHLERlogs2  : $txtFEHLERlogs2"
# echo -e "|-----"


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# +++++ START Endkontrolle und Status anzeigen ++++++++++++++++++++++++++++++++
# -Rückgabewert des Befehls kontrollieren
# -Logdatei auf Fehler kontrollieren: fncLOGScheckFEHLER
# --Diese setzt: flagFEHLERlogs, txtFEHLERlogs
# -Am Ende des Skripts muss die Infozeile angepasst und verhindert werden, dass
#  die aktuellen URLs gelöscht werden
#
# -Logdatei mit Zeilennummern versehen, damit Fehlermeldungen besser
#  zugeordnet werden können!
# --Zuerst alle Zeilennummern einfügen und dann den Fehlercheck starten.


function fncLOGSzeilennummern {
    #fncDEBUGstart "Zeilennummern"
    # -Maximale Anzahl an Zeilen ermitteln, damit klar ist wieviele Stellen für die
    #  Zeilennummern gebraucht werden.
    typeset -i intANZAHLzeichenZEILEN=0
    typeset -i intZEILENNUMMER=0
    intANZAHLzeilenLOGS=`wc -l $dateiLOGS`
    #echo -e "--- DEBUG-INFO: Anzahl Zeilen: $intANZAHLzeilenLOGS"
    intANZAHLzeilenLOGS=${intANZAHLzeilenLOGS// */}
    #echo -e "--- DEBUG-INFO: Anzahl Zeilen: $intANZAHLzeilenLOGS"
    intANZAHLzeichenZEILEN=`echo $intANZAHLzeilenLOGS | wc -m`
    intANZAHLzeichenZEILEN=intANZAHLzeichenZEILEN-1
    #echo -e "--- DEBUG-INFO: Anzahl Zeichen: $intANZAHLzeichenZEILEN"
    
    while read txtLOGS
    do
        #txtLOGStrESCAPE=`echo -e "$txtLOGS" | tr -d '\r\n'`
        #txtLOGS="$txtLOGStrESCAPE"
        echo -e "$txtLOGS" >> $dateiLOGStmp
    done < $dateiLOGS
    
    while [ ! -f $dateiLOGStmp ]
    do
        sleep 0.1
    done
    mv $dateiLOGStmp $dateiLOGS
    while [ ! -f $dateiLOGS ]
    do
        sleep 0.1
    done
    
    while read txtLOGS
    do
        [[ "$txtLOGS" == "" ]] && continue
        intZEILENNUMMER=intZEILENNUMMER+1
        #echo -e "--- DEBUG ---"
        #echo -e "--- DEBUG --- txtLOGS original: $txtLOGS"
        #txtLOGStrZIFFERN=`echo -e "$txtLOGS" | tr -d '\000-\011\013\014\016-\037'`
        #echo -e "--- DEBUG --- txtLOGS Ziffern: $txtLOGStrZIFFERN"
        #txtLOGStrR=`echo -e "$txtLOGS" | tr -d '\r'`
        #echo -e "--- DEBUG --- txtLOGS nur r: $txtLOGStrR"
        #txtLOGStrN=`echo -e "$txtLOGS" | tr -d '\n'`
        #echo -e "--- DEBUG --- txtLOGS nur n: $txtLOGStrN"
        
        # -Download Prozentangabe wird mit $txtLOGStrESCAPE komplett ausgelesen und
        #  gleichzeitig bleiben Leerzeichen und Tabs erhalten!
        txtLOGStrESCAPE=`echo -e "$txtLOGS" | tr -d '\r'`
        txtLOGS="$txtLOGStrESCAPE"
        #echo -e "--- DEBUG --- txtLOGS r und n: $txtLOGStrESCAPE"
        
        #txtLOGS=${txtLOGS//\\r/}
        #echo -e "--- DEBUG --- intZEILENNUMMER: $intZEILENNUMMER"
        
        # -Fehlende Zeilennummer: Download Prozentangabe
        if [[ "$txtLOGS" == \[download\]*\%\ of* ]]
        then
            #typeset -i intANZAHLzeichenLOGS=0
            #typeset -i intANZAHLzeichenAUSSCHNEIDEN=0
            #intLOGSzeichen=${#txtLOGS}
            [[ "$txtLOGS" == *100\%* ]] && txtLOGS=${txtLOGS//*100\%/100\%} && txtLOGS="[download] "$txtLOGS
            [[ "$txtLOGS" != *100\%* ]] && txtLOGS=${txtLOGS:0:140}
        fi
        
        
        while [[ "$txtLOGS" != \|*$intZEILENNUMMER\|* ]]
        do
            case "$intANZAHLzeichenZEILEN" in
                (1)
                    # -Zeilennummern haben maximal 1 Zeichen:
                    txtLOGS="|"`printf %01d $intZEILENNUMMER`"| $txtLOGS" ;;
                (2)
                    # -Zeilennummern haben maximal 2 Zeichen:
                    txtLOGS="|"`printf %02d $intZEILENNUMMER`"| $txtLOGS" ;;
                (3)
                    # -Zeilennummern haben maximal 3 Zeichen:
                    txtLOGS="|"`printf %03d $intZEILENNUMMER`"| $txtLOGS" ;;
                (4)
                    # -Zeilennummern haben maximal 4 Zeichen:
                    txtLOGS="|"`printf %04d $intZEILENNUMMER`"| $txtLOGS" ;;
                (5)
                    # -Zeilennummern haben maximal 5 Zeichen:
                    txtLOGS="|"`printf %05d $intZEILENNUMMER`"| $txtLOGS" ;;
                (6)
                    # -Zeilennummern haben maximal 6 Zeichen:
                    txtLOGS="|"`printf %06d $intZEILENNUMMER`"| $txtLOGS" ;;
            esac
            #echo -e "--- DEBUG --- nach-CASE - txtLOGS: $txtLOGS"
            #echo -e "--- DEBUG --- nach-CASE - intZEILENNUMMER: $intZEILENNUMMER"
        done
        #echo -e "$txtLOGS" >> $dateiLOGStmp
        echo -e "$txtLOGS" >> $dateiLOGStmp
    done < $dateiLOGS
    cp $dateiLOGS $dateiLOGStmpOHNEzeilennummern
    rm $dateiLOGS
    mv $dateiLOGStmp $dateiLOGS
    #fncDEBUGstop "Zeilennummern"
}
#fncLOGSzeilennummern

function fncLOGScheckFEHLER {
    flagFEHLERlogs="false"
    txtFEHLERlogs=""
    txtSTATUS=""
    if ( [[ "$1" == "" ]] )
    then
        actionCHECKfehlerLOGS="checkJA.auslesenNEIN"
    else
        actionCHECKfehlerLOGS="$1"
    fi
    
    while read txtSTATUS
    do
        # -Logdatei auf Fehler kontrollieren und Flag setzen:
        if ( ( [[ "$txtSTATUS" == *ERROR* ]] || [[ "$txtSTATUS" == *Error* ]] || [[ "$txtSTATUS" == *error* ]] ) && [[ "$txtSTATUS" != *Terror* ]] && [[ "$txtSTATUS" != *terror* ]] )
        then
            flagFEHLERlogs="true"
            #flagERFOLGREICHabgeschlossen="false"
            if ( [[ "$actionCHECKfehlerLOGS" != "checkJA.auslesenJA" ]] )
            then
                return 12
            fi
            
            if ( [[ "$txtFEHLERlogs" == "" ]] )
            then
                txtFEHLERlogs=\\n$txtHR\\n"|- Fehlermeldungen:"
            fi
            txtFEHLERlogs="$txtFEHLERlogs"\\n"$txtSTATUS"
        fi
    done < $dateiLOGS
    return 11
}
fncLOGScheckFEHLER "checkJA.auslesenNEIN"

function fncLOGSkopieren {
    # -Eine Sicherung der Logdatei anlegen!
    # -Mit Zeitstempel der Startzeit: $zeitSTARTdateiname
    cp $dateiLOGS $dateiLOGSsicherung
    rm $dateiLOGStmpOHNEzeilennummern
}

function fncEINGABEreadMENUende {
    #echo -e "--- DEBUG-INFOS: flagFEHLERlogs: $flagFEHLERlogs - flagERFOLGREICHabgeschlossen: $flagERFOLGREICHabgeschlossen"
    echo -e "|- NEUSTART\\t'y'\\tDas Skript mit den gleichen Optionen und URLs einfach neu starten."
    echo -e "|- ENDE\\t\\t'q'\\tDas Skript beenden."
    echo -e "|- ENDE-LOGS\\t'l'\\tDas Skript beenden und dann die aktuelle Logdatei anzeigen."
    echo -e "|-"
    echo -en "|- Ihre Eingabe (y/q/l): "

    function getCPos { 
        local v=() t=$(stty -g)
        stty -echo
        printf "\033[6n"
        IFS='[;' read -ra v -d R
        stty $t
        CPos=(${v[@]:1})
    }
    getCPos
    typeset -i cursorZEILE=0
    cursorZEILE=$CPos
    cursorZEILE=cursorZEILE-1
    cursorZEILEminus1=cursorZEILE-1
    cursorZEILEminus2=cursorZEILE-2
    zeileDELETE=`tput dl1`
    zeileINSERT=`tput il1`

    eingabeNEUSTART=""
    strBEFEHLnachQUIT=""
    while ( [[ "$eingabeNEUSTART" != "y" ]] && [[ "$eingabeNEUSTART" != "q" ]] && [[ "$eingabeNEUSTART" != "l" ]] )
    do
        read -n 1 -t 1 -s eingabeNEUSTART
        #read -n 1 -s eingabeNEUSTART
        
        case "$eingabeNEUSTART" in
            ("y")
                #echo -e $eingabeNEUSTART\\n"--- Neustart"
                flagNEUSTART="true"
                flagERFOLGREICHabgeschlossen="false"
                #cp $dateiLOGStmpOHNEzeilennummern $dateiLOGS
                break
                ;;
            ("q")
                echo -e $eingabeNEUSTART\\n"|- Das Skript wird jetzt beendet! Bitte haben Sie ein wenig Geduld, während die"\\n"|- Daten gesichert werden."
                flagERFOLGREICHabgeschlossen="true"
                break
                ;;
            ("l" )
                echo -e $eingabeNEUSTART\\n"|- Das Skript wird jetzt beendet! Bitte haben Sie ein wenig Geduld, während die"\\n"|- Daten gesichert werden. Die Logdatei wird danach angezeigt."
                #strBEFEHLnachQUIT="$datei -l"
                strBEFEHLnachQUIT="fncAUSGABElogdatei $dateiLOGS"
                flagERFOLGREICHabgeschlossen="true"
                break
                ;;
            ( * )
                echo -en $zeileDELETE
                tput cup $cursorZEILE 0
                echo -en "|- Ihre Eingabe (y/q/l): "
                ;;
        esac
    done
}







if ( [[ "$checkBEFEHLreturn" != "0" ]] || [[ "$flagFEHLERlogs" == "true" ]] )
then
    # -Wegen Kontrolle erfolgreich NEUSTART muss flagERFOLGREICHabgeschlossen auf true gesetzt werden:
    #flagERFOLGREICHabgeschlossen="true"
    
    txtINFOendeABBRUCH=""
#     if ( [[ "$checkBEFEHLreturn" == "1" ]] )
#     then
#         txtINFOendeABBRUCH="|- FEHLER:\t$datei wurde vom Benutzer abgebrochen!"\\n
#         # -Wegen Kontrolle erfolgreich NEUSTART muss flagERFOLGREICHabgeschlossen auf true gesetzt werden:
#         #flagERFOLGREICHabgeschlossen="true"
#     fi
    #txtINFOende2="|- "\\n"|- FEHLER:\t$datei wurde abgebrochen!"\\n"|-"
    if ( [[ "$flagQUIT" == *tasteF-status0* ]] )
    then
        txtINFOende1="|- INFO: \tDa das Skript vom Benutzer vorzeitig beendet wurde, werden die eingegebenen"\\n"|-\t\tURLs gespeichert. Beim nächsten Aufruf von $datei im gerade verwendeten"\\n"|-\t\tArbeitsverzeichnis werden diese automatisch übernommen."\\n"|-"
    else
        txtINFOende1=""
    fi
    if ( [[ "$flagFEHLERlogs" == "true" ]] )
    then
        txtINFOende2="|- FEHLER:\tEinige Befehle wurden leider nicht erfolgreich abgeschlossen!"\\n"|- INFO:\tDie Fehlermeldungen finden Sie zusammen gefasst am Ende der Logdatei."\\n"|-\t\tDie Logdatei wird immer im Arbeitsverzeichnis des Skripts abgespeichert."\\n"|-\t\t'$datei -h' Zum Anzeigen der Hilfe"\\n"|-"
    else
        txtINFOende2=""
    fi
    # -FEHLER Sound:
    beep -l 200 -f 200 -r 2 -D 100 --new -l 600 -f 160 -D 100
    
    if ( [[ "$txtINFOende1" != "" ]] )
    then
        echo -e $txtINFOende1
        #txtINFOende2=$txtINFOende2$txtFEHLERlogs
        echo -e $txtINFOende1 >> $dateiLOGS
    fi
    if ( [[ "$txtINFOende2" != "" ]] )
    then
        echo -e $txtINFOende2
        #txtINFOende2=$txtINFOende2$txtFEHLERlogs
        echo -e $txtINFOende2 >> $dateiLOGS
    fi
    
    # -Die Cache Datei mit dem flagCHECKurlsKOMPLETT Status löschen:
    if ( [[ -f "$dateiCACHEflagCHECKurlsKOMPLETT" ]] )
    then
        rm "$dateiCACHEflagCHECKurlsKOMPLETT"
    fi
    # -Die Cache Datei mit dem flagQUIT Status löschen:
    if ( [[ -f "$dateiCACHEflagQUIT" ]] )
    then
        rm "$dateiCACHEflagQUIT"
    fi
    # -Die Cache Datei mit den Playlist Infos löschen:
    if ( [[ -f "$dateiCACHEplsINFOS" ]] )
    then
        rm "$dateiCACHEplsINFOS"
    fi
    # -Die Cache Datei mit der Playlist Info Item löschen:
    if ( [[ -f "$dateiCACHEplsINFOSitem" ]] )
    then
        rm "$dateiCACHEplsINFOSitem"
    fi
    
#     if ( [[ "$flagFEHLERlogs" == "true" ]] )
#     then
#         fncEINGABEreadMENUende
#     fi
#     if ( [[ "$flagERFOLGREICHabgeschlossen" == "true" ]] )
#     then
#         # -Die temporäre Logdatei wird entfernt:
#         #rm $dateiLOGStmp
#         # -Sicherung der Logdatei mit Zeitstempel wird nur angelegt wenn das Skript
#         #  wirklich beendet wird:
#         fncLOGSkopieren
#     fi
    
else 
    
    # -Wegen Kontrolle erfolgreich NEUSTART muss flagERFOLGREICHabgeschlossen auf true gesetzt werden:
    #flagERFOLGREICHabgeschlossen="true"
    
    #txtINFOende2="|- "\\n"|- $datei wurde erfolgreich beendet!"\\n"|-"
    # -Erfolgreich Sound:
    beep -l 200 -f 600 -r 2 -D 100 --new -l 600 -f 600 -D 100
    #echo -e $txtINFOende2
    #echo -e $txtINFOende2 >> $dateiLOGS
    # -Sicherung der Logdatei mit Zeitstempel anlegen:
    #fncLOGSkopieren

    if ( [[ -f "$dateiURLS" ]] )
    then
        rm "$dateiURLS"
    fi

    # -Die Cache Datei mit dem flagCHECKurlsKOMPLETT Status löschen:
    if ( [[ -f "$dateiCACHEflagCHECKurlsKOMPLETT" ]] )
    then
        rm "$dateiCACHEflagCHECKurlsKOMPLETT"
    fi
    # -Die Cache Datei mit dem flagQUIT Status löschen:
    if ( [[ -f "$dateiCACHEflagQUIT" ]] )
    then
        rm "$dateiCACHEflagQUIT"
    fi
    # -Die Cache Datei mit den Playlist Infos löschen:
    if ( [[ -f "$dateiCACHEplsINFOS" ]] )
    then
        rm "$dateiCACHEplsINFOS"
    fi
    # -Die Cache Datei mit der Playlist Info Item löschen:
    if ( [[ -f "$dateiCACHEplsINFOSitem" ]] )
    then
        rm "$dateiCACHEplsINFOSitem"
    fi
    
    # -Shutdown Option
    if ( [[ "$intOFFminuten" != "" ]] )
    then
        echo -e "|- Das System wird in $intOFFminuten min ausgeschaltet. Zum Abbrechen drücken Sie bitte: \"q\""
        intOFFsekunden=`echo -e "$intOFFminuten*60" | bc`
        #echo -e "--- sek: $intOFFsekunden ---"
        #sleep $intOFFsekunden
        #eingabeTASTE=`dd bs=1 count=1 2>/dev/null`
        intUTCsekunden=`date '+%s'`
        intOFFsekunden=`echo -e "$intUTCsekunden + $intOFFsekunden" | bc`
        while ( [[ "$eingabeTASTE" != "q" ]] && [[ "$intOFFsekunden" -gt "$intUTCsekunden" ]] )
        do
            read -n 1 -t 0.05 -s eingabeTASTE
            #tput cub 1
            intUTCsekunden=`date '+%s'`
        done
        
        if ( [[ "$eingabeTASTE" != "q" ]] )
        then
            echo -e "|- Ausschalten..."
            # -Ausschalten darf erst erfolgen, wenn fncLOGSzeilennummern und fncLOGSkopieren
            #  erfolgreich abgeschlossen wurden. Daher wird der $strBEFEHLnachQUIT dafür genutzt!
            #`/bin/systemctl poweroff`
            strBEFEHLnachQUIT="/bin/systemctl poweroff"
            flagERFOLGREICHabgeschlossen="true"
        else
            echo -e "|- Ausschalten wurde abgebrochen!"
        fi
    fi
fi
# +++++ ENDE Endkontrolle und Status anzeigen +++++++++++++++++++++++++++++++++
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


#strPSalleTHREADSalleCHILDS=`ps -e -T | grep $$`
#echo -e "$strPSalleTHREADSalleCHILDS"


# echo -e "DEBUG: flagQUIT: $flagQUIT"
# echo -e "DEBUG: flagQUITpsTasteF: $flagQUITpsTasteF"
# echo -e "DEBUG: flagFEHLERlogs: $flagFEHLERlogs"



#if ( [[ "$flagQUIT" == *truePS* ]] && [[ "$flagQUITpsTasteF" != "true" ]] && [[ "$flagFEHLERlogs" != "true" ]] )
if ( [[ "$checkBEFEHLreturn" == "0" ]] && [[ "$flagQUITpsTasteF" != "true" ]] && [[ "$flagFEHLERlogs" != "true" ]] && [[ "$FlagModusBefehlKOMPLETTquit" == "" ]] )
then
    # -Wenn das Skript problemlos beendet und kein Fehler in den Logs gefunden
    #  wird, wird kein MENUende angezeigt!
    # -Ansonsten kann der Nutzer entscheiden:
    # --Neustart
    # --Logs zeigen und Ende
    # --Ende
    flagERFOLGREICHabgeschlossen="true"
else
    fncEINGABEreadMENUende
fi



if ( [[ "$flagERFOLGREICHabgeschlossen" == "true" ]] )
then
    # -Nur wenn das Skript wirklich beendet wird:
    # --1. Zeilennummern in Logdatei einfügen: fncLOGSzeilennummern
    # --2. Fehlermeldungen am Ende der Logdatei zusammen fassen: fncLOGScheckFEHLER
    # --3. Sicherung der Logdatei mit Zeitstempel anlegen: fncLOGSkopieren
    
    # -Noch laufende Schreibzugriffe checken:
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncCHECKzugriffeLOGS\\t\\tSTART"
    fncCHECKzugriffeLOGS
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncCHECKzugriffeLOGS\\t\\tENDE"
    
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSzeilennummern\\t\\tSTART"
    fncLOGSzeilennummern
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSzeilennummern\\t\\tENDE"
    
    
    if ( [[ "$flagFEHLERlogs" == "true" ]] )
    then
        #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGScheckFEHLER\\t\\tSTART"
        fncLOGScheckFEHLER "checkJA.auslesenJA"
        #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGScheckFEHLER\\t\\tENDE"    
        
        echo -e $txtFEHLERlogs >> $dateiLOGS
    fi
    
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSkopieren\\t\\tSTART"
    fncLOGSkopieren
    #echo -e "--- `fncHHMMSS 'norm.mS2'` DEBUG: fncLOGSkopieren\\t\\tENDE"
    
fi




# -DEBUG-INFOS:
#echo -e "--- DEBUG-INFOS: flagFEHLERlogs: $flagFEHLERlogs - flagERFOLGREICHabgeschlossen: $flagERFOLGREICHabgeschlossen"

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# ::::: ENDE While Kontrolle erfolgreich NEUSTART :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
done


`echo -e $strBEFEHLnachQUIT` || echo -e "|- Der letzte Befehl ($strBEFEHLnachQUIT) konnte nicht erfolgreich ausgeführt werden."

echo -e "|- $datei ($$) wurde beendet."

exit 0;











